<BOF>
# Python program to find the factorial of a number provided by the user.

# change the value for a different result
num = 10

# uncomment to take input from the user
#num = int(input("Enter a number: "))

factorial = 1

# check if the number is negative, positive or zero
if num < 0:
   print("Sorry, factorial does not exist for negative numbers")
elif num == 0:
   print("The factorial of 0 is 1")
else:
   for i in range(1,num + 1):
       factorial = factorial*i
   print("The factorial of",num,"is",factorial)
<EOF>
<BOF>
import random

"""
A python implementation of the quick select algorithm, which is efficient for calculating the value that would appear in the index of a list if it would be sorted, even if it is not already sorted
https://en.wikipedia.org/wiki/Quickselect
"""
def _partition(data, pivot):
    """
    Three way partition the data into smaller, equal and greater lists,
    in relationship to the pivot
    :param data: The data to be sorted (a list)
    :param pivot: The value to partition the data on
    :return: Three list: smaller, equal and greater
    """
    less, equal, greater = [], [], []
    for element in data:
        if element.address < pivot.address:
            less.append(element)
        elif element.address > pivot.address:
            greater.append(element)
        else:
            equal.append(element)
    return less, equal, greater
    
def quickSelect(list, k):
    #k = len(list) // 2 when trying to find the median (index that value would be when list is sorted)
    smaller = []
    larger = []
    pivot = random.randint(0, len(list) - 1)
    pivot = list[pivot]
    count = 0
    smaller, equal, larger =_partition(list, pivot)
    count = len(equal)
    m = len(smaller)

    #k is the pivot
    if m <= k < m + count:
        return pivot
    # must be in smaller
    elif m > k:
        return quickSelect(smaller, k)
    #must be in larger
    else:
        return quickSelect(larger, k - (m + count))
<EOF>
<BOF>
"""
This is pure python implementation of Tabu search algorithm for a Travelling Salesman Problem, that the distances
between the cities are symmetric (the distance between city 'a' and city 'b' is the same between city 'b' and city 'a').
The TSP can be represented into a graph. The cities are represented by nodes and the distance between them is
represented by the weight of the ark between the nodes.

The .txt file with the graph has the form:

node1 node2 distance_between_node1_and_node2
node1 node3 distance_between_node1_and_node3
...

Be careful node1, node2 and the distance between them, must exist only once. This means in the .txt file
should not exist:
node1 node2 distance_between_node1_and_node2
node2 node1 distance_between_node2_and_node1

For pytests run following command:
pytest

For manual testing run:
python tabu_search.py -f your_file_name.txt -number_of_iterations_of_tabu_search -s size_of_tabu_search
e.g. python tabu_search.py -f tabudata2.txt -i 4 -s 3
"""

import copy
import argparse
import sys


def generate_neighbours(path):
    """
    Pure implementation of generating a dictionary of neighbors and the cost with each
    neighbor, given a path file that includes a graph.

    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)
    :return dict_of_neighbours: Dictionary with key each node and value a list of lists with the neighbors of the node
    and the cost (distance) for each neighbor.

    Example of dict_of_neighbours:
    >>> dict_of_neighbours[a]
    [[b,20],[c,18],[d,22],[e,26]]

    This indicates the neighbors of node (city) 'a', which has neighbor the node 'b' with distance 20,
    the node 'c' with distance 18, the node 'd' with distance 22 and the node 'e' with distance 26.

    """
    f = open(path, "r")

    dict_of_neighbours = {}

    for line in f:
        if line.split()[0] not in dict_of_neighbours:
            _list = list()
            _list.append([line.split()[1], line.split()[2]])
            dict_of_neighbours[line.split()[0]] = _list
        else:
            dict_of_neighbours[line.split()[0]].append([line.split()[1], line.split()[2]])
        if line.split()[1] not in dict_of_neighbours:
            _list = list()
            _list.append([line.split()[0], line.split()[2]])
            dict_of_neighbours[line.split()[1]] = _list
        else:
            dict_of_neighbours[line.split()[1]].append([line.split()[0], line.split()[2]])
    f.close()

    return dict_of_neighbours


def generate_first_solution(path, dict_of_neighbours):
    """
    Pure implementation of generating the first solution for the Tabu search to start, with the redundant resolution
    strategy. That means that we start from the starting node (e.g. node 'a'), then we go to the city nearest (lowest
    distance) to this node (let's assume is node 'c'), then we go to the nearest city of the node 'c', etc
    till we have visited all cities and return to the starting node.

    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)
    :param dict_of_neighbours: Dictionary with key each node and value a list of lists with the neighbors of the node
    and the cost (distance) for each neighbor.
    :return first_solution: The solution for the first iteration of Tabu search using the redundant resolution strategy
    in a list.
    :return distance_of_first_solution: The total distance that Travelling Salesman will travel, if he follows the path
    in first_solution.

    """

    f = open(path, "r")
    start_node = f.read(1)
    end_node = start_node

    first_solution = []

    visiting = start_node

    distance_of_first_solution = 0
    f.close()
    while visiting not in first_solution:
        minim = 10000
        for k in dict_of_neighbours[visiting]:
            if int(k[1]) < int(minim) and k[0] not in first_solution:
                minim = k[1]
                best_node = k[0]

        first_solution.append(visiting)
        distance_of_first_solution = distance_of_first_solution + int(minim)
        visiting = best_node

    first_solution.append(end_node)

    position = 0
    for k in dict_of_neighbours[first_solution[-2]]:
        if k[0] == start_node:
            break
        position += 1

    distance_of_first_solution = distance_of_first_solution + int(
        dict_of_neighbours[first_solution[-2]][position][1]) - 10000
    return first_solution, distance_of_first_solution


def find_neighborhood(solution, dict_of_neighbours):
    """
    Pure implementation of generating the neighborhood (sorted by total distance of each solution from
    lowest to highest) of a solution with 1-1 exchange method, that means we exchange each node in a solution with each
    other node and generating a number of solution named neighborhood.

    :param solution: The solution in which we want to find the neighborhood.
    :param dict_of_neighbours: Dictionary with key each node and value a list of lists with the neighbors of the node
    and the cost (distance) for each neighbor.
    :return neighborhood_of_solution: A list that includes the solutions and the total distance of each solution
    (in form of list) that are produced with 1-1 exchange from the solution that the method took as an input


    Example:
    >>> find_neighborhood(['a','c','b','d','e','a'])
    [['a','e','b','d','c','a',90], [['a','c','d','b','e','a',90],['a','d','b','c','e','a',93],
    ['a','c','b','e','d','a',102], ['a','c','e','d','b','a',113], ['a','b','c','d','e','a',93]]

    """

    neighborhood_of_solution = []

    for n in solution[1:-1]:
        idx1 = solution.index(n)
        for kn in solution[1:-1]:
            idx2 = solution.index(kn)
            if n == kn:
                continue

            _tmp = copy.deepcopy(solution)
            _tmp[idx1] = kn
            _tmp[idx2] = n

            distance = 0

            for k in _tmp[:-1]:
                next_node = _tmp[_tmp.index(k) + 1]
                for i in dict_of_neighbours[k]:
                    if i[0] == next_node:
                        distance = distance + int(i[1])
            _tmp.append(distance)

            if _tmp not in neighborhood_of_solution:
                neighborhood_of_solution.append(_tmp)

    indexOfLastItemInTheList = len(neighborhood_of_solution[0]) - 1

    neighborhood_of_solution.sort(key=lambda x: x[indexOfLastItemInTheList])
    return neighborhood_of_solution


def tabu_search(first_solution, distance_of_first_solution, dict_of_neighbours, iters, size):
    """
    Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in Python.

    :param first_solution: The solution for the first iteration of Tabu search using the redundant resolution strategy
    in a list.
    :param distance_of_first_solution: The total distance that Travelling Salesman will travel, if he follows the path
    in first_solution.
    :param dict_of_neighbours: Dictionary with key each node and value a list of lists with the neighbors of the node
    and the cost (distance) for each neighbor.
    :param iters: The number of iterations that Tabu search will execute.
    :param size: The size of Tabu List.
    :return best_solution_ever: The solution with the lowest distance that occured during the execution of Tabu search.
    :return best_cost: The total distance that Travelling Salesman will travel, if he follows the path in best_solution
    ever.

    """
    count = 1
    solution = first_solution
    tabu_list = list()
    best_cost = distance_of_first_solution
    best_solution_ever = solution

    while count <= iters:
        neighborhood = find_neighborhood(solution, dict_of_neighbours)
        index_of_best_solution = 0
        best_solution = neighborhood[index_of_best_solution]
        best_cost_index = len(best_solution) - 1

        found = False
        while found is False:
            i = 0
            while i < len(best_solution):

                if best_solution[i] != solution[i]:
                    first_exchange_node = best_solution[i]
                    second_exchange_node = solution[i]
                    break
                i = i + 1

            if [first_exchange_node, second_exchange_node] not in tabu_list and [second_exchange_node,
                                                                                 first_exchange_node] not in tabu_list:
                tabu_list.append([first_exchange_node, second_exchange_node])
                found = True
                solution = best_solution[:-1]
                cost = neighborhood[index_of_best_solution][best_cost_index]
                if cost < best_cost:
                    best_cost = cost
                    best_solution_ever = solution
            else:
                index_of_best_solution = index_of_best_solution + 1
                best_solution = neighborhood[index_of_best_solution]

        if len(tabu_list) >= size:
            tabu_list.pop(0)

        count = count + 1

    return best_solution_ever, best_cost


def main(args=None):
    dict_of_neighbours = generate_neighbours(args.File)

    first_solution, distance_of_first_solution = generate_first_solution(args.File, dict_of_neighbours)

    best_sol, best_cost = tabu_search(first_solution, distance_of_first_solution, dict_of_neighbours, args.Iterations,
                                      args.Size)

    print("Best solution: {0}, with total distance: {1}.".format(best_sol, best_cost))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Tabu Search")
    parser.add_argument(
        "-f", "--File", type=str, help="Path to the file containing the data", required=True)
    parser.add_argument(
        "-i", "--Iterations", type=int, help="How many iterations the algorithm should perform", required=True)
    parser.add_argument(
        "-s", "--Size", type=int, help="Size of the tabu list", required=True)

    # Pass the arguments to main method
    sys.exit(main(parser.parse_args()))
<EOF>
<BOF>
"""
This is pure python implementation of sentinel linear search algorithm

For doctests run following command:
python -m doctest -v sentinel_linear_search.py
or
python3 -m doctest -v sentinel_linear_search.py

For manual testing run:
python sentinel_linear_search.py
"""

def sentinel_linear_search(sequence, target):
    """Pure implementation of sentinel linear search algorithm in Python

    :param sequence: some sequence with comparable items
    :param target: item value to search
    :return: index of found item or None if item is not found

    Examples:
    >>> sentinel_linear_search([0, 5, 7, 10, 15], 0)
    0

    >>> sentinel_linear_search([0, 5, 7, 10, 15], 15)
    4

    >>> sentinel_linear_search([0, 5, 7, 10, 15], 5)
    1

    >>> sentinel_linear_search([0, 5, 7, 10, 15], 6)

    """
    sequence.append(target)

    index = 0
    while sequence[index] != target:
        index += 1

    sequence.pop()

    if index == len(sequence):
        return None

    return index


if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by comma:\n').strip()
    sequence = [int(item) for item in user_input.split(',')]

    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result = sentinel_linear_search(sequence, target)
    if result is not None:
        print('{} found at positions: {}'.format(target, result))
    else:
        print('Not found')
<EOF>
<BOF>
"""
This is pure python implementation of interpolation search algorithm
"""
from __future__ import print_function

try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3


def interpolation_search(sorted_collection, item):
    """Pure implementation of interpolation search algorithm in Python
    Be careful collection must be sorted, otherwise result will be
    unpredictable
    :param sorted_collection: some sorted collection with comparable items
    :param item: item value to search
    :return: index of found item or None if item is not found
    """
    left = 0
    right = len(sorted_collection) - 1

    while left <= right:
        point = left + ((item - sorted_collection[left]) * (right - left)) // (sorted_collection[right] - sorted_collection[left])
        
        #out of range check
        if point<0 or point>=len(sorted_collection):
            return None

        current_item = sorted_collection[point]
        if current_item == item:
            return point
        else:
            if item < current_item:
                right = point - 1
            else:
                left = point + 1
    return None


def interpolation_search_by_recursion(sorted_collection, item, left, right):

    """Pure implementation of interpolation search algorithm in Python by recursion
    Be careful collection must be sorted, otherwise result will be
    unpredictable
    First recursion should be started with left=0 and right=(len(sorted_collection)-1)
    :param sorted_collection: some sorted collection with comparable items
    :param item: item value to search
    :return: index of found item or None if item is not found
    """
    point = left + ((item - sorted_collection[left]) * (right - left)) // (sorted_collection[right] - sorted_collection[left])

    #out of range check
    if point<0 or point>=len(sorted_collection):
        return None

    if sorted_collection[point] == item:
        return point
    elif sorted_collection[point] > item:
        return interpolation_search_by_recursion(sorted_collection, item, left, point-1)
    else:
        return interpolation_search_by_recursion(sorted_collection, item, point+1, right)
      
def __assert_sorted(collection):
    """Check if collection is sorted, if not - raises :py:class:`ValueError`
    :param collection: collection
    :return: True if collection is sorted
    :raise: :py:class:`ValueError` if collection is not sorted
    Examples:
    >>> __assert_sorted([0, 1, 2, 4])
    True
    >>> __assert_sorted([10, -1, 5])
    Traceback (most recent call last):
    ...
    ValueError: Collection must be sorted
    """
    if collection != sorted(collection):
        raise ValueError('Collection must be sorted')
    return True


if __name__ == '__main__':
    import sys

    user_input = raw_input('Enter numbers separated by comma:\n').strip()
    collection = [int(item) for item in user_input.split(',')]
    try:
        __assert_sorted(collection)
    except ValueError:
        sys.exit('Sequence must be sorted to apply interpolation search')

    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result = interpolation_search(collection, target)
    if result is not None:
        print('{} found at positions: {}'.format(target, result))
    else:
        print('Not found')
<EOF>
<BOF>
'''
This is a type of divide and conquer algorithm which divides the search space into
3 parts and finds the target value based on the property of the array or list 
(usually monotonic property).

Time Complexity  : O(log3 N)
Space Complexity : O(1)
'''
from __future__ import print_function

import sys

try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3

# This is the precision for this function which can be altered.
# It is recommended for users to keep this number greater than or equal to 10.
precision = 10

# This is the linear search that will occur after the search space has become smaller.
def lin_search(left, right, A, target):
    for i in range(left, right+1):
        if(A[i] == target):
            return i

# This is the iterative method of the ternary search algorithm.
def ite_ternary_search(A, target):
    left = 0
    right = len(A) - 1;
    while(True):
        if(left<right):
            
            if(right-left < precision):
                return lin_search(left,right,A,target)

            oneThird = (left+right)/3+1;
            twoThird = 2*(left+right)/3+1;
            
            if(A[oneThird] == target):
                return oneThird
            elif(A[twoThird] == target):
                return twoThird
            
            elif(target < A[oneThird]):
                right = oneThird-1
            elif(A[twoThird] < target):
                left = twoThird+1
            
            else:
                left = oneThird+1
                right = twoThird-1
        else:
            return None

# This is the recursive method of the ternary search algorithm.
def rec_ternary_search(left, right, A, target):
    if(left<right):
        
        if(right-left < precision):
            return lin_search(left,right,A,target)

        oneThird = (left+right)/3+1;
        twoThird = 2*(left+right)/3+1;

        if(A[oneThird] == target):
            return oneThird
        elif(A[twoThird] == target):
            return twoThird
        
        elif(target < A[oneThird]):
            return rec_ternary_search(left, oneThird-1, A, target)
        elif(A[twoThird] < target):
            return rec_ternary_search(twoThird+1, right, A, target)
        
        else:
            return rec_ternary_search(oneThird+1, twoThird-1, A, target)
    else:
        return None

# This function is to check if the array is sorted.
def __assert_sorted(collection):
    if collection != sorted(collection):
        raise ValueError('Collection must be sorted')
    return True


if __name__ == '__main__':
    user_input = raw_input('Enter numbers separated by coma:\n').strip()
    collection = [int(item) for item in user_input.split(',')]

    try:
        __assert_sorted(collection)
    except ValueError:
        sys.exit('Sequence must be sorted to apply the ternary search')

    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result1 = ite_ternary_search(collection, target)
    result2 = rec_ternary_search(0, len(collection)-1, collection, target)
    
    if result2 is not None:
        print('Iterative search: {} found at positions: {}'.format(target, result1))
        print('Recursive search: {} found at positions: {}'.format(target, result2))
    else:
        print('Not found')
<EOF>
<BOF>
from __future__ import print_function
import math
def jump_search(arr, x):
    n = len(arr)
    step = int(math.floor(math.sqrt(n)))
    prev = 0
    while arr[min(step, n)-1] < x:
        prev = step
        step += int(math.floor(math.sqrt(n)))
        if prev >= n:
            return -1

    while arr[prev] < x:
        prev = prev + 1
        if prev == min(step, n):
            return -1
    if arr[prev] == x:
        return prev
    return -1



arr = [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
x = 55
index = jump_search(arr, x)
print("\nNumber " + str(x) +" is at index " + str(index));
<EOF>
<BOF>
"""
This is pure python implementation of linear search algorithm

For doctests run following command:
python -m doctest -v linear_search.py
or
python3 -m doctest -v linear_search.py

For manual testing run:
python linear_search.py
"""
from __future__ import print_function

try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3

def linear_search(sequence, target):
    """Pure implementation of linear search algorithm in Python

    :param sequence: some sorted collection with comparable items
    :param target: item value to search
    :return: index of found item or None if item is not found

    Examples:
    >>> linear_search([0, 5, 7, 10, 15], 0)
    0

    >>> linear_search([0, 5, 7, 10, 15], 15)
    4

    >>> linear_search([0, 5, 7, 10, 15], 5)
    1

    >>> linear_search([0, 5, 7, 10, 15], 6)

    """
    for index, item in enumerate(sequence):
        if item == target:
            return index
    return None


if __name__ == '__main__':
    user_input = raw_input('Enter numbers separated by coma:\n').strip()
    sequence = [int(item) for item in user_input.split(',')]

    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result = linear_search(sequence, target)
    if result is not None:
        print('{} found at positions: {}'.format(target, result))
    else:
        print('Not found')
<EOF>
<BOF>
import unittest
import os
from tabu_search import generate_neighbours, generate_first_solution, find_neighborhood, tabu_search

TEST_FILE = os.path.join(os.path.dirname(__file__), './tabu_test_data.txt')

NEIGHBOURS_DICT = {'a': [['b', '20'], ['c', '18'], ['d', '22'], ['e', '26']],
                   'c': [['a', '18'], ['b', '10'], ['d', '23'], ['e', '24']],
                   'b': [['a', '20'], ['c', '10'], ['d', '11'], ['e', '12']],
                   'e': [['a', '26'], ['b', '12'], ['c', '24'], ['d', '40']],
                   'd': [['a', '22'], ['b', '11'], ['c', '23'], ['e', '40']]}

FIRST_SOLUTION = ['a', 'c', 'b', 'd', 'e', 'a']

DISTANCE = 105

NEIGHBOURHOOD_OF_SOLUTIONS = [['a', 'e', 'b', 'd', 'c', 'a', 90],
                              ['a', 'c', 'd', 'b', 'e', 'a', 90],
                              ['a', 'd', 'b', 'c', 'e', 'a', 93],
                              ['a', 'c', 'b', 'e', 'd', 'a', 102],
                              ['a', 'c', 'e', 'd', 'b', 'a', 113],
                              ['a', 'b', 'c', 'd', 'e', 'a', 119]]


class TestClass(unittest.TestCase):
    def test_generate_neighbours(self):
        neighbours = generate_neighbours(TEST_FILE)

        self.assertEquals(NEIGHBOURS_DICT, neighbours)

    def test_generate_first_solutions(self):
        first_solution, distance = generate_first_solution(TEST_FILE, NEIGHBOURS_DICT)

        self.assertEquals(FIRST_SOLUTION, first_solution)
        self.assertEquals(DISTANCE, distance)

    def test_find_neighbours(self):
        neighbour_of_solutions = find_neighborhood(FIRST_SOLUTION, NEIGHBOURS_DICT)

        self.assertEquals(NEIGHBOURHOOD_OF_SOLUTIONS, neighbour_of_solutions)

    def test_tabu_search(self):
        best_sol, best_cost = tabu_search(FIRST_SOLUTION, DISTANCE, NEIGHBOURS_DICT, 4, 3)

        self.assertEquals(['a', 'd', 'b', 'e', 'c', 'a'], best_sol)
        self.assertEquals(87, best_cost)
<EOF>
<BOF>
"""
This is pure python implementation of binary search algorithm

For doctests run following command:
python -m doctest -v binary_search.py
or
python3 -m doctest -v binary_search.py

For manual testing run:
python binary_search.py
"""
from __future__ import print_function
import bisect

try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3


def binary_search(sorted_collection, item):
    """Pure implementation of binary search algorithm in Python

    Be careful collection must be sorted, otherwise result will be
    unpredictable

    :param sorted_collection: some sorted collection with comparable items
    :param item: item value to search
    :return: index of found item or None if item is not found

    Examples:
    >>> binary_search([0, 5, 7, 10, 15], 0)
    0

    >>> binary_search([0, 5, 7, 10, 15], 15)
    4

    >>> binary_search([0, 5, 7, 10, 15], 5)
    1

    >>> binary_search([0, 5, 7, 10, 15], 6)

    """
    left = 0
    right = len(sorted_collection) - 1

    while left <= right:
        midpoint = (left + right) // 2
        current_item = sorted_collection[midpoint]
        if current_item == item:
            return midpoint
        else:
            if item < current_item:
                right = midpoint - 1
            else:
                left = midpoint + 1
    return None


def binary_search_std_lib(sorted_collection, item):
    """Pure implementation of binary search algorithm in Python using stdlib

    Be careful collection must be sorted, otherwise result will be
    unpredictable

    :param sorted_collection: some sorted collection with comparable items
    :param item: item value to search
    :return: index of found item or None if item is not found

    Examples:
    >>> binary_search_std_lib([0, 5, 7, 10, 15], 0)
    0

    >>> binary_search_std_lib([0, 5, 7, 10, 15], 15)
    4

    >>> binary_search_std_lib([0, 5, 7, 10, 15], 5)
    1

    >>> binary_search_std_lib([0, 5, 7, 10, 15], 6)

    """
    index = bisect.bisect_left(sorted_collection, item)
    if index != len(sorted_collection) and sorted_collection[index] == item:
        return index
    return None

def binary_search_by_recursion(sorted_collection, item, left, right):

    """Pure implementation of binary search algorithm in Python by recursion

    Be careful collection must be sorted, otherwise result will be
    unpredictable
    First recursion should be started with left=0 and right=(len(sorted_collection)-1)

    :param sorted_collection: some sorted collection with comparable items
    :param item: item value to search
    :return: index of found item or None if item is not found

    Examples:
    >>> binary_search_std_lib([0, 5, 7, 10, 15], 0)
    0

    >>> binary_search_std_lib([0, 5, 7, 10, 15], 15)
    4

    >>> binary_search_std_lib([0, 5, 7, 10, 15], 5)
    1

    >>> binary_search_std_lib([0, 5, 7, 10, 15], 6)

    """
    if (right < left):
        return None
    
    midpoint = left + (right - left) // 2

    if sorted_collection[midpoint] == item:
        return midpoint
    elif sorted_collection[midpoint] > item:
        return binary_search_by_recursion(sorted_collection, item, left, midpoint-1)
    else:
        return binary_search_by_recursion(sorted_collection, item, midpoint+1, right)
      
def __assert_sorted(collection):
    """Check if collection is sorted, if not - raises :py:class:`ValueError`

    :param collection: collection
    :return: True if collection is sorted
    :raise: :py:class:`ValueError` if collection is not sorted

    Examples:
    >>> __assert_sorted([0, 1, 2, 4])
    True

    >>> __assert_sorted([10, -1, 5])
    Traceback (most recent call last):
    ...
    ValueError: Collection must be sorted
    """
    if collection != sorted(collection):
        raise ValueError('Collection must be sorted')
    return True


if __name__ == '__main__':
    import sys
    user_input = raw_input('Enter numbers separated by comma:\n').strip()
    collection = [int(item) for item in user_input.split(',')]
    try:
        __assert_sorted(collection)
    except ValueError:
        sys.exit('Sequence must be sorted to apply binary search')

    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result = binary_search(collection, target)
    if result is not None:
        print('{} found at positions: {}'.format(target, result))
    else:
        print('Not found')
<EOF>
<BOF>
from __future__ import print_function
#     a
#    / \
#   b  c
#  / \
# d  e
edges = {'a': ['c', 'b'], 'b': ['d', 'e'], 'c': [], 'd': [], 'e': []}
vertices = ['a', 'b', 'c', 'd', 'e']


def topological_sort(start, visited, sort):
    """Perform topolical sort on a directed acyclic graph."""
    current = start
    # add current to visited
    visited.append(current)
    neighbors = edges[current]
    for neighbor in neighbors:
        # if neighbor not in visited, visit
        if neighbor not in visited:
            sort = topological_sort(neighbor, visited, sort)
    # if all neighbors visited add current to sort
    sort.append(current)
    # if all vertices haven't been visited select a new one to visit
    if len(visited) != len(vertices):
        for vertice in vertices:
            if vertice not in visited:
                sort = topological_sort(vertice, visited, sort)
    # return sort
    return sort


sort = topological_sort('a', [], [])
print(sort)
<EOF>
<BOF>
# Code contributed by Honey Sharma
from __future__ import print_function


def cycle_sort(array):
    ans = 0

    # Pass through the array to find cycles to rotate.
    for cycleStart in range(0, len(array) - 1):
        item = array[cycleStart]

        # finding the position for putting the item.
        pos = cycleStart
        for i in range(cycleStart + 1, len(array)):
            if array[i] < item:
                pos += 1

        # If the item is already present-not a cycle.
        if pos == cycleStart:
            continue

        # Otherwise, put the item there or right after any duplicates.
        while item == array[pos]:
            pos += 1
        array[pos], item = item, array[pos]
        ans += 1

        # Rotate the rest of the cycle.
        while pos != cycleStart:

            # Find where to put the item.
            pos = cycleStart
            for i in range(cycleStart + 1, len(array)):
                if array[i] < item:
                    pos += 1

            # Put the item there or right after any duplicates.
            while item == array[pos]:
                pos += 1
            array[pos], item = item, array[pos]
            ans += 1

    return ans


#  Main Code starts here
if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3
        
user_input = raw_input('Enter numbers separated by a comma:\n')
unsorted = [int(item) for item in user_input.split(',')]
n = len(unsorted)
cycle_sort(unsorted)

print("After sort : ")
for i in range(0, n):
    print(unsorted[i], end=' ')
<EOF>
<BOF>
"""
This is a pure python implementation of the selection sort algorithm

For doctests run following command:
python -m doctest -v selection_sort.py
or
python3 -m doctest -v selection_sort.py

For manual testing run:
python selection_sort.py
"""
from __future__ import print_function


def selection_sort(collection):
    """Pure implementation of the selection sort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending


    Examples:
    >>> selection_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> selection_sort([])
    []

    >>> selection_sort([-2, -5, -45])
    [-45, -5, -2]
    """

    length = len(collection)
    for i in range(length - 1):
        least = i
        for k in range(i + 1, length):
            if collection[k] < collection[least]:
                least = k
        collection[least], collection[i] = (
            collection[i], collection[least]
        )
    return collection


if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(selection_sort(unsorted))
<EOF>
<BOF>
"""
This is a pure python implementation of the shell sort algorithm

For doctests run following command:
python -m doctest -v shell_sort.py
or
python3 -m doctest -v shell_sort.py

For manual testing run:
python shell_sort.py
"""
from __future__ import print_function


def shell_sort(collection):
    """Pure implementation of shell sort algorithm in Python
    :param collection:  Some mutable ordered collection with heterogeneous
    comparable items inside
    :return:  the same collection ordered by ascending

    >>> shell_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> shell_sort([])
    []

    >>> shell_sort([-2, -5, -45])
    [-45, -5, -2]
    """
    # Marcin Ciura's gap sequence
    gaps = [701, 301, 132, 57, 23, 10, 4, 1]

    for gap in gaps:
        i = gap
        while i < len(collection):
            temp = collection[i]
            j = i
            while j >= gap and collection[j - gap] > temp:
                collection[j] = collection[j - gap]
                j -= gap
            collection[j] = temp
            i += 1

    return collection

if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(shell_sort(unsorted))
<EOF>
<BOF>
from __future__ import print_function
from random import randint
from tempfile import TemporaryFile
import numpy as np



def _inPlaceQuickSort(A,start,end):  
    count = 0
    if start<end:
        pivot=randint(start,end)
        temp=A[end]
        A[end]=A[pivot]
        A[pivot]=temp
        
        p,count= _inPlacePartition(A,start,end)
        count += _inPlaceQuickSort(A,start,p-1)
        count += _inPlaceQuickSort(A,p+1,end)
    return count

def _inPlacePartition(A,start,end):
    
    count = 0
    pivot= randint(start,end)
    temp=A[end]
    A[end]=A[pivot]
    A[pivot]=temp
    newPivotIndex=start-1
    for index in range(start,end):
               
        count += 1
        if A[index]<A[end]:#check if current val is less than pivot value
            newPivotIndex=newPivotIndex+1
            temp=A[newPivotIndex]
            A[newPivotIndex]=A[index]
            A[index]=temp
    
    temp=A[newPivotIndex+1]
    A[newPivotIndex+1]=A[end]
    A[end]=temp
    return newPivotIndex+1,count
    
outfile = TemporaryFile()    
p = 100 # 1000 elements are to be sorted




mu, sigma = 0, 1 # mean and standard deviation
X = np.random.normal(mu, sigma, p)
np.save(outfile, X)
print('The array is')
print(X)

  
    



outfile.seek(0)  # using the same array
M = np.load(outfile)
r = (len(M)-1)
z = _inPlaceQuickSort(M,0,r) 

print("No of Comparisons for 100 elements selected from a standard normal distribution is :")
print(z)
<EOF>
<BOF>
# Tree_sort algorithm
# Build a BST and in order traverse.

class node():
    # BST data structure
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None 
    
    def insert(self,val):
        if self.val:
            if val < self.val:
                if self.left is None:
                    self.left = node(val)
                else:
                    self.left.insert(val)
            elif val > self.val:
                if self.right is None:
                    self.right = node(val)
                else:
                    self.right.insert(val)
        else:
            self.val = val

def inorder(root, res):
    # Recursive travesal 
    if root:
        inorder(root.left,res)
        res.append(root.val)
        inorder(root.right,res)

def treesort(arr):
    # Build BST
    if len(arr) == 0:
        return arr
    root = node(arr[0])
    for i in range(1,len(arr)):
        root.insert(arr[i])
    # Traverse BST in order. 
    res = []
    inorder(root,res)
    return res

print(treesort([10,1,3,2,9,14,13]))
<EOF>
<BOF>
'''
Python implementation of merge sort algorithm.
Takes an average of 0.6 microseconds to sort a list of length 1000 items.
Best Case Scenario : O(n)
Worst Case Scenario : O(n)
'''
def merge_sort(LIST):
    start = []
    end = []
    while len(LIST) > 1:
        a = min(LIST)
        b = max(LIST)
        start.append(a)
        end.append(b)
        LIST.remove(a)
        LIST.remove(b)
    if LIST: start.append(LIST[0])
    end.reverse()
    return (start + end)
<EOF>
<BOF>
# Pancake sort algorithm 
# Only can reverse array from 0 to i

def pancakesort(arr):
    cur = len(arr)
    while cur > 1:
        # Find the maximum number in arr
        mi = arr.index(max(arr[0:cur]))
        # Reverse from 0 to mi 
        arr = arr[mi::-1] + arr[mi+1:len(arr)]
        # Reverse whole list 
        arr = arr[cur-1::-1] + arr[cur:len(arr)]
        cur -= 1
    return arr

print(pancakesort([0,10,15,3,2,9,14,13]))
<EOF>
<BOF>
"""
This is a pure python implementation of the bogosort algorithm
For doctests run following command:
python -m doctest -v bogosort.py
or
python3 -m doctest -v bogosort.py
For manual testing run:
python bogosort.py
"""

from __future__ import print_function
import random


def bogosort(collection):
    """Pure implementation of the bogosort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending
    Examples:
    >>> bogosort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> bogosort([])
    []
    >>> bogosort([-2, -5, -45])
    [-45, -5, -2]
    """

    def isSorted(collection):
        if len(collection) < 2:
            return True
        for i in range(len(collection) - 1):
            if collection[i] > collection[i + 1]:
                return False
        return True

    while not isSorted(collection):
        random.shuffle(collection)
    return collection

if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(bogosort(unsorted))
<EOF>
<BOF>
"""
This is pure python implementation of counting sort algorithm
For doctests run following command:
python -m doctest -v counting_sort.py
or
python3 -m doctest -v counting_sort.py
For manual testing run:
python counting_sort.py
"""

from __future__ import print_function


def counting_sort(collection):
    """Pure implementation of counting sort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending
    Examples:
    >>> counting_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> counting_sort([])
    []
    >>> counting_sort([-2, -5, -45])
    [-45, -5, -2]
    """
    # if the collection is empty, returns empty
    if collection == []:
        return []

    # get some information about the collection
    coll_len = len(collection)
    coll_max = max(collection)
    coll_min = min(collection)

    # create the counting array
    counting_arr_length = coll_max + 1 - coll_min
    counting_arr = [0] * counting_arr_length

    # count how much a number appears in the collection
    for number in collection:
        counting_arr[number - coll_min] += 1

    # sum each position with it's predecessors. now, counting_arr[i] tells
    # us how many elements <= i has in the collection
    for i in range(1, counting_arr_length):
        counting_arr[i] = counting_arr[i] + counting_arr[i-1]

    # create the output collection
    ordered = [0] * coll_len

    # place the elements in the output, respecting the original order (stable
    # sort) from end to begin, updating counting_arr
    for i in reversed(range(0, coll_len)):
        ordered[counting_arr[collection[i] - coll_min]-1] = collection[i]
        counting_arr[collection[i] - coll_min] -= 1

    return ordered

def counting_sort_string(string):
    return ''.join([chr(i) for i in counting_sort([ord(c) for c in string])])


if __name__ == '__main__':
    # Test string sort
    assert "eghhiiinrsssttt" == counting_sort_string("thisisthestring")

    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(counting_sort(unsorted))
<EOF>
<BOF>
"""
Comb sort is a relatively simple sorting algorithm originally designed by Wlodzimierz Dobosiewicz in 1980.
Later it was rediscovered by Stephen Lacey and Richard Box in 1991. Comb sort improves on bubble sort.

This is pure python implementation of comb sort algorithm
For doctests run following command:
python -m doctest -v comb_sort.py
or
python3 -m doctest -v comb_sort.py

For manual testing run:
python comb_sort.py
"""

def comb_sort(data):
    """Pure implementation of comb sort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending
    Examples:
    >>> comb_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> comb_sort([])
    []
    >>> comb_sort([-2, -5, -45])
    [-45, -5, -2]
    """
    shrink_factor = 1.3
    gap = len(data)
    swapped = True
    i = 0

    while gap > 1 or swapped:
        # Update the gap value for a next comb
        gap = int(float(gap) / shrink_factor)

        swapped = False
        i = 0

        while gap + i < len(data):
            if data[i] > data[i+gap]:
                # Swap values
                data[i], data[i+gap] = data[i+gap], data[i]
                swapped = True
            i += 1

    return data


if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(comb_sort(unsorted))
<EOF>
<BOF>
"""
This is a pure python implementation of the merge sort algorithm

For doctests run following command:
python -m doctest -v merge_sort.py
or
python3 -m doctest -v merge_sort.py

For manual testing run:
python merge_sort.py
"""
from __future__ import print_function


def merge_sort(collection):
    """Pure implementation of the merge sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> merge_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> merge_sort([])
    []

    >>> merge_sort([-2, -5, -45])
    [-45, -5, -2]
    """
    length = len(collection)
    if length > 1:
        midpoint = length // 2
        left_half = merge_sort(collection[:midpoint])
        right_half = merge_sort(collection[midpoint:])
        i = 0
        j = 0
        k = 0
        left_length = len(left_half)
        right_length = len(right_half)
        while i < left_length and j < right_length:
            if left_half[i] < right_half[j]:
                collection[k] = left_half[i]
                i += 1
            else:
                collection[k] = right_half[j]
                j += 1
            k += 1

        while i < left_length:
            collection[k] = left_half[i]
            i += 1
            k += 1

        while j < right_length:
            collection[k] = right_half[j]
            j += 1
            k += 1

    return collection


if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(merge_sort(unsorted))
<EOF>
<BOF>
from __future__ import print_function
def binary_search(lst, item, start, end):
    if start == end:
        if lst[start] > item:
            return start
        else:
            return start + 1
    if start > end:
        return start

    mid = (start + end) // 2
    if lst[mid] < item:
        return binary_search(lst, item, mid + 1, end)
    elif lst[mid] > item:
        return binary_search(lst, item, start, mid - 1)
    else:
        return mid


def insertion_sort(lst):
    length = len(lst)

    for index in range(1, length):
        value = lst[index]
        pos = binary_search(lst, value, 0, index - 1)
        lst = lst[:pos] + [value] + lst[pos:index] + lst[index+1:]

    return lst


def merge(left, right):
    if not left:
        return right

    if not right:
        return left

    if left[0] < right[0]:
        return [left[0]] + merge(left[1:], right)

    return [right[0]] + merge(left, right[1:])


def timsort(lst):
    runs, sorted_runs = [], []
    length = len(lst)
    new_run = [lst[0]]
    sorted_array = []

    for i in range(1, length):
        if i == length - 1:
            new_run.append(lst[i])
            runs.append(new_run)
            break

        if lst[i] < lst[i - 1]:
            if not new_run:
                runs.append([lst[i - 1]])
                new_run.append(lst[i])
            else:
                runs.append(new_run)
                new_run = []
        else:
            new_run.append(lst[i])

    for run in runs:
        sorted_runs.append(insertion_sort(run))

    for run in sorted_runs:
        sorted_array = merge(sorted_array, run)

    return sorted_array


def main():

    lst = [5,9,10,3,-4,5,178,92,46,-18,0,7]
    sorted_lst = timsort(lst)
    print(sorted_lst)

if __name__ == '__main__':
    main()
<EOF>
<BOF>
#!/usr/bin/env python

#
# Sort large text files in a minimum amount of memory
#
import os
import argparse

class FileSplitter(object):
    BLOCK_FILENAME_FORMAT = 'block_{0}.dat'

    def __init__(self, filename):
        self.filename = filename
        self.block_filenames = []

    def write_block(self, data, block_number):
        filename = self.BLOCK_FILENAME_FORMAT.format(block_number)
        file = open(filename, 'w')
        file.write(data)
        file.close()
        self.block_filenames.append(filename)

    def get_block_filenames(self):
        return self.block_filenames

    def split(self, block_size, sort_key=None):
        file = open(self.filename, 'r')
        i = 0

        while True:
            lines = file.readlines(block_size)

            if lines == []:
                break

            if sort_key is None:
                lines.sort()
            else:
                lines.sort(key=sort_key)

            self.write_block(''.join(lines), i)
            i += 1

    def cleanup(self):
        map(lambda f: os.remove(f), self.block_filenames)


class NWayMerge(object):
    def select(self, choices):
        min_index = -1
        min_str = None

        for i in range(len(choices)):
            if min_str is None or choices[i] < min_str:
                min_index = i

        return min_index


class FilesArray(object):
    def __init__(self, files):
        self.files = files
        self.empty = set()
        self.num_buffers = len(files)
        self.buffers = {i: None for i in range(self.num_buffers)}

    def get_dict(self):
        return {i: self.buffers[i] for i in range(self.num_buffers) if i not in self.empty}

    def refresh(self):
        for i in range(self.num_buffers):
            if self.buffers[i] is None and i not in self.empty:
                self.buffers[i] = self.files[i].readline()

                if self.buffers[i] == '':
                    self.empty.add(i)

        if len(self.empty) == self.num_buffers:
            return False

        return True

    def unshift(self, index):
        value = self.buffers[index]
        self.buffers[index] = None

        return value


class FileMerger(object):
    def __init__(self, merge_strategy):
        self.merge_strategy = merge_strategy

    def merge(self, filenames, outfilename, buffer_size):
        outfile = open(outfilename, 'w', buffer_size)
        buffers = FilesArray(self.get_file_handles(filenames, buffer_size))

        while buffers.refresh():
            min_index = self.merge_strategy.select(buffers.get_dict())
            outfile.write(buffers.unshift(min_index))

    def get_file_handles(self, filenames, buffer_size):
        files = {}

        for i in range(len(filenames)):
            files[i] = open(filenames[i], 'r', buffer_size)

        return files



class ExternalSort(object):
    def __init__(self, block_size):
        self.block_size = block_size

    def sort(self, filename, sort_key=None):
        num_blocks = self.get_number_blocks(filename, self.block_size)
        splitter = FileSplitter(filename)
        splitter.split(self.block_size, sort_key)

        merger = FileMerger(NWayMerge())
        buffer_size = self.block_size / (num_blocks + 1)
        merger.merge(splitter.get_block_filenames(), filename + '.out', buffer_size)

        splitter.cleanup()

    def get_number_blocks(self, filename, block_size):
        return (os.stat(filename).st_size / block_size) + 1


def parse_memory(string):
    if string[-1].lower() == 'k':
        return int(string[:-1]) * 1024
    elif string[-1].lower() == 'm':
        return int(string[:-1]) * 1024 * 1024
    elif string[-1].lower() == 'g':
        return int(string[:-1]) * 1024 * 1024 * 1024
    else:
        return int(string)



def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-m',
                        '--mem',
                        help='amount of memory to use for sorting',
                        default='100M')
    parser.add_argument('filename',
                        metavar='<filename>',
                        nargs=1,
                        help='name of file to sort')
    args = parser.parse_args()

    sorter = ExternalSort(parse_memory(args.mem))
    sorter.sort(args.filename[0])


if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function


def bubble_sort(collection):
    """Pure implementation of bubble sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> bubble_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> bubble_sort([])
    []

    >>> bubble_sort([-2, -5, -45])
    [-45, -5, -2]
    
    >>> bubble_sort([-23,0,6,-4,34])
    [-23,-4,0,6,34]
    """
    length = len(collection)
    for i in range(length-1):
        swapped = False
        for j in range(length-1-i):
            if collection[j] > collection[j+1]:
                swapped = True
                collection[j], collection[j+1] = collection[j+1], collection[j]
        if not swapped: break  # Stop iteration if the collection is sorted.
    return collection


if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3
    user_input = raw_input('Enter numbers separated by a comma:').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(*bubble_sort(unsorted), sep=',')
<EOF>
<BOF>
"""
This is a pure python implementation of the insertion sort algorithm

For doctests run following command:
python -m doctest -v insertion_sort.py
or
python3 -m doctest -v insertion_sort.py

For manual testing run:
python insertion_sort.py
"""
from __future__ import print_function


def insertion_sort(collection):
    """Pure implementation of the insertion sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> insertion_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> insertion_sort([])
    []

    >>> insertion_sort([-2, -5, -45])
    [-45, -5, -2]
    """
    for index in range(1, len(collection)):
        while index > 0 and collection[index - 1] > collection[index]:
            collection[index], collection[index - 1] = collection[index - 1], collection[index]
            index -= 1

    return collection


if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(insertion_sort(unsorted))
<EOF>
<BOF>
from __future__ import print_function

def cocktail_shaker_sort(unsorted):
    """
    Pure implementation of the cocktail shaker sort algorithm in Python.
    """
    for i in range(len(unsorted)-1, 0, -1):
        swapped = False
        
        for j in range(i, 0, -1):
            if unsorted[j] < unsorted[j-1]:
                unsorted[j], unsorted[j-1] = unsorted[j-1], unsorted[j]
                swapped = True

        for j in range(i):
            if unsorted[j] > unsorted[j+1]:
                unsorted[j], unsorted[j+1] = unsorted[j+1], unsorted[j]
                swapped = True
        
        if not swapped:
            return unsorted
            
if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3
    
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    cocktail_shaker_sort(unsorted)
    print(unsorted)
<EOF>
<BOF>
'''
This is a pure python implementation of the heap sort algorithm.

For doctests run following command:
python -m doctest -v heap_sort.py
or
python3 -m doctest -v heap_sort.py

For manual testing run:
python heap_sort.py
'''

from __future__ import print_function


def heapify(unsorted, index, heap_size):
    largest = index
    left_index = 2 * index + 1
    right_index = 2 * index + 2
    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:
        largest = left_index

    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:
        largest = right_index

    if largest != index:
        unsorted[largest], unsorted[index] = unsorted[index], unsorted[largest]
        heapify(unsorted, largest, heap_size)


def heap_sort(unsorted):
    '''
    Pure implementation of the heap sort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> heap_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> heap_sort([])
    []

    >>> heap_sort([-2, -5, -45])
    [-45, -5, -2]
    '''
    n = len(unsorted)
    for i in range(n // 2 - 1, -1, -1):
        heapify(unsorted, i, n)
    for i in range(n - 1, 0, -1):
        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]
        heapify(unsorted, 0, i)
    return unsorted

if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(heap_sort(unsorted))
<EOF>
<BOF>
"""
This is a pure python implementation of the quick sort algorithm

For doctests run following command:
python -m doctest -v quick_sort.py
or
python3 -m doctest -v quick_sort.py

For manual testing run:
python quick_sort.py
"""
from __future__ import print_function


def quick_sort(ARRAY):
    """Pure implementation of quick sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> quick_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> quick_sort([])
    []

    >>> quick_sort([-2, -5, -45])
    [-45, -5, -2]
    """
    ARRAY_LENGTH = len(ARRAY)
    if( ARRAY_LENGTH <= 1):
        return ARRAY
    else:
        PIVOT = ARRAY[0]
        GREATER = [ element for element in ARRAY[1:] if element > PIVOT ]
        LESSER = [ element for element in ARRAY[1:] if element <= PIVOT ]
        return quick_sort(LESSER) + [PIVOT] + quick_sort(GREATER)


if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [ int(item) for item in user_input.split(',') ]
    print( quick_sort(unsorted) )
<EOF>
<BOF>
def radixsort(lst):
  RADIX = 10
  maxLength = False
  tmp , placement = -1, 1

  while not maxLength:
    maxLength = True
    # declare and initialize buckets
    buckets = [list() for _ in range( RADIX )]

    # split lst between lists
    for i in lst:
      tmp = int((i / placement) % RADIX)
      buckets[tmp].append(i)

      if maxLength and tmp > 0:
        maxLength = False

    # empty lists into lst array
    a = 0
    for b in range( RADIX ):
      buck = buckets[b]
      for i in buck:
        lst[a] = i
        a += 1

    # move to next
    placement *= RADIX
<EOF>
<BOF>
from __future__ import print_function

def gnome_sort(unsorted):
    """
    Pure implementation of the gnome sort algorithm in Python.
    """
    if len(unsorted) <= 1:
        return unsorted
        
    i = 1
    
    while i < len(unsorted):
        if unsorted[i-1] <= unsorted[i]:
            i += 1
        else:
            unsorted[i-1], unsorted[i] = unsorted[i], unsorted[i-1]
            i -= 1
            if (i == 0):
                i = 1
                
if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3
    
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    gnome_sort(unsorted)
    print(unsorted)
<EOF>
<BOF>
#!/usr/bin/env python
# Author: OMKAR PATHAK
# This program will illustrate how to implement bucket sort algorithm

# Wikipedia says: Bucket sort, or bin sort, is a sorting algorithm that works by distributing the
# elements of an array into a number of buckets. Each bucket is then sorted individually, either using
# a different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a
# distribution sort, and is a cousin of radix sort in the most to least significant digit flavour.
# Bucket sort is a generalization of pigeonhole sort. Bucket sort can be implemented with comparisons
# and therefore can also be considered a comparison sort algorithm. The computational complexity estimates
# involve the number of buckets.

#  Time Complexity of Solution:
#  Best Case O(n); Average Case O(n); Worst Case O(n)

from __future__ import print_function
from insertion_sort import insertion_sort
import math

DEFAULT_BUCKET_SIZE = 5

def bucketSort(myList, bucketSize=DEFAULT_BUCKET_SIZE):
    if(len(myList) == 0):
        print('You don\'t have any elements in array!')

    minValue = myList[0]
    maxValue = myList[0]

    # For finding minimum and maximum values
    for i in range(0, len(myList)):
        if myList[i] < minValue:
            minValue = myList[i]
        elif myList[i] > maxValue:
            maxValue = myList[i]

    # Initialize buckets
    bucketCount = math.floor((maxValue - minValue) / bucketSize) + 1
    buckets = []
    for i in range(0, bucketCount):
        buckets.append([])

    # For putting values in buckets
    for i in range(0, len(myList)):
        buckets[math.floor((myList[i] - minValue) / bucketSize)].append(myList[i])

    # Sort buckets and place back into input array
    sortedArray = []
    for i in range(0, len(buckets)):
        insertion_sort(buckets[i])
        for j in range(0, len(buckets[i])):
            sortedArray.append(buckets[i][j])

    return sortedArray

if __name__ == '__main__':
    sortedArray = bucketSort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95])
    print(sortedArray)
<EOF>
<BOF>
from __future__ import print_function

def quick_sort_3partition(sorting, left, right):
    if right <= left:
        return
    a = i = left
    b = right
    pivot = sorting[left]
    while i <= b:
        if sorting[i] < pivot:
            sorting[a], sorting[i] = sorting[i], sorting[a]
            a += 1
            i += 1
        elif sorting[i] > pivot:
            sorting[b], sorting[i] = sorting[i], sorting[b]
            b -= 1
        else:
            i += 1
    quick_sort_3partition(sorting, left, a - 1)
    quick_sort_3partition(sorting, b + 1, right)

if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [ int(item) for item in user_input.split(',') ]
    quick_sort_3partition(unsorted,0,len(unsorted)-1)
    print(unsorted)
<EOF>
<BOF>
# server

import socket                   # Import socket module

port = 60000                    # Reserve a port for your service.
s = socket.socket()             # Create a socket object
host = socket.gethostname()     # Get local machine name
s.bind((host, port))            # Bind to the port
s.listen(5)                     # Now wait for client connection.

print('Server listening....')

while True:
    conn, addr = s.accept()     # Establish connection with client.
    print('Got connection from', addr)
    data = conn.recv(1024)
    print('Server received', repr(data))

    filename = 'mytext.txt'
    f = open(filename, 'rb')
    in_data = f.read(1024)
    while (in_data):
       conn.send(in_data)
       print('Sent ', repr(in_data))
       in_data = f.read(1024)
    f.close()

    print('Done sending')
    conn.send('Thank you for connecting')
    conn.close()


# client side server

import socket                   # Import socket module

s = socket.socket()             # Create a socket object
host = socket.gethostname()     # Get local machine name
port = 60000                    # Reserve a port for your service.

s.connect((host, port))
s.send("Hello server!")

with open('received_file', 'wb') as f:
    print('file opened')
    while True:
        print('receiving data...')
        data = s.recv(1024)
        print('data=%s', (data))
        if not data:
            break
        # write data to a file
        f.write(data)

f.close()
print('Successfully get the file')
s.close()
print('connection closed')
<EOF>
<BOF>
"""
	File transfer protocol used to send and receive files using FTP server.
	Use credentials to provide access to the FTP client

	Note: Do not use root username & password for security reasons
	  Create a seperate user and provide access to a home directory of the user
	  Use login id and password of the user created 
	  cwd here stands for current working directory
"""

from ftplib import FTP
ftp = FTP('xxx.xxx.x.x')  # Enter the ip address or the domain name here
ftp.login(user='username', passwd='password')
ftp.cwd('/Enter the directory here/')

"""
	The file which will be received via the FTP server
	Enter the location of the file where the file is received
"""

def ReceiveFile():
	FileName = 'example.txt'   """ Enter the location of the file """
	LocalFile = open(FileName, 'wb')
	ftp.retrbinary('RETR ' + FileName, LocalFile.write, 1024)
	ftp.quit()
	LocalFile.close()

"""
	The file which will be sent via the FTP server
	The file send will be send to the current working directory
"""

def SendFile():
	FileName = 'example.txt'   """ Enter the name of the file """
	ftp.storbinary('STOR ' + FileName, open(FileName, 'rb'))
	ftp.quit()
<EOF>
<BOF>
def compare_string(string1, string2):
	l1 = list(string1); l2 = list(string2)
	count = 0
	for i in range(len(l1)):
		if l1[i] != l2[i]:
			count += 1
			l1[i] = '_'
	if count > 1:
		return -1
	else:
		return("".join(l1))

def check(binary):
	pi = []
	while 1:
		check1 = ['$']*len(binary)
		temp = []
		for i in range(len(binary)):
			for j in range(i+1, len(binary)):
				k=compare_string(binary[i], binary[j])
				if k != -1:
					check1[i] = '*'
					check1[j] = '*'
					temp.append(k)
		for  i in range(len(binary)):
			if check1[i] == '$':
				pi.append(binary[i])
		if len(temp) == 0:
			return pi
		binary = list(set(temp))

def decimal_to_binary(no_of_variable, minterms):
	temp = []
	s = ''
	for m in minterms:
		for i in range(no_of_variable):
			s = str(m%2) + s
			m //= 2
		temp.append(s)
		s = ''
	return temp

def is_for_table(string1, string2, count):
	l1 = list(string1);l2=list(string2)
	count_n = 0
	for i in range(len(l1)):
		if l1[i] != l2[i]:
			count_n += 1
	if count_n == count:
		return True
	else:
		return False 

def selection(chart, prime_implicants):
	temp = []
	select = [0]*len(chart)
	for i in range(len(chart[0])):
		count = 0
		rem = -1
		for j in range(len(chart)):
			if chart[j][i] == 1:
				count += 1
				rem = j
		if count == 1:
			select[rem] = 1
	for i in range(len(select)):
		if select[i] == 1:
			for j in range(len(chart[0])):
				if chart[i][j] == 1:
					for k in range(len(chart)):
						chart[k][j] = 0 
			temp.append(prime_implicants[i])
	while 1:
		max_n = 0; rem = -1; count_n = 0
		for i in range(len(chart)):
			count_n = chart[i].count(1)
			if count_n > max_n:
				max_n = count_n
				rem = i
		
		if max_n == 0:
			return temp
		
		temp.append(prime_implicants[rem])
		
		for i in range(len(chart[0])):
			if chart[rem][i] == 1:
				for j in range(len(chart)):
					chart[j][i] = 0
		
def prime_implicant_chart(prime_implicants, binary):
	chart = [[0 for x in range(len(binary))] for x in range(len(prime_implicants))]
	for i in range(len(prime_implicants)):
		count = prime_implicants[i].count('_')
		for j in range(len(binary)):
			if(is_for_table(prime_implicants[i], binary[j], count)):
				chart[i][j] = 1
	
	return chart

def main():
	no_of_variable = int(input("Enter the no. of variables\n"))
	minterms = [int(x) for x in input("Enter the decimal representation of Minterms 'Spaces Seprated'\n").split()]
	binary = decimal_to_binary(no_of_variable, minterms)
	
	prime_implicants = check(binary)
	print("Prime Implicants are:")
	print(prime_implicants)
	chart = prime_implicant_chart(prime_implicants, binary)
	
	essential_prime_implicants = selection(chart,prime_implicants)
	print("Essential Prime Implicants are:")
	print(essential_prime_implicants)

if __name__ == '__main__':
	main()
<EOF>
<BOF>
from __future__ import print_function
import math

def rearrange(bitString32):
	"""[summary]
	Regroups the given binary string.
	
	Arguments:
		bitString32 {[string]} -- [32 bit binary]
	
	Raises:
		ValueError -- [if the given string not are 32 bit binary string]
	
	Returns:
		[string] -- [32 bit binary string]
	"""

	if len(bitString32) != 32:
		raise ValueError("Need length 32")
	newString = ""
	for i in [3,2,1,0]:
		newString += bitString32[8*i:8*i+8]
	return newString

def reformatHex(i):
	"""[summary]
	Converts the given integer into 8-digit hex number.

	Arguments:
		i {[int]} -- [integer]
	"""

	hexrep = format(i,'08x')
	thing = ""
	for i in [3,2,1,0]:
		thing += hexrep[2*i:2*i+2]
	return thing

def pad(bitString):
	"""[summary]
	Fills up the binary string to a 512 bit binary string

	Arguments:
		bitString {[string]} -- [binary string]
	
	Returns:
		[string] -- [binary string]
	"""

	startLength = len(bitString)
	bitString += '1'
	while len(bitString) % 512 != 448:
		bitString += '0'
	lastPart = format(startLength,'064b')
	bitString += rearrange(lastPart[32:]) + rearrange(lastPart[:32]) 
	return bitString

def getBlock(bitString):
	"""[summary]
	Iterator:
		Returns by each call a list of length 16 with the 32 bit
		integer blocks. 

	Arguments:
		bitString {[string]} -- [binary string >= 512]
	"""

	currPos = 0
	while currPos < len(bitString):
		currPart = bitString[currPos:currPos+512]
		mySplits = []
		for i in range(16):
			mySplits.append(int(rearrange(currPart[32*i:32*i+32]),2))
		yield mySplits
		currPos += 512

def not32(i):
	i_str = format(i,'032b')
	new_str = ''
	for c in i_str:
		new_str += '1' if c=='0' else '0'
	return int(new_str,2)

def sum32(a,b):
	return (a + b) % 2**32

def leftrot32(i,s):
	return (i << s) ^ (i >> (32-s))

def md5me(testString):
	"""[summary]
	Returns a 32-bit hash code of the string 'testString'

	Arguments:
		testString {[string]} -- [message]
	"""

	bs =''
	for i in testString:
		bs += format(ord(i),'08b')
	bs = pad(bs)

	tvals = [int(2**32 * abs(math.sin(i+1))) for i in range(64)]

	a0 = 0x67452301
	b0 = 0xefcdab89
	c0 = 0x98badcfe
	d0 = 0x10325476

	s = [7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22, \
		5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20, \
		4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23, \
		6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21 ]

	for m in getBlock(bs):
		A = a0 
		B = b0
		C = c0
		D = d0
		for i in range(64):
			if i <= 15:
				#f = (B & C) | (not32(B) & D)
				f = D ^ (B & (C ^ D))
				g = i
			elif i<= 31:
				#f = (D & B) | (not32(D) & C)
				f = C ^ (D & (B ^ C))
				g = (5*i+1) % 16
			elif i <= 47:
				f = B ^ C ^ D
				g = (3*i+5) % 16
			else:
				f = C ^ (B | not32(D))
				g = (7*i) % 16
			dtemp = D
			D = C
			C = B
			B = sum32(B,leftrot32((A + f + tvals[i] + m[g]) % 2**32, s[i]))
			A = dtemp
		a0 = sum32(a0, A)
		b0 = sum32(b0, B)
		c0 = sum32(c0, C)
		d0 = sum32(d0, D)

	digest = reformatHex(a0) + reformatHex(b0) + reformatHex(c0) + reformatHex(d0)
	return digest

def test():
	assert md5me("") == "d41d8cd98f00b204e9800998ecf8427e"	
	assert md5me("The quick brown fox jumps over the lazy dog") == "9e107d9d372bb6826bd81d3542a419d6"
	print("Success.")


if __name__ == "__main__":
	test()
<EOF>
<BOF>
"""example of simple chaos machine"""
from __future__ import print_function

try:
  input = raw_input  # Python 2
except NameError:
  pass               # Python 3

# Chaos Machine (K, t, m)
K = [0.33, 0.44, 0.55, 0.44, 0.33]; t = 3; m = 5

# Buffer Space (with Parameters Space)
buffer_space, params_space = [], []

# Machine Time
machine_time = 0

def push(seed):
  global buffer_space, params_space, machine_time, \
    K, m, t

  # Choosing Dynamical Systems (All)
  for key, value in enumerate(buffer_space):
    # Evolution Parameter
    e = float(seed / value)

    # Control Theory: Orbit Change
    value = (buffer_space[(key + 1) % m] + e) % 1

    # Control Theory: Trajectory Change
    r = (params_space[key] + e) % 1 + 3

    # Modification (Transition Function) - Jumps
    buffer_space[key] = \
      round(float(r * value * (1 - value)), 10)
    params_space[key] = \
      r # Saving to Parameters Space

  # Logistic Map
  assert max(buffer_space) < 1
  assert max(params_space) < 4

  # Machine Time
  machine_time += 1

def pull():
  global buffer_space, params_space, machine_time, \
    K, m, t

  # PRNG (Xorshift by George Marsaglia)
  def xorshift(X, Y):
    X ^= Y >> 13
    Y ^= X << 17
    X ^= Y >> 5
    return X

  # Choosing Dynamical Systems (Increment)
  key = machine_time % m

  # Evolution (Time Length)
  for i in range(0, t):
    # Variables (Position + Parameters)
    r     = params_space[key]
    value = buffer_space[key]

    # Modification (Transition Function) - Flow
    buffer_space[key] = \
      round(float(r * value * (1 - value)), 10)
    params_space[key] = \
      (machine_time * 0.01 + r * 1.01) % 1 + 3

  # Choosing Chaotic Data
  X = int(buffer_space[(key + 2) % m] * (10 ** 10))
  Y = int(buffer_space[(key - 2) % m] * (10 ** 10))

  # Machine Time
  machine_time += 1

  return xorshift(X, Y) % 0xFFFFFFFF

def reset():
  global buffer_space, params_space, machine_time, \
    K, m, t

  buffer_space = K; params_space = [0] * m
  machine_time = 0

#######################################

# Initialization
reset()

# Pushing Data (Input)
import random
message = random.sample(range(0xFFFFFFFF), 100)
for chunk in message:
  push(chunk)

# for controlling 
inp = ""

# Pulling Data (Output)
while inp in ("e", "E"):
  print("%s" % format(pull(), '#04x'))
  print(buffer_space); print(params_space)
  inp = input("(e)exit? ").strip()
<EOF>
<BOF>
"""
Demonstrates implementation of SHA1 Hash function in a Python class and gives utilities
to find hash of string or hash of text from a file.
Usage: python sha1.py --string "Hello World!!"
       pyhton sha1.py --file "hello_world.txt"
       When run without any arguments, it prints the hash of the string "Hello World!! Welcome to Cryptography"
Also contains a Test class to verify that the generated Hash is same as that
returned by the hashlib library

SHA1 hash or SHA1 sum of a string is a crytpographic function which means it is easy
to calculate forwards but extemely difficult to calculate backwards. What this means
is, you can easily calculate the hash of  a string, but it is extremely difficult to
know the original string if you have its hash. This property is useful to communicate
securely, send encrypted messages and is very useful in payment systems, blockchain
and cryptocurrency etc.
The Algorithm as described in the reference:
First we start with a message. The message is padded and the length of the message
is added to the end. It is then split into blocks of 512 bits or 64 bytes. The blocks
are then processed one at a time. Each block must be expanded and compressed.
The value after each compression is added to a 160bit buffer called the current hash
state. After the last block is processed the current hash state is returned as
the final hash.
Reference: https://deadhacker.com/2006/02/21/sha-1-illustrated/
"""

import argparse
import struct
import hashlib #hashlib is only used inside the Test class
import unittest


class SHA1Hash:
    """
    Class to contain the entire pipeline for SHA1 Hashing Algorithm
    """
    def __init__(self, data):
        """
        Inititates the variables data and h. h is a list of 5 8-digit Hexadecimal
        numbers corresponding to (1732584193, 4023233417, 2562383102, 271733878, 3285377520)
        respectively. We will start with this as a message digest. 0x is how you write
        Hexadecimal numbers in Python
        """
        self.data = data
        self.h = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

    @staticmethod
    def rotate(n, b):
        """
        Static method to be used inside other methods. Left rotates n by b.
        """
        return ((n << b) | (n >> (32 - b))) & 0xffffffff

    def padding(self):
        """
        Pads the input message with zeros so that padded_data has 64 bytes or 512 bits
        """
        padding = b'\x80' + b'\x00'*(63 - (len(self.data) + 8) % 64)
        padded_data = self.data + padding + struct.pack('>Q', 8 * len(self.data))
        return padded_data

    def split_blocks(self):
        """
        Returns a list of bytestrings each of length 64
        """
        return [self.padded_data[i:i+64] for i in range(0, len(self.padded_data), 64)]

    # @staticmethod
    def expand_block(self, block):
        """
        Takes a bytestring-block of length 64, unpacks it to a list of integers and returns a
        list of 80 integers pafter some bit operations
        """
        w = list(struct.unpack('>16L', block)) + [0] * 64
        for i in range(16, 80):
            w[i] = self.rotate((w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16]), 1)
        return w

    def final_hash(self):
        """
        Calls all the other methods to process the input. Pads the data, then splits into
        blocks and then does a series of operations for each block (including expansion).
        For each block, the variable h that was initialized is copied to a,b,c,d,e
        and these 5 variables a,b,c,d,e undergo several changes. After all the blocks are
        processed, these 5 variables are pairwise added to h ie a to h[0], b to h[1] and so on.
        This h becomes our final hash which is returned.
        """
        self.padded_data = self.padding()
        self.blocks = self.split_blocks()
        for block in self.blocks:
            expanded_block = self.expand_block(block)
            a, b, c, d, e = self.h
            for i in range(0, 80):
                if 0 <= i < 20:
                    f = (b & c) | ((~b) & d)
                    k = 0x5A827999
                elif 20 <= i < 40:
                    f = b ^ c ^ d
                    k = 0x6ED9EBA1
                elif 40 <= i < 60:
                    f = (b & c) | (b & d) | (c & d)
                    k = 0x8F1BBCDC
                elif 60 <= i < 80:
                    f = b ^ c ^ d
                    k = 0xCA62C1D6
                a, b, c, d, e = self.rotate(a, 5) + f + e + k + expanded_block[i] & 0xffffffff,\
                                a, self.rotate(b, 30), c, d
        self.h = self.h[0] + a & 0xffffffff,\
                 self.h[1] + b & 0xffffffff,\
                 self.h[2] + c & 0xffffffff,\
                 self.h[3] + d & 0xffffffff,\
                 self.h[4] + e & 0xffffffff
        return '%08x%08x%08x%08x%08x' %tuple(self.h)


class SHA1HashTest(unittest.TestCase):
    """
    Test class for the SHA1Hash class. Inherits the TestCase class from unittest
    """
    def testMatchHashes(self):
        msg = bytes('Test String', 'utf-8')
        self.assertEqual(SHA1Hash(msg).final_hash(), hashlib.sha1(msg).hexdigest())


def main():
    """
    Provides option 'string' or 'file' to take input and prints the calculated SHA1 hash.
    unittest.main() has been commented because we probably dont want to run
    the test each time.
    """
    # unittest.main()
    parser = argparse.ArgumentParser(description='Process some strings or files')
    parser.add_argument('--string', dest='input_string',
                        default='Hello World!! Welcome to Cryptography',
                        help='Hash the string')
    parser.add_argument('--file', dest='input_file', help='Hash contents of a file')
    args = parser.parse_args()
    input_string = args.input_string
    #In any case hash input should be a bytestring
    if args.input_file:
        hash_input = open(args.input_file, 'rb').read()
    else:
        hash_input = bytes(input_string, 'utf-8')
    print(SHA1Hash(hash_input).final_hash())


if __name__ == '__main__':
    main()
<EOF>
<BOF>
'''

	Perceptron
	w = w + N * (d(k) - y) * x(k)

	Using perceptron network for oil analysis,
	with Measuring of 3 parameters that represent chemical characteristics we can classify the oil, in p1 or p2
	p1 = -1
	p2 = 1

'''
from __future__ import print_function

import random


class Perceptron:
    def __init__(self, sample, exit, learn_rate=0.01, epoch_number=1000, bias=-1):
        self.sample = sample
        self.exit = exit
        self.learn_rate = learn_rate
        self.epoch_number = epoch_number
        self.bias = bias
        self.number_sample = len(sample)
        self.col_sample = len(sample[0])
        self.weight = []

    def trannig(self):
        for sample in self.sample:
            sample.insert(0, self.bias)

        for i in range(self.col_sample):
           self.weight.append(random.random())

        self.weight.insert(0, self.bias)

        epoch_count = 0

        while True:
            erro = False
            for i in range(self.number_sample):
                u = 0
                for j in range(self.col_sample + 1):
                    u = u + self.weight[j] * self.sample[i][j]
                y = self.sign(u)
                if y != self.exit[i]:

                    for j in range(self.col_sample + 1):

                        self.weight[j] = self.weight[j] + self.learn_rate * (self.exit[i] - y) * self.sample[i][j]
                    erro = True
            #print('Epoch: \n',epoch_count)
            epoch_count = epoch_count + 1
            # if you want controle the epoch or just by erro
            if erro == False:
                print(('\nEpoch:\n',epoch_count))
                print('------------------------\n')
            #if epoch_count > self.epoch_number or not erro:
                break

    def sort(self, sample):
        sample.insert(0, self.bias)
        u = 0
        for i in range(self.col_sample + 1):
            u = u + self.weight[i] * sample[i]

        y = self.sign(u)

        if  y == -1:
            print(('Sample: ', sample))
            print('classification: P1')
        else:
            print(('Sample: ', sample))
            print('classification: P2')

    def sign(self, u):
        return 1 if u >= 0 else -1


samples = [
    [-0.6508, 0.1097, 4.0009],
    [-1.4492, 0.8896, 4.4005],
    [2.0850, 0.6876, 12.0710],
    [0.2626, 1.1476, 7.7985],
    [0.6418, 1.0234, 7.0427],
    [0.2569, 0.6730, 8.3265],
    [1.1155, 0.6043, 7.4446],
    [0.0914, 0.3399, 7.0677],
    [0.0121, 0.5256, 4.6316],
    [-0.0429, 0.4660, 5.4323],
    [0.4340, 0.6870, 8.2287],
    [0.2735, 1.0287, 7.1934],
    [0.4839, 0.4851, 7.4850],
    [0.4089, -0.1267, 5.5019],
    [1.4391, 0.1614, 8.5843],
    [-0.9115, -0.1973, 2.1962],
    [0.3654, 1.0475, 7.4858],
    [0.2144, 0.7515, 7.1699],
    [0.2013, 1.0014, 6.5489],
    [0.6483, 0.2183, 5.8991],
    [-0.1147, 0.2242, 7.2435],
    [-0.7970, 0.8795, 3.8762],
    [-1.0625, 0.6366, 2.4707],
    [0.5307, 0.1285, 5.6883],
    [-1.2200, 0.7777, 1.7252],
    [0.3957, 0.1076, 5.6623],
    [-0.1013, 0.5989, 7.1812],
    [2.4482, 0.9455, 11.2095],
    [2.0149, 0.6192, 10.9263],
    [0.2012, 0.2611, 5.4631]

]

exit = [-1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, -1, 1]

network = Perceptron(sample=samples, exit = exit, learn_rate=0.01, epoch_number=1000, bias=-1)

network.trannig()

while True:
    sample = []
    for i in range(3):
        sample.insert(i, float(input('value: ')))
    network.sort(sample)
<EOF>
<BOF>
"""
Implementation of gradient descent algorithm for minimizing cost of a linear hypothesis function.
"""
from __future__ import print_function, division
import numpy

# List of input, output pairs
train_data = (((5, 2, 3), 15), ((6, 5, 9), 25),
              ((11, 12, 13), 41), ((1, 1, 1), 8), ((11, 12, 13), 41))
test_data = (((515, 22, 13), 555), ((61, 35, 49), 150))
parameter_vector = [2, 4, 1, 5]
m = len(train_data)
LEARNING_RATE = 0.009


def _error(example_no, data_set='train'):
    """
    :param data_set: train data or test data
    :param example_no: example number whose error has to be checked
    :return: error in example pointed by example number.
    """
    return calculate_hypothesis_value(example_no, data_set) - output(example_no, data_set)


def _hypothesis_value(data_input_tuple):
    """
    Calculates hypothesis function value for a given input
    :param data_input_tuple: Input tuple of a particular example
    :return: Value of hypothesis function at that point.
    Note that there is an 'biased input' whose value is fixed as 1.
    It is not explicitly mentioned in input data.. But, ML hypothesis functions use it.
    So, we have to take care of it separately. Line 36 takes care of it.
    """
    hyp_val = 0
    for i in range(len(parameter_vector) - 1):
        hyp_val += data_input_tuple[i]*parameter_vector[i+1]
    hyp_val += parameter_vector[0]
    return hyp_val


def output(example_no, data_set):
    """
    :param data_set: test data or train data
    :param example_no: example whose output is to be fetched
    :return: output for that example
    """
    if data_set == 'train':
        return train_data[example_no][1]
    elif data_set == 'test':
        return test_data[example_no][1]


def calculate_hypothesis_value(example_no, data_set):
    """
    Calculates hypothesis value for a given example
    :param data_set: test data or train_data
    :param example_no: example whose hypothesis value is to be calculated
    :return: hypothesis value for that example
    """
    if data_set == "train":
        return _hypothesis_value(train_data[example_no][0])
    elif data_set == "test":
        return _hypothesis_value(test_data[example_no][0])


def summation_of_cost_derivative(index, end=m):
    """
    Calculates the sum of cost function derivative
    :param index: index wrt derivative is being calculated
    :param end: value where summation ends, default is m, number of examples
    :return: Returns the summation of cost derivative
    Note: If index is -1, this means we are calculating summation wrt to biased parameter.
    """
    summation_value = 0
    for i in range(end):
        if index == -1:
            summation_value += _error(i)
        else:
            summation_value += _error(i)*train_data[i][0][index]
    return summation_value


def get_cost_derivative(index):
    """
    :param index: index of the parameter vector wrt to derivative is to be calculated
    :return: derivative wrt to that index
    Note: If index is -1, this means we are calculating summation wrt to biased parameter.
    """
    cost_derivative_value = summation_of_cost_derivative(index, m)/m
    return cost_derivative_value


def run_gradient_descent():
    global parameter_vector
    # Tune these values to set a tolerance value for predicted output
    absolute_error_limit = 0.000002
    relative_error_limit = 0
    j = 0
    while True:
        j += 1
        temp_parameter_vector = [0, 0, 0, 0]
        for i in range(0, len(parameter_vector)):
            cost_derivative = get_cost_derivative(i-1)
            temp_parameter_vector[i] = parameter_vector[i] - \
                LEARNING_RATE*cost_derivative
        if numpy.allclose(parameter_vector, temp_parameter_vector,
                          atol=absolute_error_limit, rtol=relative_error_limit):
            break
        parameter_vector = temp_parameter_vector
    print(("Number of iterations:", j))


def test_gradient_descent():
    for i in range(len(test_data)):
        print(("Actual output value:", output(i, 'test')))
        print(("Hypothesis output:", calculate_hypothesis_value(i, 'test')))


if __name__ == '__main__':
    run_gradient_descent()
    print("\nTesting gradient descent for a linear hypothesis function.\n")
    test_gradient_descent()
<EOF>
<BOF>
"""
Linear regression is the most basic type of regression commonly used for
predictive analysis. The idea is preety simple, we have a dataset and we have
a feature's associated with it. The Features should be choose very cautiously
as they determine, how much our model will be able to make future predictions.
We try to set these Feature weights, over many iterations, so that they best
fits our dataset. In this particular code, i had used a CSGO dataset (ADR vs
Rating). We try to best fit a line through dataset and estimate the parameters.
"""
from __future__ import print_function

import requests
import numpy as np


def collect_dataset():
    """ Collect dataset of CSGO
    The dataset contains ADR vs Rating of a Player
    :return : dataset obtained from the link, as matrix
    """
    response = requests.get('https://raw.githubusercontent.com/yashLadha/' +
                            'The_Math_of_Intelligence/master/Week1/ADRvs' +
                            'Rating.csv')
    lines = response.text.splitlines()
    data = []
    for item in lines:
        item = item.split(',')
        data.append(item)
    data.pop(0)  # This is for removing the labels from the list
    dataset = np.matrix(data)
    return dataset


def run_steep_gradient_descent(data_x, data_y,
                               len_data, alpha, theta):
    """ Run steep gradient descent and updates the Feature vector accordingly_
    :param data_x   : contains the dataset
    :param data_y   : contains the output associated with each data-entry
    :param len_data : length of the data_
    :param alpha    : Learning rate of the model
    :param theta    : Feature vector (weight's for our model)
    ;param return    : Updated Feature's, using
                       curr_features - alpha_ * gradient(w.r.t. feature)
    """
    n = len_data

    prod = np.dot(theta, data_x.transpose())
    prod -= data_y.transpose()
    sum_grad = np.dot(prod, data_x)
    theta = theta - (alpha / n) * sum_grad
    return theta


def sum_of_square_error(data_x, data_y, len_data, theta):
    """ Return sum of square error for error calculation
    :param data_x    : contains our dataset
    :param data_y    : contains the output (result vector)
    :param len_data  : len of the dataset
    :param theta     : contains the feature vector
    :return          : sum of square error computed from given feature's
    """
    prod = np.dot(theta, data_x.transpose())
    prod -= data_y.transpose()
    sum_elem = np.sum(np.square(prod))
    error = sum_elem / (2 * len_data)
    return error


def run_linear_regression(data_x, data_y):
    """ Implement Linear regression over the dataset
    :param data_x  : contains our dataset
    :param data_y  : contains the output (result vector)
    :return        : feature for line of best fit (Feature vector)
    """
    iterations = 100000
    alpha = 0.0001550

    no_features = data_x.shape[1]
    len_data = data_x.shape[0] - 1

    theta = np.zeros((1, no_features))

    for i in range(0, iterations):
        theta = run_steep_gradient_descent(data_x, data_y,
                                           len_data, alpha, theta)
        error = sum_of_square_error(data_x, data_y, len_data, theta)
        print('At Iteration %d - Error is %.5f ' % (i + 1, error))

    return theta


def main():
    """ Driver function """
    data = collect_dataset()

    len_data = data.shape[0]
    data_x = np.c_[np.ones(len_data), data[:, :-1]].astype(float)
    data_y = data[:, -1].astype(float)

    theta = run_linear_regression(data_x, data_y)
    len_result = theta.shape[1]
    print('Resultant Feature vector : ')
    for i in range(0, len_result):
        print('%.5f' % (theta[0, i]))


if __name__ == '__main__':
    main()
<EOF>
<BOF>
'''README, Author - Anurag Kumar(mailto:anuragkumarak95@gmail.com)

Requirements:
  - sklearn
  - numpy
  - matplotlib

Python:
  - 3.5

Inputs:
  - X , a 2D numpy array of features.
  - k , number of clusters to create.
  - initial_centroids , initial centroid values generated by utility function(mentioned in usage).
  - maxiter , maximum number of iterations to process.
  - heterogeneity , empty list that will be filled with hetrogeneity values if passed to kmeans func.

Usage:
  1. define 'k' value, 'X' features array and 'hetrogeneity' empty list
  
  2. create initial_centroids,
        initial_centroids = get_initial_centroids(
            X, 
            k, 
            seed=0 # seed value for initial centroid generation, None for randomness(default=None)
            )

  3. find centroids and clusters using kmeans function.
  
        centroids, cluster_assignment = kmeans(
            X, 
            k, 
            initial_centroids, 
            maxiter=400,
            record_heterogeneity=heterogeneity, 
            verbose=True # whether to print logs in console or not.(default=False)
            )
  
  
  4. Plot the loss function, hetrogeneity values for every iteration saved in hetrogeneity list.
        plot_heterogeneity(
            heterogeneity, 
            k
        )
  
  5. Have fun..
  
'''
from __future__ import print_function
from sklearn.metrics import pairwise_distances
import numpy as np

TAG = 'K-MEANS-CLUST/ '

def get_initial_centroids(data, k, seed=None):
    '''Randomly choose k data points as initial centroids'''
    if seed is not None: # useful for obtaining consistent results
        np.random.seed(seed)
    n = data.shape[0] # number of data points
        
    # Pick K indices from range [0, N).
    rand_indices = np.random.randint(0, n, k)
    
    # Keep centroids as dense format, as many entries will be nonzero due to averaging.
    # As long as at least one document in a cluster contains a word,
    # it will carry a nonzero weight in the TF-IDF vector of the centroid.
    centroids = data[rand_indices,:]
    
    return centroids

def centroid_pairwise_dist(X,centroids):
    return pairwise_distances(X,centroids,metric='euclidean')

def assign_clusters(data, centroids):
    
    # Compute distances between each data point and the set of centroids:
    # Fill in the blank (RHS only)
    distances_from_centroids = centroid_pairwise_dist(data,centroids)
    
    # Compute cluster assignments for each data point:
    # Fill in the blank (RHS only)
    cluster_assignment = np.argmin(distances_from_centroids,axis=1)
    
    return cluster_assignment

def revise_centroids(data, k, cluster_assignment):
    new_centroids = []
    for i in range(k):
        # Select all data points that belong to cluster i. Fill in the blank (RHS only)
        member_data_points = data[cluster_assignment==i]
        # Compute the mean of the data points. Fill in the blank (RHS only)
        centroid = member_data_points.mean(axis=0)
        new_centroids.append(centroid)
    new_centroids = np.array(new_centroids)
    
    return new_centroids

def compute_heterogeneity(data, k, centroids, cluster_assignment):
    
    heterogeneity = 0.0
    for i in range(k):
        
        # Select all data points that belong to cluster i. Fill in the blank (RHS only)
        member_data_points = data[cluster_assignment==i, :]
        
        if member_data_points.shape[0] > 0: # check if i-th cluster is non-empty
            # Compute distances from centroid to data points (RHS only)
            distances = pairwise_distances(member_data_points, [centroids[i]], metric='euclidean')
            squared_distances = distances**2
            heterogeneity += np.sum(squared_distances)
        
    return heterogeneity

from matplotlib import pyplot as plt
def plot_heterogeneity(heterogeneity, k):
    plt.figure(figsize=(7,4))
    plt.plot(heterogeneity, linewidth=4)
    plt.xlabel('# Iterations')
    plt.ylabel('Heterogeneity')
    plt.title('Heterogeneity of clustering over time, K={0:d}'.format(k))
    plt.rcParams.update({'font.size': 16})
    plt.show()

def kmeans(data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False):
    '''This function runs k-means on given data and initial set of centroids.
       maxiter: maximum number of iterations to run.(default=500)
       record_heterogeneity: (optional) a list, to store the history of heterogeneity as function of iterations
                             if None, do not store the history.
       verbose: if True, print how many data points changed their cluster labels in each iteration'''
    centroids = initial_centroids[:]
    prev_cluster_assignment = None
    
    for itr in range(maxiter):        
        if verbose:
            print(itr, end='')
        
        # 1. Make cluster assignments using nearest centroids
        cluster_assignment = assign_clusters(data,centroids)
            
        # 2. Compute a new centroid for each of the k clusters, averaging all data points assigned to that cluster.
        centroids = revise_centroids(data,k, cluster_assignment)
            
        # Check for convergence: if none of the assignments changed, stop
        if prev_cluster_assignment is not None and \
          (prev_cluster_assignment==cluster_assignment).all():
            break
        
        # Print number of new assignments 
        if prev_cluster_assignment is not None:
            num_changed = np.sum(prev_cluster_assignment!=cluster_assignment)
            if verbose:
                print('    {0:5d} elements changed their cluster assignment.'.format(num_changed))   
        
        # Record heterogeneity convergence metric
        if record_heterogeneity is not None:
            # YOUR CODE HERE
            score = compute_heterogeneity(data,k,centroids,cluster_assignment)
            record_heterogeneity.append(score)
        
        prev_cluster_assignment = cluster_assignment[:]
        
    return centroids, cluster_assignment

# Mock test below
if False: # change to true to run this test case.
    import sklearn.datasets as ds
    dataset = ds.load_iris()
    k = 3
    heterogeneity = []
    initial_centroids = get_initial_centroids(dataset['data'], k, seed=0)
    centroids, cluster_assignment = kmeans(dataset['data'], k, initial_centroids, maxiter=400,
                                        record_heterogeneity=heterogeneity, verbose=True)
    plot_heterogeneity(heterogeneity, k)
<EOF>
<BOF>
#!/usr/bin/python
# -*- coding: utf-8 -*-

## Logistic Regression from scratch

# In[62]:

# In[63]:

# importing all the required libraries

''' Implementing logistic regression for classification problem 
     Helpful resources : 1.Coursera ML course    2.https://medium.com/@martinpella/logistic-regression-from-scratch-in-python-124c5636b8ac'''

import numpy as np
import matplotlib.pyplot as plt

# get_ipython().run_line_magic('matplotlib', 'inline')

from sklearn import datasets


# In[67]:

# sigmoid function or logistic function is used as a hypothesis function in classification problems

def sigmoid_function(z):
    return 1 / (1 + np.exp(-z))


def cost_function(h, y):
    return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()


# here alpha is the learning rate, X is the feature matrix,y is the target matrix

def logistic_reg(
    alpha,
    X,
    y,
    max_iterations=70000,
    ):
    converged = False
    iterations = 0
    theta = np.zeros(X.shape[1])

    while not converged:
        z = np.dot(X, theta)
        h = sigmoid_function(z)
        gradient = np.dot(X.T, h - y) / y.size
        theta = theta - alpha * gradient

        z = np.dot(X, theta)
        h = sigmoid_function(z)
        J = cost_function(h, y)

        iterations += 1  # update iterations

        if iterations == max_iterations:
            print ('Maximum iterations exceeded!')
            print ('Minimal cost function J=', J)
            converged = True

    return theta


# In[68]:

if __name__ == '__main__':
    iris = datasets.load_iris()
    X = iris.data[:, :2]
    y = (iris.target != 0) * 1

    alpha = 0.1
    theta = logistic_reg(alpha, X, y, max_iterations=70000)
    print (theta)


    def predict_prob(X):
        return sigmoid_function(np.dot(X, theta))  # predicting the value of probability from the logistic regression algorithm


    plt.figure(figsize=(10, 6))
    plt.scatter(X[y == 0][:, 0], X[y == 0][:, 1], color='b', label='0')
    plt.scatter(X[y == 1][:, 0], X[y == 1][:, 1], color='r', label='1')
    (x1_min, x1_max) = (X[:, 0].min(), X[:, 0].max())
    (x2_min, x2_max) = (X[:, 1].min(), X[:, 1].max())
    (xx1, xx2) = np.meshgrid(np.linspace(x1_min, x1_max),
                             np.linspace(x2_min, x2_max))
    grid = np.c_[xx1.ravel(), xx2.ravel()]
    probs = predict_prob(grid).reshape(xx1.shape)
    plt.contour(
        xx1,
        xx2,
        probs,
        [0.5],
        linewidths=1,
        colors='black',
        )

    plt.legend()
<EOF>
<BOF>
import numpy as np

""" Here I implemented the scoring functions.
    MAE, MSE, RMSE, RMSLE are included.

    Those are used for calculating differences between
    predicted values and actual values.

    Metrics are slightly differentiated. Sometimes squared, rooted,
    even log is used.

    Using log and roots can be perceived as tools for penalizing big
    erors. However, using appropriate metrics depends on the situations,
    and types of data
"""

#Mean Absolute Error
def mae(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    difference = abs(predict - actual)
    score = difference.mean()

    return score

#Mean Squared Error
def mse(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    difference = predict - actual
    square_diff = np.square(difference)

    score = square_diff.mean()
    return score

#Root Mean Squared Error
def rmse(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    difference = predict - actual
    square_diff = np.square(difference)
    mean_square_diff = square_diff.mean()
    score = np.sqrt(mean_square_diff)
    return score

#Root Mean Square Logarithmic Error
def rmsle(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    log_predict = np.log(predict+1)
    log_actual = np.log(actual+1)

    difference = log_predict - log_actual
    square_diff = np.square(difference)
    mean_square_diff = square_diff.mean()

    score = np.sqrt(mean_square_diff)

    return score

#Mean Bias Deviation
def mbd(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    difference = predict - actual
    numerator = np.sum(difference) / len(predict) 
    denumerator =  np.sum(actual) / len(predict)
    print(numerator)
    print(denumerator)

    score = float(numerator) / denumerator * 100

    return score
<EOF>
<BOF>
"""
Implementation of a basic regression decision tree.
Input data set: The input data set must be 1-dimensional with continuous labels.
Output: The decision tree maps a real number input to a real number output. 
"""
from __future__ import print_function

import numpy as np

class Decision_Tree:
    def __init__(self, depth = 5, min_leaf_size = 5):
        self.depth = depth
        self.decision_boundary = 0
        self.left = None
        self.right = None
        self.min_leaf_size = min_leaf_size
        self.prediction = None

    def mean_squared_error(self, labels, prediction):
        """
        mean_squared_error:
        @param labels: a one dimensional numpy array 
        @param prediction: a floating point value
        return value: mean_squared_error calculates the error if prediction is used to estimate the labels
        """
        if labels.ndim != 1:
            print("Error: Input labels must be one dimensional")

        return np.mean((labels - prediction) ** 2)

    def train(self, X, y):
        """
        train:
        @param X: a one dimensional numpy array
        @param y: a one dimensional numpy array. 
        The contents of y are the labels for the corresponding X values

        train does not have a return value
        """

        """
        this section is to check that the inputs conform to our dimensionality constraints
        """
        if X.ndim != 1:
            print("Error: Input data set must be one dimensional")
            return
        if len(X) != len(y):
            print("Error: X and y have different lengths")
            return
        if y.ndim != 1:
            print("Error: Data set labels must be one dimensional")
            return

        if len(X) < 2 * self.min_leaf_size:
            self.prediction = np.mean(y)
            return

        if self.depth == 1:
            self.prediction = np.mean(y)
            return

        best_split = 0
        min_error = self.mean_squared_error(X,np.mean(y)) * 2


        """
        loop over all possible splits for the decision tree. find the best split.
        if no split exists that is less than 2 * error for the entire array
        then the data set is not split and the average for the entire array is used as the predictor
        """
        for i in range(len(X)):
            if len(X[:i]) < self.min_leaf_size:
                continue
            elif len(X[i:]) < self.min_leaf_size:
                continue
            else:
                error_left = self.mean_squared_error(X[:i], np.mean(y[:i]))
                error_right = self.mean_squared_error(X[i:], np.mean(y[i:]))
                error = error_left + error_right
                if error < min_error:
                    best_split = i
                    min_error = error

        if best_split != 0:
            left_X = X[:best_split]
            left_y = y[:best_split]
            right_X = X[best_split:]
            right_y = y[best_split:]

            self.decision_boundary = X[best_split]
            self.left = Decision_Tree(depth = self.depth - 1, min_leaf_size = self.min_leaf_size)
            self.right = Decision_Tree(depth = self.depth - 1, min_leaf_size = self.min_leaf_size)
            self.left.train(left_X, left_y)
            self.right.train(right_X, right_y)
        else:
            self.prediction = np.mean(y)

        return

    def predict(self, x):
        """
        predict:
        @param x: a floating point value to predict the label of
        the prediction function works by recursively calling the predict function
        of the appropriate subtrees based on the tree's decision boundary
        """
        if self.prediction is not None:
            return self.prediction
        elif self.left or self.right is not None:
            if x >= self.decision_boundary:
                return self.right.predict(x)
            else:
                return self.left.predict(x)
        else:
            print("Error: Decision tree not yet trained")
            return None

def main():
    """
    In this demonstration we're generating a sample data set from the sin function in numpy.
    We then train a decision tree on the data set and use the decision tree to predict the
    label of 10 different test values. Then the mean squared error over this test is displayed.
    """
    X = np.arange(-1., 1., 0.005)
    y = np.sin(X)

    tree = Decision_Tree(depth = 10, min_leaf_size = 10)
    tree.train(X,y)

    test_cases = (np.random.rand(10) * 2) - 1
    predictions = np.array([tree.predict(x) for x in test_cases])
    avg_error = np.mean((predictions - test_cases) ** 2)

    print("Test values: " + str(test_cases))
    print("Predictions: " + str(predictions))
    print("Average error: " + str(avg_error))

            
if __name__ == '__main__':
    main()
<EOF>
<BOF>
# Random Forest Classification

# Importing the libraries
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv('Social_Network_Ads.csv')
X = dataset.iloc[:, [2, 3]].values
y = dataset.iloc[:, 4].values

# Splitting the dataset into the Training set and Test set
from sklearn.cross_validation import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

# Fitting Random Forest Classification to the Training set
from sklearn.ensemble import RandomForestClassifier
classifier = RandomForestClassifier(n_estimators = 10, criterion = 'entropy', random_state = 0)
classifier.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)

# Visualising the Training set results
from matplotlib.colors import ListedColormap
X_set, y_set = X_train, y_train
X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),
                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))
plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),
             alpha = 0.75, cmap = ListedColormap(('red', 'green')))
plt.xlim(X1.min(), X1.max())
plt.ylim(X2.min(), X2.max())
for i, j in enumerate(np.unique(y_set)):
    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],
                c = ListedColormap(('red', 'green'))(i), label = j)
plt.title('Random Forest Classification (Training set)')
plt.xlabel('Age')
plt.ylabel('Estimated Salary')
plt.legend()
plt.show()

# Visualising the Test set results
from matplotlib.colors import ListedColormap
X_set, y_set = X_test, y_test
X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),
                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))
plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),
             alpha = 0.75, cmap = ListedColormap(('red', 'green')))
plt.xlim(X1.min(), X1.max())
plt.ylim(X2.min(), X2.max())
for i, j in enumerate(np.unique(y_set)):
    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],
                c = ListedColormap(('red', 'green'))(i), label = j)
plt.title('Random Forest Classification (Test set)')
plt.xlabel('Age')
plt.ylabel('Estimated Salary')
plt.legend()
plt.show()
<EOF>
<BOF>
# Random Forest Regression

# Importing the libraries
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv('Position_Salaries.csv')
X = dataset.iloc[:, 1:2].values
y = dataset.iloc[:, 2].values

# Splitting the dataset into the Training set and Test set
"""from sklearn.cross_validation import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)"""

# Feature Scaling
"""from sklearn.preprocessing import StandardScaler
sc_X = StandardScaler()
X_train = sc_X.fit_transform(X_train)
X_test = sc_X.transform(X_test)
sc_y = StandardScaler()
y_train = sc_y.fit_transform(y_train)"""

# Fitting Random Forest Regression to the dataset
from sklearn.ensemble import RandomForestRegressor
regressor = RandomForestRegressor(n_estimators = 10, random_state = 0)
regressor.fit(X, y)

# Predicting a new result
y_pred = regressor.predict(6.5)

# Visualising the Random Forest Regression results (higher resolution)
X_grid = np.arange(min(X), max(X), 0.01)
X_grid = X_grid.reshape((len(X_grid), 1))
plt.scatter(X, y, color = 'red')
plt.plot(X_grid, regressor.predict(X_grid), color = 'blue')
plt.title('Truth or Bluff (Random Forest Regression)')
plt.xlabel('Position level')
plt.ylabel('Salary')
plt.show()
<EOF>
<BOF>
'''

	Perceptron
	w = w + N * (d(k) - y) * x(k)

	Using perceptron network for oil analysis,
	with Measuring of 3 parameters that represent chemical characteristics we can classify the oil, in p1 or p2
	p1 = -1
	p2 = 1

'''
from __future__ import print_function

import random


class Perceptron:
    def __init__(self, sample, exit, learn_rate=0.01, epoch_number=1000, bias=-1):
        self.sample = sample
        self.exit = exit
        self.learn_rate = learn_rate
        self.epoch_number = epoch_number
        self.bias = bias
        self.number_sample = len(sample)
        self.col_sample = len(sample[0])
        self.weight = []

    def training(self):
        for sample in self.sample:
            sample.insert(0, self.bias)

        for i in range(self.col_sample):
           self.weight.append(random.random())

        self.weight.insert(0, self.bias)

        epoch_count = 0

        while True:
            erro = False
            for i in range(self.number_sample):
                u = 0
                for j in range(self.col_sample + 1):
                    u = u + self.weight[j] * self.sample[i][j]
                y = self.sign(u)
                if y != self.exit[i]:

                    for j in range(self.col_sample + 1):

                        self.weight[j] = self.weight[j] + self.learn_rate * (self.exit[i] - y) * self.sample[i][j]
                    erro = True
            #print('Epoch: \n',epoch_count)
            epoch_count = epoch_count + 1
            # if you want controle the epoch or just by erro
            if erro == False:
                print(('\nEpoch:\n',epoch_count))
                print('------------------------\n')
            #if epoch_count > self.epoch_number or not erro:
                break

    def sort(self, sample):
        sample.insert(0, self.bias)
        u = 0
        for i in range(self.col_sample + 1):
            u = u + self.weight[i] * sample[i]

        y = self.sign(u)

        if  y == -1:
            print(('Sample: ', sample))
            print('classification: P1')
        else:
            print(('Sample: ', sample))
            print('classification: P2')

    def sign(self, u):
        return 1 if u >= 0 else -1


samples = [
    [-0.6508, 0.1097, 4.0009],
    [-1.4492, 0.8896, 4.4005],
    [2.0850, 0.6876, 12.0710],
    [0.2626, 1.1476, 7.7985],
    [0.6418, 1.0234, 7.0427],
    [0.2569, 0.6730, 8.3265],
    [1.1155, 0.6043, 7.4446],
    [0.0914, 0.3399, 7.0677],
    [0.0121, 0.5256, 4.6316],
    [-0.0429, 0.4660, 5.4323],
    [0.4340, 0.6870, 8.2287],
    [0.2735, 1.0287, 7.1934],
    [0.4839, 0.4851, 7.4850],
    [0.4089, -0.1267, 5.5019],
    [1.4391, 0.1614, 8.5843],
    [-0.9115, -0.1973, 2.1962],
    [0.3654, 1.0475, 7.4858],
    [0.2144, 0.7515, 7.1699],
    [0.2013, 1.0014, 6.5489],
    [0.6483, 0.2183, 5.8991],
    [-0.1147, 0.2242, 7.2435],
    [-0.7970, 0.8795, 3.8762],
    [-1.0625, 0.6366, 2.4707],
    [0.5307, 0.1285, 5.6883],
    [-1.2200, 0.7777, 1.7252],
    [0.3957, 0.1076, 5.6623],
    [-0.1013, 0.5989, 7.1812],
    [2.4482, 0.9455, 11.2095],
    [2.0149, 0.6192, 10.9263],
    [0.2012, 0.2611, 5.4631]

]

exit = [-1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, -1, 1]

network = Perceptron(sample=samples, exit = exit, learn_rate=0.01, epoch_number=1000, bias=-1)

network.training()

while True:
    sample = []
    for i in range(3):
        sample.insert(i, float(input('value: ')))
    network.sort(sample)
<EOF>
<BOF>
#!/usr/bin/python
# encoding=utf8

'''

A Framework of Back Propagation Neural NetworkBP model

Easy to use:
    * add many layers as you want 
    * clearly see how the loss decreasing
Easy to expand:
    * more activation functions
    * more loss functions
    * more optimization method

Author: Stephen Lee
Github : https://github.com/RiptideBo
Date: 2017.11.23

'''

import numpy as np
import matplotlib.pyplot as plt


def sigmoid(x):
    return 1 / (1 + np.exp(-1 * x))

class DenseLayer():
    '''
    Layers of BP neural network
    '''
    def __init__(self,units,activation=None,learning_rate=None,is_input_layer=False):
        '''
        common connected layer of bp network
        :param units: numbers of neural units
        :param activation: activation function
        :param learning_rate: learning rate for paras
        :param is_input_layer: whether it is input layer or not
        '''
        self.units = units
        self.weight = None
        self.bias = None
        self.activation = activation
        if learning_rate is None:
            learning_rate = 0.3
        self.learn_rate = learning_rate
        self.is_input_layer = is_input_layer

    def initializer(self,back_units):
        self.weight = np.asmatrix(np.random.normal(0,0.5,(self.units,back_units)))
        self.bias = np.asmatrix(np.random.normal(0,0.5,self.units)).T
        if self.activation is None:
            self.activation = sigmoid

    def cal_gradient(self):
        if self.activation == sigmoid:
            gradient_mat = np.dot(self.output ,(1- self.output).T)
            gradient_activation = np.diag(np.diag(gradient_mat))
        else:
            gradient_activation = 1
        return gradient_activation

    def forward_propagation(self,xdata):
        self.xdata = xdata
        if self.is_input_layer:
            # input layer
            self.wx_plus_b = xdata
            self.output = xdata
            return xdata
        else:
            self.wx_plus_b = np.dot(self.weight,self.xdata) - self.bias
            self.output = self.activation(self.wx_plus_b)
            return self.output

    def back_propagation(self,gradient):

        gradient_activation = self.cal_gradient() # i * i 
        gradient = np.asmatrix(np.dot(gradient.T,gradient_activation))

        self._gradient_weight = np.asmatrix(self.xdata)
        self._gradient_bias = -1
        self._gradient_x = self.weight

        self.gradient_weight = np.dot(gradient.T,self._gradient_weight.T)
        self.gradient_bias = gradient * self._gradient_bias
        self.gradient = np.dot(gradient,self._gradient_x).T
        # ----------------------upgrade
        # -----------the Negative gradient direction --------
        self.weight = self.weight - self.learn_rate * self.gradient_weight
        self.bias = self.bias - self.learn_rate * self.gradient_bias.T

        return self.gradient


class BPNN():
    '''
    Back Propagation Neural Network model
    '''
    def __init__(self):
        self.layers = []
        self.train_mse = []
        self.fig_loss = plt.figure()
        self.ax_loss = self.fig_loss.add_subplot(1,1,1)

    def add_layer(self,layer):
        self.layers.append(layer)

    def build(self):
        for i,layer in enumerate(self.layers[:]):
            if i < 1:
                layer.is_input_layer = True
            else:
                layer.initializer(self.layers[i-1].units)

    def summary(self):
        for i,layer in enumerate(self.layers[:]):
            print('------- layer %d -------'%i)
            print('weight.shape ',np.shape(layer.weight))
            print('bias.shape ',np.shape(layer.bias))

    def train(self,xdata,ydata,train_round,accuracy):
        self.train_round = train_round
        self.accuracy = accuracy

        self.ax_loss.hlines(self.accuracy, 0, self.train_round * 1.1)

        x_shape = np.shape(xdata)
        for round_i in range(train_round):
            all_loss = 0
            for row in range(x_shape[0]):
                _xdata = np.asmatrix(xdata[row,:]).T
                _ydata = np.asmatrix(ydata[row,:]).T

                # forward propagation
                for layer in self.layers:
                    _xdata = layer.forward_propagation(_xdata)

                loss, gradient = self.cal_loss(_ydata, _xdata)
                all_loss = all_loss + loss

                # back propagation
                # the input_layer does not upgrade
                for layer in self.layers[:0:-1]:
                    gradient = layer.back_propagation(gradient)

            mse = all_loss/x_shape[0]
            self.train_mse.append(mse)

            self.plot_loss()

            if mse < self.accuracy:
                print('--------')
                return mse

    def cal_loss(self,ydata,ydata_):
        self.loss = np.sum(np.power((ydata - ydata_),2))
        self.loss_gradient = 2 * (ydata_ - ydata)
        # vector (shape is the same as _ydata.shape)
        return self.loss,self.loss_gradient

    def plot_loss(self):
        if self.ax_loss.lines:
            self.ax_loss.lines.remove(self.ax_loss.lines[0])
        self.ax_loss.plot(self.train_mse, 'r-')
        plt.ion()
        plt.xlabel('step')
        plt.ylabel('loss')
        plt.show()
        plt.pause(0.1)




def example():

    x = np.random.randn(10,10)
    y = np.asarray([[0.8,0.4],[0.4,0.3],[0.34,0.45],[0.67,0.32],
                    [0.88,0.67],[0.78,0.77],[0.55,0.66],[0.55,0.43],[0.54,0.1],
                    [0.1,0.5]])

    model = BPNN()
    model.add_layer(DenseLayer(10))
    model.add_layer(DenseLayer(20))
    model.add_layer(DenseLayer(30))
    model.add_layer(DenseLayer(2))

    model.build()

    model.summary()

    model.train(xdata=x,ydata=y,train_round=100,accuracy=0.01)

if __name__ == '__main__':
    example()
<EOF>
<BOF>
#-*- coding: utf-8 -*-

'''
     - - - - - -- - - - - - - - - - - - - - - - - - - - - - -
    Name - - CNN - Convolution Neural Network For Photo Recognizing
    Goal - - Recognize Handing Writting Word Photo
    DetailTotal 5 layers neural network
            * Convolution layer
            * Pooling layer
            * Input layer layer of BP
            * Hiden layer of BP
            * Output layer of BP
    Author: Stephen Lee
    Github: 245885195@qq.com
    Date: 2017.9.20
    - - - - - -- - - - - - - - - - - - - - - - - - - - - - -
          '''
from __future__ import print_function

import numpy as np
import matplotlib.pyplot as plt

class CNN():

    def __init__(self,conv1_get,size_p1,bp_num1,bp_num2,bp_num3,rate_w=0.2,rate_t=0.2):
        '''
        :param conv1_get: [a,c,d]size, number, step of convolution kernel
        :param size_p1: pooling size
        :param bp_num1: units number of flatten layer
        :param bp_num2: units number of hidden layer
        :param bp_num3: units number of output layer
        :param rate_w: rate of weight learning
        :param rate_t: rate of threshold learning
        '''
        self.num_bp1 = bp_num1
        self.num_bp2 = bp_num2
        self.num_bp3 = bp_num3
        self.conv1 = conv1_get[:2]
        self.step_conv1 = conv1_get[2]
        self.size_pooling1 = size_p1
        self.rate_weight = rate_w
        self.rate_thre = rate_t
        self.w_conv1 = [np.mat(-1*np.random.rand(self.conv1[0],self.conv1[0])+0.5) for i in range(self.conv1[1])]
        self.wkj = np.mat(-1 * np.random.rand(self.num_bp3, self.num_bp2) + 0.5)
        self.vji = np.mat(-1*np.random.rand(self.num_bp2, self.num_bp1)+0.5)
        self.thre_conv1 = -2*np.random.rand(self.conv1[1])+1
        self.thre_bp2 = -2*np.random.rand(self.num_bp2)+1
        self.thre_bp3 = -2*np.random.rand(self.num_bp3)+1


    def save_model(self,save_path):
        #save model dict with pickle
        import pickle
        model_dic = {'num_bp1':self.num_bp1,
                    'num_bp2':self.num_bp2,
                    'num_bp3':self.num_bp3,
                    'conv1':self.conv1,
                    'step_conv1':self.step_conv1,
                    'size_pooling1':self.size_pooling1,
                    'rate_weight':self.rate_weight,
                    'rate_thre':self.rate_thre,
                    'w_conv1':self.w_conv1,
                    'wkj':self.wkj,
                    'vji':self.vji,
                    'thre_conv1':self.thre_conv1,
                    'thre_bp2':self.thre_bp2,
                     'thre_bp3':self.thre_bp3}
        with open(save_path, 'wb') as f:
            pickle.dump(model_dic, f)

        print('Model saved %s'% save_path)

    @classmethod
    def ReadModel(cls,model_path):
        #read saved model
        import pickle
        with open(model_path, 'rb') as f:
            model_dic = pickle.load(f)

        conv_get= model_dic.get('conv1')
        conv_get.append(model_dic.get('step_conv1'))
        size_p1 = model_dic.get('size_pooling1')
        bp1 = model_dic.get('num_bp1')
        bp2 = model_dic.get('num_bp2')
        bp3 = model_dic.get('num_bp3')
        r_w = model_dic.get('rate_weight')
        r_t = model_dic.get('rate_thre')
        #create model instance
        conv_ins = CNN(conv_get,size_p1,bp1,bp2,bp3,r_w,r_t)
        #modify model parameter
        conv_ins.w_conv1 = model_dic.get('w_conv1')
        conv_ins.wkj = model_dic.get('wkj')
        conv_ins.vji = model_dic.get('vji')
        conv_ins.thre_conv1 = model_dic.get('thre_conv1')
        conv_ins.thre_bp2 = model_dic.get('thre_bp2')
        conv_ins.thre_bp3 = model_dic.get('thre_bp3')
        return conv_ins


    def sig(self,x):
        return 1 / (1 + np.exp(-1*x))

    def do_round(self,x):
        return round(x, 3)

    def convolute(self,data,convs,w_convs,thre_convs,conv_step):
        #convolution process
        size_conv = convs[0]
        num_conv =convs[1]
        size_data = np.shape(data)[0]
        #get the data slice of original image data, data_focus
        data_focus = []
        for i_focus in range(0, size_data - size_conv + 1, conv_step):
            for j_focus in range(0, size_data - size_conv + 1, conv_step):
                focus = data[i_focus:i_focus + size_conv, j_focus:j_focus + size_conv]
                data_focus.append(focus)
        #caculate the feature map of every single kernel, and saved as list of matrix
        data_featuremap = []
        Size_FeatureMap = int((size_data - size_conv) / conv_step + 1)
        for i_map in range(num_conv):
            featuremap = []
            for i_focus in range(len(data_focus)):
                net_focus = np.sum(np.multiply(data_focus[i_focus], w_convs[i_map])) - thre_convs[i_map]
                featuremap.append(self.sig(net_focus))
            featuremap = np.asmatrix(featuremap).reshape(Size_FeatureMap, Size_FeatureMap)
            data_featuremap.append(featuremap)

        #expanding the data slice to One dimenssion
        focus1_list = []
        for each_focus in data_focus:
            focus1_list.extend(self.Expand_Mat(each_focus))
        focus_list = np.asarray(focus1_list)
        return focus_list,data_featuremap

    def pooling(self,featuremaps,size_pooling,type='average_pool'):
        #pooling process
        size_map = len(featuremaps[0])
        size_pooled = int(size_map/size_pooling)
        featuremap_pooled = []
        for i_map in range(len(featuremaps)):
            map = featuremaps[i_map]
            map_pooled = []
            for i_focus in range(0,size_map,size_pooling):
                for j_focus in range(0, size_map, size_pooling):
                    focus = map[i_focus:i_focus + size_pooling, j_focus:j_focus + size_pooling]
                    if type == 'average_pool':
                        #average pooling
                        map_pooled.append(np.average(focus))
                    elif type == 'max_pooling':
                        #max pooling
                        map_pooled.append(np.max(focus))
            map_pooled = np.asmatrix(map_pooled).reshape(size_pooled,size_pooled)
            featuremap_pooled.append(map_pooled)
        return featuremap_pooled

    def _expand(self,datas):
        #expanding three dimension data to one dimension list
        data_expanded = []
        for i in range(len(datas)):
            shapes = np.shape(datas[i])
            data_listed = datas[i].reshape(1,shapes[0]*shapes[1])
            data_listed = data_listed.getA().tolist()[0]
            data_expanded.extend(data_listed)
        data_expanded = np.asarray(data_expanded)
        return data_expanded

    def _expand_mat(self,data_mat):
        #expanding matrix to one dimension list
        data_mat = np.asarray(data_mat)
        shapes = np.shape(data_mat)
        data_expanded = data_mat.reshape(1,shapes[0]*shapes[1])
        return data_expanded

    def _calculate_gradient_from_pool(self,out_map,pd_pool,num_map,size_map,size_pooling):
        '''
        calcluate the gradient from the data slice of pool layer
        pd_pool: list of matrix
        out_map: the shape of data slice(size_map*size_map)
        return: pd_all: list of matrix, [num, size_map, size_map]
        '''
        pd_all = []
        i_pool = 0
        for i_map in range(num_map):
            pd_conv1 = np.ones((size_map, size_map))
            for i in range(0, size_map, size_pooling):
                for j in range(0, size_map, size_pooling):
                    pd_conv1[i:i + size_pooling, j:j + size_pooling] = pd_pool[i_pool]
                    i_pool = i_pool + 1
            pd_conv2 = np.multiply(pd_conv1,np.multiply(out_map[i_map],(1-out_map[i_map])))
            pd_all.append(pd_conv2)
        return pd_all

    def trian(self,patterns,datas_train, datas_teach, n_repeat, error_accuracy,draw_e = bool):
        #model traning
        print('----------------------Start Training-------------------------')
        print((' - - Shape: Train_Data  ',np.shape(datas_train)))
        print((' - - Shape: Teach_Data  ',np.shape(datas_teach)))
        rp = 0
        all_mse = []
        mse  = 10000
        while rp < n_repeat and mse >= error_accuracy:
            alle = 0
            print('-------------Learning Time %d--------------'%rp)
            for p in range(len(datas_train)):
                #print('------------Learning Image: %d--------------'%p)
                data_train = np.asmatrix(datas_train[p])
                data_teach = np.asarray(datas_teach[p])
                data_focus1,data_conved1 = self.convolute(data_train,self.conv1,self.w_conv1,
                                           self.thre_conv1,conv_step=self.step_conv1)
                data_pooled1 = self.pooling(data_conved1,self.size_pooling1)
                shape_featuremap1 = np.shape(data_conved1)
                '''
                print('  -----original shape   ', np.shape(data_train))
                print('  ---- after convolution  ',np.shape(data_conv1))
                print('  -----after pooling  ',np.shape(data_pooled1))
               '''
                data_bp_input = self._expand(data_pooled1)
                bp_out1 = data_bp_input

                bp_net_j = np.dot(bp_out1,self.vji.T) - self.thre_bp2
                bp_out2 = self.sig(bp_net_j)
                bp_net_k = np.dot(bp_out2 ,self.wkj.T) - self.thre_bp3
                bp_out3 = self.sig(bp_net_k)

                #--------------Model Leaning ------------------------
                # calcluate error and gradient---------------
                pd_k_all = np.multiply((data_teach - bp_out3), np.multiply(bp_out3, (1 - bp_out3)))
                pd_j_all = np.multiply(np.dot(pd_k_all,self.wkj), np.multiply(bp_out2, (1 - bp_out2)))
                pd_i_all = np.dot(pd_j_all,self.vji)

                pd_conv1_pooled = pd_i_all / (self.size_pooling1*self.size_pooling1)
                pd_conv1_pooled = pd_conv1_pooled.T.getA().tolist()
                pd_conv1_all = self._calculate_gradient_from_pool(data_conved1,pd_conv1_pooled,shape_featuremap1[0],
                                                    shape_featuremap1[1],self.size_pooling1)
                #weight and threshold learning process---------
                #convolution layer
                for k_conv in range(self.conv1[1]):
                    pd_conv_list = self._expand_mat(pd_conv1_all[k_conv])
                    delta_w = self.rate_weight * np.dot(pd_conv_list,data_focus1)

                    self.w_conv1[k_conv] = self.w_conv1[k_conv] + delta_w.reshape((self.conv1[0],self.conv1[0]))

                    self.thre_conv1[k_conv] = self.thre_conv1[k_conv] - np.sum(pd_conv1_all[k_conv]) * self.rate_thre
                #all connected layer
                self.wkj = self.wkj + pd_k_all.T * bp_out2 * self.rate_weight
                self.vji = self.vji + pd_j_all.T * bp_out1 * self.rate_weight
                self.thre_bp3 = self.thre_bp3 - pd_k_all * self.rate_thre
                self.thre_bp2 = self.thre_bp2 - pd_j_all * self.rate_thre
                # calculate the sum error of all single image
                errors = np.sum(abs((data_teach - bp_out3)))
                alle = alle + errors
                #print('   ----Teach      ',data_teach)
                #print('   ----BP_output  ',bp_out3)
            rp = rp + 1
            mse = alle/patterns
            all_mse.append(mse)
        def draw_error():
            yplot = [error_accuracy for i in range(int(n_repeat * 1.2))]
            plt.plot(all_mse, '+-')
            plt.plot(yplot, 'r--')
            plt.xlabel('Learning Times')
            plt.ylabel('All_mse')
            plt.grid(True, alpha=0.5)
            plt.show()
        print('------------------Training Complished---------------------')
        print((' - - Training epoch: ', rp, '     - - Mse: %.6f' % mse))
        if draw_e:
            draw_error()
        return mse

    def predict(self,datas_test):
        #model predict
        produce_out = []
        print('-------------------Start Testing-------------------------')
        print((' - - Shape: Test_Data  ',np.shape(datas_test)))
        for p in range(len(datas_test)):
            data_test = np.asmatrix(datas_test[p])
            data_focus1, data_conved1 = self.convolute(data_test, self.conv1, self.w_conv1,
                                                     self.thre_conv1, conv_step=self.step_conv1)
            data_pooled1 = self.pooling(data_conved1, self.size_pooling1)
            data_bp_input = self._expand(data_pooled1)

            bp_out1 = data_bp_input
            bp_net_j = bp_out1 * self.vji.T - self.thre_bp2
            bp_out2 = self.sig(bp_net_j)
            bp_net_k = bp_out2 * self.wkj.T - self.thre_bp3
            bp_out3 = self.sig(bp_net_k)
            produce_out.extend(bp_out3.getA().tolist())
        res = [list(map(self.do_round,each)) for each in produce_out]
        return np.asarray(res)

    def convolution(self,data):
        #return the data of image after convoluting process so we can check it out
        data_test = np.asmatrix(data)
        data_focus1, data_conved1 = self.convolute(data_test, self.conv1, self.w_conv1,
                                                     self.thre_conv1, conv_step=self.step_conv1)
        data_pooled1 = self.pooling(data_conved1, self.size_pooling1)

        return data_conved1,data_pooled1


if __name__ == '__main__':
    pass
    '''
    I will put the example on other file
    '''
<EOF>
<BOF>
# Minimum cut on Ford_Fulkerson algorithm.
    
def BFS(graph, s, t, parent):
    # Return True if there is node that has not iterated.
    visited = [False]*len(graph)
    queue=[]
    queue.append(s)
    visited[s] = True
    
    while queue:
        u = queue.pop(0)
        for ind in range(len(graph[u])):
            if visited[ind] == False and graph[u][ind] > 0:
                queue.append(ind)
                visited[ind] = True
                parent[ind] = u

    return True if visited[t] else False
 
def mincut(graph, source, sink):
    # This array is filled by BFS and to store path
    parent = [-1]*(len(graph))
    max_flow = 0 
    res = []
    temp = [i[:] for i in graph]   # Record orignial cut, copy.
    while BFS(graph, source, sink, parent) :
        path_flow = float("Inf")
        s = sink

        while(s !=  source):
            # Find the minimum value in select path
            path_flow = min (path_flow, graph[parent[s]][s])
            s = parent[s]

        max_flow +=  path_flow
        v = sink
        
        while(v !=  source):
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = parent[v]

    for i in range(len(graph)):
        for j in range(len(graph[0])):
            if graph[i][j] == 0 and temp[i][j] > 0:
                res.append((i,j))

    return res

graph = [[0, 16, 13, 0, 0, 0],
         [0, 0, 10 ,12, 0, 0],
         [0, 4, 0, 0, 14, 0],
         [0, 0, 9, 0, 0, 20],
         [0, 0, 0, 7, 0, 4],
         [0, 0, 0, 0, 0, 0]]

source, sink = 0, 5
print(mincut(graph, source, sink))
<EOF>
<BOF>
# Ford-Fulkerson Algorithm for Maximum Flow Problem
"""
Description:
    (1) Start with initial flow as 0;
    (2) Choose augmenting path from source to sink and add path to flow;
"""
    
def BFS(graph, s, t, parent):
    # Return True if there is node that has not iterated.
    visited = [False]*len(graph)
    queue=[]
    queue.append(s)
    visited[s] = True
    
    while queue:
        u = queue.pop(0)
        for ind in range(len(graph[u])):
            if visited[ind] == False and graph[u][ind] > 0:
                queue.append(ind)
                visited[ind] = True
                parent[ind] = u

    return True if visited[t] else False
     
def FordFulkerson(graph, source, sink):
    # This array is filled by BFS and to store path
    parent = [-1]*(len(graph))
    max_flow = 0 
    while BFS(graph, source, sink, parent) :
        path_flow = float("Inf")
        s = sink

        while(s !=  source):
            # Find the minimum value in select path
            path_flow = min (path_flow, graph[parent[s]][s])
            s = parent[s]

        max_flow +=  path_flow
        v = sink

        while(v !=  source):
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = parent[v]
    return max_flow

graph = [[0, 16, 13, 0, 0, 0],
         [0, 0, 10 ,12, 0, 0],
         [0, 4, 0, 0, 14, 0],
         [0, 0, 9, 0, 0, 20],
         [0, 0, 0, 7, 0, 4],
         [0, 0, 0, 0, 0, 0]]

source, sink = 0, 5
print(FordFulkerson(graph, source, sink))
<EOF>
<BOF>
def add(matrix_a, matrix_b):
    rows = len(matrix_a)
    columns = len(matrix_a[0])
    matrix_c = []
    for i in range(rows):
        list_1 = []
        for j in range(columns):
            val = matrix_a[i][j] + matrix_b[i][j]
            list_1.append(val)
        matrix_c.append(list_1)
    return matrix_c


def multiply(matrix_a, matrix_b):
    matrix_c = []
    n = len(matrix_a)
    for i in range(n):
        list_1 = []
        for j in range(n):
            val = 0
            for k in range(n):
                val = val + matrix_a[i][k] * matrix_b[k][j]
            list_1.append(val)
        matrix_c.append(list_1)
    return matrix_c


def main():
    matrix_a = [[12, 10], [3, 9]]
    matrix_b = [[3, 4], [7, 4]]
    print(add(matrix_a, matrix_b))
    print(multiply(matrix_a, matrix_b))


if __name__ == '__main__':
    main()
<EOF>
<BOF>
"""
Author  : Turfa Auliarachman
Date    : October 12, 2016

This is a pure Python implementation of Dynamic Programming solution to the edit distance problem.

The problem is :
Given two strings A and B. Find the minimum number of operations to string B such that A = B. The permitted operations are removal,  insertion, and substitution.
"""
from __future__ import print_function


class EditDistance:
    """
    Use :
    solver              = EditDistance()
    editDistanceResult  = solver.solve(firstString, secondString)
    """

    def __init__(self):
        self.__prepare__()

    def __prepare__(self, N = 0, M = 0):
        self.dp = [[-1 for y in range(0,M)] for x in range(0,N)]

    def __solveDP(self, x, y):
        if (x==-1):
            return y+1
        elif (y==-1):
            return x+1
        elif (self.dp[x][y]>-1):
            return self.dp[x][y]
        else:
            if (self.A[x]==self.B[y]):
                self.dp[x][y] = self.__solveDP(x-1,y-1)
            else:
                self.dp[x][y] = 1+min(self.__solveDP(x,y-1), self.__solveDP(x-1,y), self.__solveDP(x-1,y-1))

            return self.dp[x][y]

    def solve(self, A, B):
        if isinstance(A,bytes):
            A = A.decode('ascii')

        if isinstance(B,bytes):
            B = B.decode('ascii')

        self.A = str(A)
        self.B = str(B)

        self.__prepare__(len(A), len(B))

        return self.__solveDP(len(A)-1, len(B)-1)

if __name__ == '__main__':
        try:
            raw_input          # Python 2
        except NameError:
            raw_input = input  # Python 3

        solver = EditDistance()

        print("****************** Testing Edit Distance DP Algorithm ******************")
        print()

        print("Enter the first string: ", end="")
        S1 = raw_input().strip()

        print("Enter the second string: ", end="")
        S2 = raw_input().strip()

        print()
        print("The minimum Edit Distance is: %d" % (solver.solve(S1, S2)))
        print()
        print("*************** End of Testing Edit Distance DP Algorithm ***************")
<EOF>
<BOF>
import math

class Graph:
    
    def __init__(self, N = 0): # a graph with Node 0,1,...,N-1
        self.N = N
        self.W = [[math.inf for j in range(0,N)] for i in range(0,N)] # adjacency matrix for weight
        self.dp = [[math.inf for j in range(0,N)] for i in range(0,N)] # dp[i][j] stores minimum distance from i to j

    def addEdge(self, u, v, w):
        self.dp[u][v] = w

    def floyd_warshall(self):
        for k in range(0,self.N):
            for i in range(0,self.N):
                for j in range(0,self.N):
                    self.dp[i][j] = min(self.dp[i][j], self.dp[i][k] + self.dp[k][j])

    def showMin(self, u, v):
        return self.dp[u][v]
    
if __name__ == '__main__':
    graph = Graph(5)
    graph.addEdge(0,2,9)
    graph.addEdge(0,4,10)
    graph.addEdge(1,3,5)
    graph.addEdge(2,3,7)
    graph.addEdge(3,0,10)
    graph.addEdge(3,1,2)
    graph.addEdge(3,2,1)
    graph.addEdge(3,4,6)
    graph.addEdge(4,1,3)
    graph.addEdge(4,2,4)
    graph.addEdge(4,3,9)
    graph.floyd_warshall()
    graph.showMin(1,4)
    graph.showMin(0,3)
<EOF>
<BOF>
from __future__ import print_function

import sys
'''
Dynamic Programming
Implementation of Matrix Chain Multiplication
Time Complexity: O(n^3)
Space Complexity: O(n^2)
'''
def MatrixChainOrder(array):
    N=len(array)
    Matrix=[[0 for x in range(N)] for x in range(N)]
    Sol=[[0 for x in range(N)] for x in range(N)]

    for ChainLength in range(2,N):
        for a in range(1,N-ChainLength+1):
            b = a+ChainLength-1

            Matrix[a][b] = sys.maxsize
            for c in range(a , b):
                cost = Matrix[a][c] + Matrix[c+1][b] + array[a-1]*array[c]*array[b]
                if cost < Matrix[a][b]:
                    Matrix[a][b] = cost
                    Sol[a][b] = c
    return Matrix , Sol
#Print order of matrix with Ai as Matrix
def PrintOptimalSolution(OptimalSolution,i,j):
    if i==j:
        print("A" + str(i),end = " ")
    else:
        print("(",end = " ")
        PrintOptimalSolution(OptimalSolution,i,OptimalSolution[i][j])
        PrintOptimalSolution(OptimalSolution,OptimalSolution[i][j]+1,j)
        print(")",end = " ")

def main():
    array=[30,35,15,5,10,20,25]
    n=len(array)
    #Size of matrix created from above array will be
    # 30*35 35*15 15*5 5*10 10*20 20*25
    Matrix , OptimalSolution = MatrixChainOrder(array)

    print("No. of Operation required: "+str((Matrix[1][n-1])))
    PrintOptimalSolution(OptimalSolution,1,n-1)
if __name__ == '__main__':
    main()
<EOF>
<BOF>
"""
You have m types of coins available in infinite quantities
where the value of each coins is given in the array S=[S0,... Sm-1]
Can you determine number of ways of making change for n units using
the given types of coins?
https://www.hackerrank.com/challenges/coin-change/problem
"""
from __future__ import print_function
def dp_count(S, m, n):
    table = [0] * (n + 1)

    # Base case (If given value is 0)
    table[0] = 1

    # Pick all coins one by one and update table[] values
    # after the index greater than or equal to the value of the
    # picked coin
    for i in range(0, m):
        for j in range(S[i], n + 1):
            table[j] += table[j - S[i]]

    return table[n]

if __name__ == '__main__':
    print(dp_count([1, 2, 3], 3, 4))  # answer 4
    print(dp_count([2, 5, 3, 6], 4, 10))  # answer 5
<EOF>
<BOF>
from itertools import accumulate
from bisect import bisect

def fracKnapsack(vl, wt, W, n):

    r = list(sorted(zip(vl,wt), key=lambda x:x[0]/x[1],reverse=True))
    vl , wt = [i[0] for i in r],[i[1] for i in r]
    acc=list(accumulate(wt))
    k = bisect(acc,W)
    return 0 if k == 0 else sum(vl[:k])+(W-acc[k-1])*(vl[k])/(wt[k]) if k!=n else sum(vl[:k])

print("%.0f"%fracKnapsack([60, 100, 120],[10, 20, 30],50,3))
<EOF>
<BOF>
"""
This is a pure Python implementation of Dynamic Programming solution to the fibonacci sequence problem.
"""
from __future__ import print_function


class Fibonacci:

    def __init__(self, N=None):
        self.fib_array = []
        if N:
            N = int(N)
            self.fib_array.append(0)
            self.fib_array.append(1)
            for i in range(2, N + 1):
                self.fib_array.append(self.fib_array[i - 1] + self.fib_array[i - 2])
        elif N == 0:
            self.fib_array.append(0)

    def get(self, sequence_no=None):
        if sequence_no != None:
            if sequence_no < len(self.fib_array):
                return print(self.fib_array[:sequence_no + 1])
            else:
                print("Out of bound.")
        else:
            print("Please specify a value")


if __name__ == '__main__':
    print("\n********* Fibonacci Series Using Dynamic Programming ************\n")
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    print("\n Enter the upper limit for the fibonacci sequence: ", end="")
    try:
        N = eval(raw_input().strip())
        fib = Fibonacci(N)
        print(
            "\n********* Enter different values to get the corresponding fibonacci sequence, enter any negative number to exit. ************\n")
        while True:
            print("Enter value: ", end=" ")
            try:
                i = eval(raw_input().strip())
                if i < 0:
                    print("\n********* Good Bye!! ************\n")
                    break
                fib.get(i)
            except NameError:
                print("\nInvalid input, please try again.")
    except NameError:
        print("\n********* Invalid input, good bye!! ************\n")
<EOF>
<BOF>
import tensorflow as tf
from random import shuffle
from numpy import array


def TFKMeansCluster(vectors, noofclusters):
    """
    K-Means Clustering using TensorFlow.
    'vectors' should be a n*k 2-D NumPy array, where n is the number
    of vectors of dimensionality k.
    'noofclusters' should be an integer.
    """

    noofclusters = int(noofclusters)
    assert noofclusters < len(vectors)

    #Find out the dimensionality
    dim = len(vectors[0])

    #Will help select random centroids from among the available vectors
    vector_indices = list(range(len(vectors)))
    shuffle(vector_indices)

    #GRAPH OF COMPUTATION
    #We initialize a new graph and set it as the default during each run
    #of this algorithm. This ensures that as this function is called
    #multiple times, the default graph doesn't keep getting crowded with
    #unused ops and Variables from previous function calls.

    graph = tf.Graph()

    with graph.as_default():

        #SESSION OF COMPUTATION

        sess = tf.Session()

        ##CONSTRUCTING THE ELEMENTS OF COMPUTATION

        ##First lets ensure we have a Variable vector for each centroid,
        ##initialized to one of the vectors from the available data points
        centroids = [tf.Variable((vectors[vector_indices[i]]))
                     for i in range(noofclusters)]
        ##These nodes will assign the centroid Variables the appropriate
        ##values
        centroid_value = tf.placeholder("float64", [dim])
        cent_assigns = []
        for centroid in centroids:
            cent_assigns.append(tf.assign(centroid, centroid_value))

        ##Variables for cluster assignments of individual vectors(initialized
        ##to 0 at first)
        assignments = [tf.Variable(0) for i in range(len(vectors))]
        ##These nodes will assign an assignment Variable the appropriate
        ##value
        assignment_value = tf.placeholder("int32")
        cluster_assigns = []
        for assignment in assignments:
            cluster_assigns.append(tf.assign(assignment,
                                             assignment_value))

        ##Now lets construct the node that will compute the mean
        #The placeholder for the input
        mean_input = tf.placeholder("float", [None, dim])
        #The Node/op takes the input and computes a mean along the 0th
        #dimension, i.e. the list of input vectors
        mean_op = tf.reduce_mean(mean_input, 0)

        ##Node for computing Euclidean distances
        #Placeholders for input
        v1 = tf.placeholder("float", [dim])
        v2 = tf.placeholder("float", [dim])
        euclid_dist = tf.sqrt(tf.reduce_sum(tf.pow(tf.sub(
            v1, v2), 2)))

        ##This node will figure out which cluster to assign a vector to,
        ##based on Euclidean distances of the vector from the centroids.
        #Placeholder for input
        centroid_distances = tf.placeholder("float", [noofclusters])
        cluster_assignment = tf.argmin(centroid_distances, 0)

        ##INITIALIZING STATE VARIABLES

        ##This will help initialization of all Variables defined with respect
        ##to the graph. The Variable-initializer should be defined after
        ##all the Variables have been constructed, so that each of them
        ##will be included in the initialization.
        init_op = tf.initialize_all_variables()

        #Initialize all variables
        sess.run(init_op)

        ##CLUSTERING ITERATIONS

        #Now perform the Expectation-Maximization steps of K-Means clustering
        #iterations. To keep things simple, we will only do a set number of
        #iterations, instead of using a Stopping Criterion.
        noofiterations = 100
        for iteration_n in range(noofiterations):

            ##EXPECTATION STEP
            ##Based on the centroid locations till last iteration, compute
            ##the _expected_ centroid assignments.
            #Iterate over each vector
            for vector_n in range(len(vectors)):
                vect = vectors[vector_n]
                #Compute Euclidean distance between this vector and each
                #centroid. Remember that this list cannot be named
                #'centroid_distances', since that is the input to the
                #cluster assignment node.
                distances = [sess.run(euclid_dist, feed_dict={
                    v1: vect, v2: sess.run(centroid)})
                             for centroid in centroids]
                #Now use the cluster assignment node, with the distances
                #as the input
                assignment = sess.run(cluster_assignment, feed_dict = {
                    centroid_distances: distances})
                #Now assign the value to the appropriate state variable
                sess.run(cluster_assigns[vector_n], feed_dict={
                    assignment_value: assignment})

            ##MAXIMIZATION STEP
            #Based on the expected state computed from the Expectation Step,
            #compute the locations of the centroids so as to maximize the
            #overall objective of minimizing within-cluster Sum-of-Squares
            for cluster_n in range(noofclusters):
                #Collect all the vectors assigned to this cluster
                assigned_vects = [vectors[i] for i in range(len(vectors))
                                  if sess.run(assignments[i]) == cluster_n]
                #Compute new centroid location
                new_location = sess.run(mean_op, feed_dict={
                    mean_input: array(assigned_vects)})
                #Assign value to appropriate variable
                sess.run(cent_assigns[cluster_n], feed_dict={
                    centroid_value: new_location})

        #Return centroids and assignments
        centroids = sess.run(centroids)
        assignments = sess.run(assignments)
        return centroids, assignments

<EOF>
<BOF>
"""
Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack.
"""
def MF_knapsack(i,wt,val,j):
    '''
    This code involves the concept of memory functions. Here we solve the subproblems which are needed
    unlike the below example
    F is a 2D array with -1s filled up
    '''
    global F  # a global dp table for knapsack
    if F[i][j] < 0:
        if j < wt[i - 1]:
            val = MF_knapsack(i - 1,wt,val,j)
        else:
            val = max(MF_knapsack(i - 1,wt,val,j),MF_knapsack(i - 1,wt,val,j - wt[i - 1]) + val[i - 1])
        F[i][j] = val
    return F[i][j]

def knapsack(W, wt, val, n):
    dp = [[0 for i in range(W+1)]for j in range(n+1)]

    for i in range(1,n+1):
        for w in range(1,W+1):
            if(wt[i-1]<=w):
                dp[i][w] = max(val[i-1]+dp[i-1][w-wt[i-1]],dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]

    return dp[n][w]

if __name__ == '__main__':
    '''
    Adding test case for knapsack
    '''
    val = [3,2,4,4]
    wt = [4,3,2,3]
    n = 4
    w = 6
    F = [[0]*(w + 1)] + [[0] + [-1 for i in range(w + 1)] for j in range(n + 1)]
    print(knapsack(w,wt,val,n))
    print(MF_knapsack(n,wt,val,w))  # switched the n and w 
    
<EOF>
<BOF>
"""
https://www.hackerrank.com/challenges/abbr/problem
You can perform the following operation on some string, :

1. Capitalize zero or more of 's lowercase letters at some index i
   (i.e., make them uppercase).
2. Delete all of the remaining lowercase letters in .

Example:
a=daBcd and b="ABC"
daBcd -> capitalize a and c(dABCd) -> remove d (ABC)
"""


def abbr(a, b):
    n = len(a)
    m = len(b)
    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]
    dp[0][0] = True
    for i in range(n):
        for j in range(m + 1):
            if dp[i][j]:
                if j < m and a[i].upper() == b[j]:
                    dp[i + 1][j + 1] = True
                if a[i].islower():
                    dp[i + 1][j] = True
    return dp[n][m]


if __name__ == "__main__":
    print(abbr("daBcd", "ABC"))  # expect True
<EOF>
<BOF>
'''
Author  : Mehdi ALAOUI

This is a pure Python implementation of Dynamic Programming solution to the longest increasing subsequence of a given sequence.

The problem is  :
Given an ARRAY, to find the longest and increasing sub ARRAY in that given ARRAY and return it.
Example: [10, 22, 9, 33, 21, 50, 41, 60, 80] as input will return [10, 22, 33, 41, 60, 80] as output
'''
from __future__ import print_function

def longestSub(ARRAY): 			#This function is recursive
	
	ARRAY_LENGTH = len(ARRAY)
	if(ARRAY_LENGTH <= 1):  	#If the array contains only one element, we return it (it's the stop condition of recursion)
		return ARRAY
								#Else
	PIVOT=ARRAY[0]
	isFound=False
	i=1
	LONGEST_SUB=[]
	while(not isFound and i<ARRAY_LENGTH):
		if (ARRAY[i] < PIVOT):
			isFound=True
			TEMPORARY_ARRAY = [ element for element in ARRAY[i:] if element >= ARRAY[i] ]
			TEMPORARY_ARRAY = longestSub(TEMPORARY_ARRAY)
			if ( len(TEMPORARY_ARRAY) > len(LONGEST_SUB) ):
				LONGEST_SUB = TEMPORARY_ARRAY
		else:
			i+=1

	TEMPORARY_ARRAY = [ element for element in ARRAY[1:] if element >= PIVOT ]
	TEMPORARY_ARRAY = [PIVOT] + longestSub(TEMPORARY_ARRAY)
	if ( len(TEMPORARY_ARRAY) > len(LONGEST_SUB) ):
		return TEMPORARY_ARRAY
	else:
		return LONGEST_SUB

#Some examples

print(longestSub([4,8,7,5,1,12,2,3,9]))
print(longestSub([9,8,7,6,5,7]))
<EOF>
<BOF>
"""
Partition a set into two subsets such that the difference of subset sums is minimum
"""
def findMin(arr):
    n = len(arr)
    s = sum(arr)

    dp = [[False for x in range(s+1)]for y in range(n+1)]

    for i in range(1, n+1):
        dp[i][0] = True

    for i in range(1, s+1):
        dp[0][i] = False

    for i in range(1, n+1):
        for j in range(1, s+1):
            dp[i][j]= dp[i][j-1]

            if (arr[i-1] <= j):
                dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]]

    for j in range(int(s/2), -1, -1):
        if dp[n][j] == True:
            diff = s-2*j
            break;

    return diff
<EOF>
<BOF>
from __future__ import print_function

try:
	xrange		#Python 2
except NameError:
	xrange = range	#Python 3

try:
	raw_input		#Python 2
except NameError:
	raw_input = input	#Python 3

'''
The number of partitions of a number n into at least k parts equals the number of partitions into exactly k parts
plus the number of partitions into at least k-1 parts. Subtracting 1 from each part of a partition of n into k parts
gives a partition of n-k into k parts. These two facts together are used for this algorithm.
'''
def partition(m):
	memo = [[0 for _ in xrange(m)] for _ in xrange(m+1)]
	for i in xrange(m+1):
		memo[i][0] = 1

	for n in xrange(m+1):
		for k in xrange(1, m):
			memo[n][k] += memo[n][k-1]
			if n-k > 0:
				memo[n][k] += memo[n-k-1][k]

	return memo[m][m-1]

if __name__ == '__main__':
	import sys

	if len(sys.argv) == 1:
		try:
			n = int(raw_input('Enter a number: '))
			print(partition(n))
		except ValueError:
			print('Please enter a number.')
	else:
		try:
			n = int(sys.argv[1])
			print(partition(n))
		except ValueError:
			print('Please pass a number.')
<EOF>
<BOF>
from __future__ import print_function
#############################
# Author: Aravind Kashyap
# File: lis.py
# comments: This programme outputs the Longest Strictly Increasing Subsequence in O(NLogN)
#           Where N is the Number of elements in the list 
#############################
def CeilIndex(v,l,r,key):
	while r-l > 1:
		m = (l + r)/2
		if v[m] >= key:
			r = m
		else:
			l = m
	
	return r
	

def LongestIncreasingSubsequenceLength(v):
	if(len(v) == 0):
		return 0	
	
	tail = [0]*len(v)
	length = 1
	
	tail[0] = v[0]
	
	for i in range(1,len(v)):
		if v[i] < tail[0]:
			tail[0] = v[i]
		elif v[i] > tail[length-1]:
			tail[length] = v[i]
			length += 1			
		else:
			tail[CeilIndex(tail,-1,length-1,v[i])] = v[i]
	
	return length
	

v = [2, 5, 3, 7, 11, 8, 10, 13, 6]
print(LongestIncreasingSubsequenceLength(v))
<EOF>
<BOF>
'''
Auther  : Yvonne

This is a pure Python implementation of Dynamic Programming solution to the longest_sub_array problem.

The problem is  :
Given an array, to find the longest and continuous sub array and get the max sum of the sub array in the given array.
'''
from __future__ import print_function


class SubArray:

    def __init__(self, arr):
        # we need a list not a string, so do something to change the type
        self.array = arr.split(',')
        print(("the input array is:", self.array))

    def solve_sub_array(self):
        rear = [int(self.array[0])]*len(self.array)
        sum_value = [int(self.array[0])]*len(self.array)
        for i in range(1, len(self.array)):
            sum_value[i] = max(int(self.array[i]) + sum_value[i-1], int(self.array[i]))
            rear[i] = max(sum_value[i], rear[i-1])
        return rear[len(self.array)-1]


if __name__ == '__main__':
    whole_array = input("please input some numbers:")
    array = SubArray(whole_array)
    re = array.solve_sub_array()
    print(("the results is:", re))

<EOF>
<BOF>
"""
LCS Problem Statement: Given two sequences, find the length of longest subsequence present in both of them.
A subsequence is a sequence that appears in the same relative order, but not necessarily continious.
Example:"abc", "abg" are subsequences of "abcdefgh".
"""
from __future__ import print_function

try:
    xrange          # Python 2
except NameError:
    xrange = range  # Python 3

def lcs_dp(x, y):
    # find the length of strings
    m = len(x)
    n = len(y)

    # declaring the array for storing the dp values
    L = [[None] * (n + 1) for i in xrange(m + 1)]
    seq = []

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif x[i - 1] == y[ j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1
                seq.append(x[i -1])
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])
    # L[m][n] contains the length of LCS of X[0..n-1] & Y[0..m-1]
    return L[m][n], seq

if __name__=='__main__':
    x = 'AGGTAB'
    y = 'GXTXAYB'
    print(lcs_dp(x, y))
<EOF>
<BOF>
"""
author : Mayank Kumar Jha (mk9440)
"""
from __future__ import print_function

import time
import matplotlib.pyplot as plt
from random import randint
def find_max_sub_array(A,low,high):
    if low==high:
        return low,high,A[low]
    else :
        mid=(low+high)//2        
        left_low,left_high,left_sum=find_max_sub_array(A,low,mid)
        right_low,right_high,right_sum=find_max_sub_array(A,mid+1,high)
        cross_left,cross_right,cross_sum=find_max_cross_sum(A,low,mid,high)
        if left_sum>=right_sum and left_sum>=cross_sum:
            return left_low,left_high,left_sum
        elif right_sum>=left_sum and right_sum>=cross_sum :
            return right_low,right_high,right_sum
        else:
            return cross_left,cross_right,cross_sum

def find_max_cross_sum(A,low,mid,high):
    left_sum,max_left=-999999999,-1
    right_sum,max_right=-999999999,-1
    summ=0
    for i in range(mid,low-1,-1):
        summ+=A[i]
        if summ > left_sum:
            left_sum=summ
            max_left=i
    summ=0        
    for i in range(mid+1,high+1):
        summ+=A[i]
        if summ > right_sum:
            right_sum=summ
            max_right=i
    return max_left,max_right,(left_sum+right_sum)
    

if __name__=='__main__':
    inputs=[10,100,1000,10000,50000,100000,200000,300000,400000,500000]
    tim=[]
    for i in inputs:
        li=[randint(1,i) for j in range(i)]
        strt=time.time()
        (find_max_sub_array(li,0,len(li)-1))
        end=time.time()
        tim.append(end-strt)
    print("No of Inputs       Time Taken")    
    for i in range(len(inputs)):    
        print(inputs[i],'\t\t',tim[i])
    plt.plot(inputs,tim)
    plt.xlabel("Number of Inputs");plt.ylabel("Time taken in seconds ")
    plt.show()



        
<EOF>
<BOF>
#!/usr/bin/python
# encoding=utf8

"""
This program calculates the nth Fibonacci number in O(log(n)).
It's possible to calculate F(1000000) in less than a second.
"""
from __future__ import print_function
import sys


# returns F(n)
def fibonacci(n: int):  # noqa: E999 This syntax is Python 3 only
    if n < 0:
        raise ValueError("Negative arguments are not supported")
    return _fib(n)[0]


# returns (F(n), F(n-1))
def _fib(n: int):  # noqa: E999 This syntax is Python 3 only
    if n == 0:
        # (F(0), F(1))
        return (0, 1)
    else:
        # F(2n) = F(n)[2F(n+1)  F(n)]
        # F(2n+1) = F(n+1)^2+F(n)^2
        a, b = _fib(n // 2)
        c = a * (b * 2 - a)
        d = a * a + b * b
        if n % 2 == 0:
            return (c, d)
        else:
            return (d, c + d)


if __name__ == "__main__":
    args = sys.argv[1:]
    if len(args) != 1:
        print("Too few or too much parameters given.")
        exit(1)
    try:
        n = int(args[0])
    except ValueError:
        print("Could not convert data to an integer.")
        exit(1)
    print("F(%d) = %d" % (n, fibonacci(n)))
<EOF>
<BOF>
from __future__ import print_function

try:
	xrange		#Python 2
except NameError:
	xrange = range	#Python 3

'''
Algorithm for calculating the most cost-efficient sequence for converting one string into another.
The only allowed operations are
---Copy character with cost cC
---Replace character with cost cR
---Delete character with cost cD
---Insert character with cost cI
'''
def compute_transform_tables(X, Y, cC, cR, cD, cI):
	X = list(X)
	Y = list(Y)
	m = len(X)
	n = len(Y)

	costs = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
	ops = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]

	for i in xrange(1, m+1):
		costs[i][0] = i*cD
		ops[i][0] = 'D%c' % X[i-1]

	for i in xrange(1, n+1):
		costs[0][i] = i*cI
		ops[0][i] = 'I%c' % Y[i-1]

	for i in xrange(1, m+1):
		for j in xrange(1, n+1):
			if X[i-1] == Y[j-1]:
				costs[i][j] = costs[i-1][j-1] + cC
				ops[i][j] = 'C%c' % X[i-1]
			else:
				costs[i][j] = costs[i-1][j-1] + cR
				ops[i][j] = 'R%c' % X[i-1] + str(Y[j-1])

			if costs[i-1][j] + cD < costs[i][j]:
				costs[i][j] = costs[i-1][j] + cD
				ops[i][j] = 'D%c' % X[i-1]

			if costs[i][j-1] + cI < costs[i][j]:
				costs[i][j] = costs[i][j-1] + cI
				ops[i][j] = 'I%c' % Y[j-1]

	return costs, ops

def assemble_transformation(ops, i, j):
	if i == 0 and j == 0:
		seq = []
		return seq
	else:
		if ops[i][j][0] == 'C' or ops[i][j][0] == 'R':
			seq = assemble_transformation(ops, i-1, j-1)
			seq.append(ops[i][j])
			return seq
		elif ops[i][j][0] == 'D':
			seq = assemble_transformation(ops, i-1, j)
			seq.append(ops[i][j])
			return seq
		else:
			seq = assemble_transformation(ops, i, j-1)
			seq.append(ops[i][j])
			return seq

if __name__ == '__main__':
	_, operations = compute_transform_tables('Python', 'Algorithms', -1, 1, 2, 2)

	m = len(operations)
	n = len(operations[0])
	sequence = assemble_transformation(operations, m-1, n-1)
	
	file = open('min_cost.txt', 'w')

	string = list('Python')
	i = 0
	cost = 0
	for op in sequence:
		print(''.join(string))

		if op[0] == 'C':
			file.write('%-16s' % 'Copy %c' % op[1])
			file.write('\t\t\t' + ''.join(string))
			file.write('\r\n')
			
			cost -= 1
		elif op[0] == 'R':
			string[i] = op[2]

			file.write('%-16s' % ('Replace %c' % op[1] + ' with ' + str(op[2])))
			file.write('\t\t' + ''.join(string))
			file.write('\r\n')
			
			cost += 1
		elif op[0] == 'D':
			string.pop(i)

			file.write('%-16s' % 'Delete %c' % op[1])
			file.write('\t\t\t' + ''.join(string))
			file.write('\r\n')
			
			cost += 2
		else:
			string.insert(i, op[1])

			file.write('%-16s' % 'Insert %c' % op[1])
			file.write('\t\t\t' + ''.join(string))
			file.write('\r\n')
			
			cost += 2

		i += 1

	print(''.join(string))
	print('Cost: ', cost)
	
	file.write('\r\nMinimum cost: ' + str(cost))
	file.close()
<EOF>
<BOF>
"""
This is a Python implementation of the levenshtein distance.
Levenshtein distance is a string metric for measuring the
difference between two sequences.

For doctests run following command:
python -m doctest -v levenshtein-distance.py
or
python3 -m doctest -v levenshtein-distance.py

For manual testing run:
python levenshtein-distance.py
"""


def levenshtein_distance(first_word, second_word):
    """Implementation of the levenshtein distance in Python.
    :param first_word: the first word to measure the difference.
    :param second_word: the second word to measure the difference.
    :return: the levenshtein distance between the two words.
    Examples:
    >>> levenshtein_distance("planet", "planetary")
    3
    >>> levenshtein_distance("", "test")
    4
    >>> levenshtein_distance("book", "back")
    2
    >>> levenshtein_distance("book", "book")
    0
    >>> levenshtein_distance("test", "")
    4
    >>> levenshtein_distance("", "")
    0
    >>> levenshtein_distance("orchestration", "container")
    10
    """
    # The longer word should come first
    if len(first_word) < len(second_word):
        return levenshtein_distance(second_word, first_word)

    if len(second_word) == 0:
        return len(first_word)

    previous_row = range(len(second_word) + 1)

    for i, c1 in enumerate(first_word):

        current_row = [i + 1]

        for j, c2 in enumerate(second_word):

            # Calculate insertions, deletions and substitutions
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)

            # Get the minimum to append to the current row
            current_row.append(min(insertions, deletions, substitutions))

        # Store the previous row
        previous_row = current_row

    # Returns the last element (distance)
    return previous_row[-1]


if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    first_word = raw_input('Enter the first word:\n').strip()
    second_word = raw_input('Enter the second word:\n').strip()

    result = levenshtein_distance(first_word, second_word)
    print('Levenshtein distance between {} and {} is {}'.format(
        first_word, second_word, result))
<EOF>
<BOF>
def kmp(pattern, text):
    """
    The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text
    with complexity O(n + m)

    1) Preprocess pattern to identify any suffixes that are identical to prefixes

        This tells us where to continue from if we get a mismatch between a character in our pattern
        and the text.

    2) Step through the text one character at a time and compare it to a character in the pattern
        updating our location within the pattern if necessary

    """

    # 1) Construct the failure array
    failure = get_failure_array(pattern)

    # 2) Step through text searching for pattern
    i, j = 0, 0  # index into text, pattern
    while i < len(text):
        if pattern[j] == text[i]:
            if j == (len(pattern) - 1):
                return True
            j += 1

        # if this is a prefix in our pattern
        # just go back far enough to continue
        elif j > 0:
            j = failure[j - 1]
            continue
        i += 1
    return False


def get_failure_array(pattern):
    """
    Calculates the new index we should go to if we fail a comparison
    :param pattern:
    :return:
    """
    failure = [0]
    i = 0
    j = 1
    while j < len(pattern):
        if pattern[i] == pattern[j]:
            i += 1
        elif i > 0:
            i = failure[i-1]
            continue
        j += 1
        failure.append(i)
    return failure


if __name__ == '__main__':
    # Test 1)
    pattern = "abc1abc12"
    text1 = "alskfjaldsabc1abc1abc12k23adsfabcabc"
    text2 = "alskfjaldsk23adsfabcabc"
    assert kmp(pattern, text1) and not kmp(pattern, text2)

    # Test 2)
    pattern = "ABABX"
    text = "ABABZABABYABABX"
    assert kmp(pattern, text)

    # Test 3)
    pattern = "AAAB"
    text = "ABAAAAAB"
    assert kmp(pattern, text)

    # Test 4)
    pattern = "abcdabcy"
    text = "abcxabcdabxabcdabcdabcy"
    assert kmp(pattern, text)

    # Test 5)
    pattern = "aabaabaaa"
    assert get_failure_array(pattern) == [0, 1, 0, 1, 2, 3, 4, 5, 2]
<EOF>
<BOF>
def rabin_karp(pattern, text):
    """

    The Rabin-Karp Algorithm for finding a pattern within a piece of text
    with complexity O(nm), most efficient when it is used with multiple patterns
    as it is able to check if any of a set of patterns match a section of text in o(1) given the precomputed hashes.

    This will be the simple version which only assumes one pattern is being searched for but it's not hard to modify

    1) Calculate pattern hash

    2) Step through the text one character at a time passing a window with the same length as the pattern
        calculating the hash of the text within the window compare it with the hash of the pattern. Only testing
        equality if the hashes match

    """
    p_len = len(pattern)
    p_hash = hash(pattern)

    for i in range(0, len(text) - (p_len - 1)):

        # written like this t
        text_hash = hash(text[i:i + p_len])
        if text_hash == p_hash and \
                text[i:i + p_len] == pattern:
            return True
    return False


if __name__ == '__main__':
    # Test 1)
    pattern = "abc1abc12"
    text1 = "alskfjaldsabc1abc1abc12k23adsfabcabc"
    text2 = "alskfjaldsk23adsfabcabc"
    assert rabin_karp(pattern, text1) and not rabin_karp(pattern, text2)

    # Test 2)
    pattern = "ABABX"
    text = "ABABZABABYABABX"
    assert rabin_karp(pattern, text)

    # Test 3)
    pattern = "AAAB"
    text = "ABAAAAAB"
    assert rabin_karp(pattern, text)

    # Test 4)
    pattern = "abcdabcy"
    text = "abcxabcdabxabcdabcdabcy"
    assert rabin_karp(pattern, text)
<EOF>
<BOF>
# Newton's Method - https://en.wikipedia.org/wiki/Newton%27s_method

def newton(function,function1,startingInt): #function is the f(x) and function1 is the f'(x)
  x_n=startingInt
  while True:
      x_n1=x_n-function(x_n)/function1(x_n)
      if abs(x_n-x_n1) < 10**-5:
          return x_n1
      x_n=x_n1
      
def f(x):
    return (x**3) - (2 * x) -5

def f1(x):
    return 3 * (x**2) -2

if __name__ == "__main__":
    print(newton(f,f1,3))
<EOF>
<BOF>
import math

def intersection(function,x0,x1): #function is the f we want to find its root and x0 and x1 are two random starting points
    x_n = x0
    x_n1 = x1
    while True:
        x_n2 = x_n1-(function(x_n1)/((function(x_n1)-function(x_n))/(x_n1-x_n)))
        if abs(x_n2 - x_n1) < 10**-5:
            return x_n2
        x_n=x_n1
        x_n1=x_n2

def f(x):
    return math.pow(x , 3) - (2 * x) -5

if __name__ == "__main__":
    print(intersection(f,3,3.5))
<EOF>
<BOF>
# Implementing Newton Raphson method in Python
# Author: Haseeb

from sympy import diff
from decimal import Decimal

def NewtonRaphson(func, a):
    ''' Finds root from the point 'a' onwards by Newton-Raphson method '''
    while True:
        c = Decimal(a) - ( Decimal(eval(func)) / Decimal(eval(str(diff(func)))) )
        
        a = c

        # This number dictates the accuracy of the answer
        if  abs(eval(func)) < 10**-15:
            return  c
    

# Let's Execute
if __name__ == '__main__':
    # Find root of trigonometric function
    # Find value of pi
    print ('sin(x) = 0', NewtonRaphson('sin(x)', 2))
    
    # Find root of polynomial
    print ('x**2 - 5*x +2 = 0', NewtonRaphson('x**2 - 5*x +2', 0.4))
    
    # Find Square Root of 5
    print ('x**2 - 5 = 0', NewtonRaphson('x**2 - 5', 0.1))

    # Exponential Roots
    print ('exp(x) - 1 = 0', NewtonRaphson('exp(x) - 1', 0))
    
    
    

<EOF>
<BOF>
import math


def bisection(function, a, b):  # finds where the function becomes 0 in [a,b] using bolzano

    start = a
    end = b
    if function(a) == 0:  # one of the a or b is a root for the function
        return a
    elif function(b) == 0:
        return b
    elif function(a) * function(b) > 0:  # if none of these are root and they are both positive or negative,
        # then his algorithm can't find the root
        print("couldn't find root in [a,b]")
        return
    else:
        mid = (start + end) / 2
        while abs(start - mid) > 10**-7:  # until we achieve precise equals to 10^-7
            if function(mid) == 0:
                return mid
            elif function(mid) * function(start) < 0:
                end = mid
            else:
                start = mid
            mid = (start + end) / 2
        return mid


def f(x):
    return math.pow(x, 3) - 2*x - 5

if __name__ == "__main__":
    print(bisection(f, 1, 1000))
<EOF>
<BOF>
# lowerupper (LU) decomposition - https://en.wikipedia.org/wiki/LU_decomposition
import numpy

def LUDecompose (table):
    # Table that contains our data
    # Table has to be a square array so we need to check first
    rows,columns=numpy.shape(table)
    L=numpy.zeros((rows,columns))
    U=numpy.zeros((rows,columns))
    if rows!=columns:
        return []
    for i in range (columns):
        for j in range(i-1):
            sum=0
            for k in range (j-1):
                sum+=L[i][k]*U[k][j]
            L[i][j]=(table[i][j]-sum)/U[j][j]
        L[i][i]=1
        for j in range(i-1,columns):
            sum1=0
            for k in range(i-1):
                sum1+=L[i][k]*U[k][j]
            U[i][j]=table[i][j]-sum1
    return L,U

if __name__ == "__main__":
    matrix =numpy.array([[2,-2,1],
                         [0,1,2],
                         [5,3,1]])
    L,U = LUDecompose(matrix)
    print(L)
    print(U)
<EOF>
<BOF>
# client.py

import socket

HOST, PORT = '127.0.0.1', 1400

s = socket.socket(

            socket.AF_INET,     #           ADDRESS FAMILIES
                                #Name                   Purpose
                                #AF_UNIX, AF_LOCAL      Local communication
                                #AF_INET                IPv4 Internet protocols
                                #AF_INET6               IPv6 Internet protocols
                                #AF_APPLETALK           Appletalk
                                #AF_BLUETOOTH           Bluetooth


            socket.SOCK_STREAM  #           SOCKET TYPES
                                #Name           Way of Interaction
                                #SOCK_STREAM    TCP
                                #SOCK_DGRAM     UDP
)
s.connect((HOST, PORT))

s.send('Hello World'.encode('ascii'))#in UDP use sendto()
data = s.recv(1024)#in UDP use recvfrom()

s.close()#end the connection
print(repr(data.decode('ascii')))
<EOF>
<BOF>
# server.py

import socket

HOST, PORT = '127.0.0.1', 1400

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#refer to client.py
s.bind((HOST, PORT))
s.listen(1)#listen for 1 connection

conn, addr = s.accept()#start the actual data flow

print('connected to:', addr)

while 1:
    data = conn.recv(1024).decode('ascii')#receive 1024 bytes and decode using ascii
    if not data:
        break
    conn.send((data + ' [ addition by server ]').encode('ascii'))

conn.close()
<EOF>
<BOF>
"""
An AVL tree
"""
from __future__ import print_function


class Node:

    def __init__(self, label):
        self.label = label
        self._parent = None
        self._left = None
        self._right = None
        self.height = 0

    @property
    def right(self):
        return self._right

    @right.setter
    def right(self, node):
        if node is not None:
            node._parent = self
            self._right = node

    @property
    def left(self):
        return self._left

    @left.setter
    def left(self, node):
        if node is not None:
            node._parent = self
            self._left = node

    @property
    def parent(self):
        return self._parent

    @parent.setter
    def parent(self, node):
        if node is not None:
            self._parent = node
            self.height = self.parent.height + 1
        else:
            self.height = 0


class AVL:

    def __init__(self):
        self.root = None
        self.size = 0

    def insert(self, value):
        node = Node(value)

        if self.root is None:
            self.root = node
            self.root.height = 0
            self.size = 1
        else:
            # Same as Binary Tree
            dad_node = None
            curr_node = self.root

            while True:
                if curr_node is not None:

                    dad_node = curr_node

                    if node.label < curr_node.label:
                        curr_node = curr_node.left
                    else:
                        curr_node = curr_node.right
                else:
                    node.height = dad_node.height
                    dad_node.height += 1
                    if node.label < dad_node.label:
                        dad_node.left = node
                    else:
                        dad_node.right = node
                    self.rebalance(node)
                    self.size += 1
                    break

    def rebalance(self, node):
        n = node

        while n is not None:
            height_right = n.height
            height_left = n.height

            if n.right is not None:
                height_right = n.right.height

            if n.left is not None:
                height_left = n.left.height

            if abs(height_left - height_right) > 1:
                if height_left > height_right:
                    left_child = n.left
                    if left_child is not None:
                        h_right = (left_child.right.height
                                    if (left_child.right is not None) else 0)
                        h_left = (left_child.left.height
                                    if (left_child.left is not None) else 0)
                    if (h_left > h_right):
                        self.rotate_left(n)
                        break
                    else:
                        self.double_rotate_right(n)
                        break
                else:
                    right_child = n.right
                    if right_child is not None:
                        h_right = (right_child.right.height
                            if (right_child.right is not None) else 0)
                        h_left = (right_child.left.height
                            if (right_child.left is not None) else 0)
                    if (h_left > h_right):
                        self.double_rotate_left(n)
                        break
                    else:
                        self.rotate_right(n)
                        break
            n = n.parent

    def rotate_left(self, node):
        aux = node.parent.label
        node.parent.label = node.label
        node.parent.right = Node(aux)
        node.parent.right.height = node.parent.height + 1
        node.parent.left = node.right


    def rotate_right(self, node):
        aux = node.parent.label
        node.parent.label = node.label
        node.parent.left = Node(aux)
        node.parent.left.height = node.parent.height + 1
        node.parent.right = node.right

    def double_rotate_left(self, node):
        self.rotate_right(node.getRight().getRight())
        self.rotate_left(node)

    def double_rotate_right(self, node):
        self.rotate_left(node.getLeft().getLeft())
        self.rotate_right(node)

    def empty(self):
        if self.root is None:
            return True
        return False

    def preShow(self, curr_node):
        if curr_node is not None:
            self.preShow(curr_node.left)
            print(curr_node.label, end=" ")
            self.preShow(curr_node.right)

    def preorder(self, curr_node):
        if curr_node is not None:
            self.preShow(curr_node.left)
            self.preShow(curr_node.right)
            print(curr_node.label, end=" ")

    def getRoot(self):
        return self.root

t = AVL()
t.insert(1)
t.insert(2)
t.insert(3)
# t.preShow(t.root)
# print("\n")
# t.insert(4)
# t.insert(5)
# t.preShow(t.root)
# t.preorden(t.root)
<EOF>
<BOF>
arr = [10, 20, 30, 40]
arr[1] = 30 # set element 1 (20) of array to 30
print(arr)
<EOF>
<BOF>
from __future__ import absolute_import
from .union_find import UnionFind
import unittest


class TestUnionFind(unittest.TestCase):
    def test_init_with_valid_size(self):
        uf = UnionFind(5)
        self.assertEqual(uf.size, 5)

    def test_init_with_invalid_size(self):
        with self.assertRaises(ValueError):
            uf = UnionFind(0)

        with self.assertRaises(ValueError):
            uf = UnionFind(-5)

    def test_union_with_valid_values(self):
        uf = UnionFind(10)

        for i in range(11):
            for j in range(11):
                uf.union(i, j)

    def test_union_with_invalid_values(self):
        uf = UnionFind(10)

        with self.assertRaises(ValueError):
            uf.union(-1, 1)

        with self.assertRaises(ValueError):
            uf.union(11, 1)

    def test_same_set_with_valid_values(self):
        uf = UnionFind(10)

        for i in range(11):
            for j in range(11):
                if i == j:
                    self.assertTrue(uf.same_set(i, j))
                else:
                    self.assertFalse(uf.same_set(i, j))

        uf.union(1, 2)
        self.assertTrue(uf.same_set(1, 2))

        uf.union(3, 4)
        self.assertTrue(uf.same_set(3, 4))

        self.assertFalse(uf.same_set(1, 3))
        self.assertFalse(uf.same_set(1, 4))
        self.assertFalse(uf.same_set(2, 3))
        self.assertFalse(uf.same_set(2, 4))

        uf.union(1, 3)
        self.assertTrue(uf.same_set(1, 3))
        self.assertTrue(uf.same_set(1, 4))
        self.assertTrue(uf.same_set(2, 3))
        self.assertTrue(uf.same_set(2, 4))

        uf.union(4, 10)
        self.assertTrue(uf.same_set(1, 10))
        self.assertTrue(uf.same_set(2, 10))
        self.assertTrue(uf.same_set(3, 10))
        self.assertTrue(uf.same_set(4, 10))

    def test_same_set_with_invalid_values(self):
        uf = UnionFind(10)

        with self.assertRaises(ValueError):
            uf.same_set(-1, 1)

        with self.assertRaises(ValueError):
            uf.same_set(11, 0)


if __name__ == '__main__':
    unittest.main()
<EOF>
<BOF>
class UnionFind():
    """
    https://en.wikipedia.org/wiki/Disjoint-set_data_structure

    The union-find is a disjoint-set data structure

    You can merge two sets and tell if one set belongs to
    another one.

    It's used on the Kruskal Algorithm
    (https://en.wikipedia.org/wiki/Kruskal%27s_algorithm)

    The elements are in range [0, size]
    """
    def __init__(self, size):
        if size <= 0:
            raise ValueError("size should be greater than 0")

        self.size = size

        # The below plus 1 is because we are using elements
        # in range [0, size]. It makes more sense.

        # Every set begins with only itself
        self.root = [i for i in range(size+1)]

        # This is used for heuristic union by rank
        self.weight = [0 for i in range(size+1)]

    def union(self, u, v):
        """
        Union of the sets u and v.
        Complexity: log(n).
        Amortized complexity: < 5 (it's very fast).
        """

        self._validate_element_range(u, "u")
        self._validate_element_range(v, "v")

        if u == v:
            return

        # Using union by rank will guarantee the
        # log(n) complexity
        rootu = self._root(u)
        rootv = self._root(v)
        weight_u = self.weight[rootu]
        weight_v = self.weight[rootv]
        if weight_u >= weight_v:
            self.root[rootv] = rootu
            if weight_u == weight_v:
                self.weight[rootu] += 1
        else:
            self.root[rootu] = rootv

    def same_set(self, u, v):
        """
        Return true if the elements u and v belongs to
        the same set
        """

        self._validate_element_range(u, "u")
        self._validate_element_range(v, "v")

        return self._root(u) == self._root(v)

    def _root(self, u):
        """
        Get the element set root.
        This uses the heuristic path compression
        See wikipedia article for more details.
        """

        if u != self.root[u]:
            self.root[u] = self._root(self.root[u])

        return self.root[u]

    def _validate_element_range(self, u, element_name):
        """
        Raises ValueError if element is not in range
        """
        if u < 0 or u > self.size:
            msg = ("element {0} with value {1} "
                   "should be in range [0~{2}]")\
                  .format(element_name, u, self.size)
            raise ValueError(msg)
<EOF>
<BOF>
from __future__ import print_function

def printDist(dist, V):
	print("\nThe shortest path matrix using Floyd Warshall algorithm\n")
	for i in range(V):
		for j in range(V):
			if dist[i][j] != float('inf') :
				print(int(dist[i][j]),end = "\t")
			else:
				print("INF",end="\t")
		print()



def FloydWarshall(graph, V):
	dist=[[float('inf') for i in range(V)] for j in range(V)]
	
	for i in range(V):
		for j in range(V):
			dist[i][j] = graph[i][j]

	for k in range(V):
		for i in range(V):
			for j in range(V):
				if dist[i][k]!=float('inf') and dist[k][j]!=float('inf') and dist[i][k]+dist[k][j] < dist[i][j]:
					dist[i][j] = dist[i][k] + dist[k][j]

	printDist(dist, V)	

			

#MAIN
V = int(input("Enter number of vertices: "))
E = int(input("Enter number of edges: "))

graph = [[float('inf') for i in range(V)] for j in range(V)]

for i in range(V):
	graph[i][i] = 0.0

for i in range(E):
	print("\nEdge ",i+1)
	src = int(input("Enter source:"))
	dst = int(input("Enter destination:"))
	weight = float(input("Enter weight:"))
	graph[src][dst] = weight

FloydWarshall(graph, V)
<EOF>
<BOF>
"""
You are given a tree(a simple connected graph with no cycles). The tree has N
nodes numbered from 1 to N and is rooted at node 1.

Find the maximum number of edges you can remove from the tree to get a forest
such that each connected component of the forest contains an even number of
nodes.

Constraints
2 <= 2 <= 100

Note: The tree input will be such that it can always be decomposed into
components containing an even number of nodes.
"""
from __future__ import print_function
# pylint: disable=invalid-name
from collections import defaultdict


def dfs(start):
    """DFS traversal"""
    # pylint: disable=redefined-outer-name
    ret = 1
    visited[start] = True
    for v in tree.get(start):
        if v not in visited:
            ret += dfs(v)
    if ret % 2 == 0:
        cuts.append(start)
    return ret


def even_tree():
    """
    2 1
    3 1
    4 3
    5 2
    6 1
    7 2
    8 6
    9 8
    10 8
    On removing edges (1,3) and (1,6), we can get the desired result 2.
    """
    dfs(1)


if __name__ == '__main__':
    n, m = 10, 9
    tree = defaultdict(list)
    visited = {}
    cuts = []
    count = 0
    edges = [
        (2, 1),
        (3, 1),
        (4, 3),
        (5, 2),
        (6, 1),
        (7, 2),
        (8, 6),
        (9, 8),
        (10, 8),
    ]
    for u, v in edges:
        tree[u].append(v)
        tree[v].append(u)
    even_tree()
    print(len(cuts) - 1)
<EOF>
<BOF>
#!/usr/bin/python
# encoding=utf8

""" Author: OMKAR PATHAK """

from __future__ import print_function


class Graph():
    def __init__(self):
        self.vertex = {}

    # for printing the Graph vertexes
    def printGraph(self):
        for i in self.vertex.keys():
            print(i,' -> ', ' -> '.join([str(j) for j in self.vertex[i]]))

    # for adding the edge beween two vertexes
    def addEdge(self, fromVertex, toVertex):
        # check if vertex is already present,
        if fromVertex in self.vertex.keys():
            self.vertex[fromVertex].append(toVertex)
        else:
            # else make a new vertex
            self.vertex[fromVertex] = [toVertex]

    def BFS(self, startVertex):
        # Take a list for stoting already visited vertexes
        visited = [False] * len(self.vertex)

        # create a list to store all the vertexes for BFS
        queue = []

        # mark the source node as visited and enqueue it
        visited[startVertex] = True
        queue.append(startVertex)

        while queue:
            startVertex = queue.pop(0)
            print(startVertex, end = ' ')

            # mark all adjacent nodes as visited and print them
            for i in self.vertex[startVertex]:
                if visited[i] == False:
                    queue.append(i)
                    visited[i] = True

if __name__ == '__main__':
    g = Graph()
    g.addEdge(0, 1)
    g.addEdge(0, 2)
    g.addEdge(1, 2)
    g.addEdge(2, 0)
    g.addEdge(2, 3)
    g.addEdge(3, 3)

    g.printGraph()
    print('BFS:')
    g.BFS(2)

    # OUTPUT:
    # 0->1->2
    # 1->2
    # 2->0->3
    # 3->3
    # BFS:
    # 2031
<EOF>
<BOF>
from __future__ import print_function


class Graph:
    def __init__(self, vertex):
        self.vertex = vertex
        self.graph = [[0] for i in range(vertex)]

    def add_edge(self, u, v):
        self.graph[u - 1].append(v - 1)

    def show(self):
        for i in range(self.vertex):
            print('%d: '% (i + 1), end=' ')
            for j in self.graph[i]:
                print('%d-> '% (j + 1), end=' ')
            print(' ')



g = Graph(100)

g.add_edge(1,3)
g.add_edge(2,3)
g.add_edge(3,4)
g.add_edge(3,5)
g.add_edge(4,5)


g.show()

<EOF>
<BOF>
#!/usr/bin/python
# encoding=utf8

from __future__ import print_function
# Author: OMKAR PATHAK

# We can use Python's dictionary for constructing the graph

class AdjacencyList(object):
    def __init__(self):
        self.List = {}

    def addEdge(self, fromVertex, toVertex):
        # check if vertex is already present
        if fromVertex in self.List.keys():
            self.List[fromVertex].append(toVertex)
        else:
            self.List[fromVertex] = [toVertex]

    def printList(self):
        for i  in self.List:
            print((i,'->',' -> '.join([str(j) for j in self.List[i]])))

if __name__ == '__main__':
    al = AdjacencyList()
    al.addEdge(0, 1)
    al.addEdge(0, 4)
    al.addEdge(4, 1)
    al.addEdge(4, 3)
    al.addEdge(1, 0)
    al.addEdge(1, 4)
    al.addEdge(1, 3)
    al.addEdge(1, 2)
    al.addEdge(2, 3)
    al.addEdge(3, 4)

    al.printList()

    # OUTPUT:
    # 0->1->4
    # 1->0->4->3->2
    # 2->3
    # 3->4
    # 4->1->3
<EOF>
<BOF>
from __future__ import print_function

def printDist(dist, V):
	print("\nVertex Distance")
	for i in range(V):
		if dist[i] != float('inf') :
			print(i,"\t",int(dist[i]),end = "\t")
		else:
			print(i,"\t","INF",end="\t")
		print()

def BellmanFord(graph, V, E, src):
	mdist=[float('inf') for i in range(V)]
	mdist[src] = 0.0
	
	for i in range(V-1):
		for j in range(V):
			u = graph[j]["src"]
			v = graph[j]["dst"]
			w = graph[j]["weight"]

			if mdist[u] != float('inf') and mdist[u] + w < mdist[v]:
				mdist[v] = mdist[u] + w 
	for j in range(V):
			u = graph[j]["src"]
			v = graph[j]["dst"]
			w = graph[j]["weight"]

			if mdist[u] != float('inf') and mdist[u] + w < mdist[v]:
				print("Negative cycle found. Solution not possible.")
				return
	
	printDist(mdist, V)	

			

#MAIN
V = int(input("Enter number of vertices: "))
E = int(input("Enter number of edges: "))

graph = [dict() for j in range(E)]

for i in range(V):
	graph[i][i] = 0.0

for i in range(E):
	print("\nEdge ",i+1)
	src = int(input("Enter source:"))
	dst = int(input("Enter destination:"))
	weight = float(input("Enter weight:"))
	graph[i] = {"src": src,"dst": dst, "weight": weight}
	
gsrc = int(input("\nEnter shortest path source:"))
BellmanFord(graph, V, E, gsrc)
<EOF>
<BOF>
from __future__ import print_function


class Graph:

    def __init__(self, vertex):
        self.vertex = vertex
        self.graph = [[0] * vertex for i in range(vertex) ]

    def add_edge(self, u, v):
        self.graph[u - 1][v - 1] = 1
        self.graph[v - 1][u - 1] = 1

    def show(self):

        for i in self.graph:
            for j in i:
                print(j, end=' ')
            print(' ')




g = Graph(100)

g.add_edge(1,4)
g.add_edge(4,2)
g.add_edge(4,5)
g.add_edge(2,5)
g.add_edge(5,3)
g.show()

<EOF>
<BOF>
from __future__ import print_function

def printDist(dist, V):
	print("\nVertex Distance")
	for i in range(V):
		if dist[i] != float('inf') :
			print(i,"\t",int(dist[i]),end = "\t")
		else:
			print(i,"\t","INF",end="\t")
		print()

def minDist(mdist, vset, V):
	minVal = float('inf')
	minInd = -1
	for i in range(V):
		if (not vset[i]) and mdist[i] < minVal :
			minInd = i
			minVal = mdist[i]
	return minInd

def Dijkstra(graph, V, src):
	mdist=[float('inf') for i in range(V)]
	vset = [False for i in range(V)]
	mdist[src] = 0.0
	
	for i in range(V-1):
		u = minDist(mdist, vset, V)
		vset[u] = True
		
		for v in range(V):
			if (not vset[v]) and graph[u][v]!=float('inf') and mdist[u] + graph[u][v] < mdist[v]:
				mdist[v] = mdist[u] + graph[u][v] 

	

	printDist(mdist, V)	

			

#MAIN
V = int(input("Enter number of vertices: "))
E = int(input("Enter number of edges: "))

graph = [[float('inf') for i in range(V)] for j in range(V)]

for i in range(V):
	graph[i][i] = 0.0

for i in range(E):
	print("\nEdge ",i+1)
	src = int(input("Enter source:"))
	dst = int(input("Enter destination:"))
	weight = float(input("Enter weight:"))
	graph[src][dst] = weight

gsrc = int(input("\nEnter shortest path source:"))
Dijkstra(graph, V, gsrc)
<EOF>
<BOF>
#!/usr/bin/python
# encoding=utf8

""" Author: OMKAR PATHAK """
from __future__ import print_function


class Graph():
    def __init__(self):
        self.vertex = {}

    # for printing the Graph vertexes
    def printGraph(self):
        print(self.vertex)
        for i in self.vertex.keys():
            print(i,' -> ', ' -> '.join([str(j) for j in self.vertex[i]]))

    # for adding the edge beween two vertexes
    def addEdge(self, fromVertex, toVertex):
        # check if vertex is already present,
        if fromVertex in self.vertex.keys():
            self.vertex[fromVertex].append(toVertex)
        else:
            # else make a new vertex
            self.vertex[fromVertex] = [toVertex]

    def DFS(self):
        # visited array for storing already visited nodes
        visited = [False] * len(self.vertex)

        # call the recursive helper function
        for i in range(len(self.vertex)):
            if visited[i] == False:
                self.DFSRec(i, visited)

    def DFSRec(self, startVertex, visited):
        # mark start vertex as visited
        visited[startVertex] = True

        print(startVertex, end = ' ')

        # Recur for all the vertexes that are adjacent to this node
        for i in self.vertex.keys():
            if visited[i] == False:
                self.DFSRec(i, visited)

if __name__ == '__main__':
    g = Graph()
    g.addEdge(0, 1)
    g.addEdge(0, 2)
    g.addEdge(1, 2)
    g.addEdge(2, 0)
    g.addEdge(2, 3)
    g.addEdge(3, 3)

    g.printGraph()
    print('DFS:')
    g.DFS()

    # OUTPUT:
    # 0->1->2
    # 1->2
    # 2->0->3
    # 3->3
    # DFS:
    #012 3
<EOF>
<BOF>
# Title: Dijkstra's Algorithm for finding single source shortest path from scratch
# Author: Shubham Malik
# References: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm

from __future__ import print_function
import math
import sys
# For storing the vertex set to retreive node with the lowest distance


class PriorityQueue:
    # Based on Min Heap
    def __init__(self):
        self.cur_size = 0
        self.array = []
        self.pos = {}   # To store the pos of node in array

    def isEmpty(self):
        return self.cur_size == 0

    def min_heapify(self, idx):
        lc = self.left(idx)
        rc = self.right(idx)
        if lc < self.cur_size and self.array(lc)[0] < self.array(idx)[0]:
            smallest = lc
        else:
            smallest = idx
        if rc < self.cur_size and self.array(rc)[0] < self.array(smallest)[0]:
            smallest = rc
        if smallest != idx:
            self.swap(idx, smallest)
            self.min_heapify(smallest)

    def insert(self, tup):
        # Inserts a node into the Priority Queue
        self.pos[tup[1]] = self.cur_size
        self.cur_size += 1
        self.array.append((sys.maxsize, tup[1]))
        self.decrease_key((sys.maxsize, tup[1]), tup[0])

    def extract_min(self):
        # Removes and returns the min element at top of priority queue
        min_node = self.array[0][1]
        self.array[0] = self.array[self.cur_size - 1]
        self.cur_size -= 1
        self.min_heapify(1)
        del self.pos[min_node]
        return min_node

    def left(self, i):
        # returns the index of left child
        return 2 * i + 1

    def right(self, i):
        # returns the index of right child
        return 2 * i + 2

    def par(self, i):
        # returns the index of parent
        return math.floor(i / 2)

    def swap(self, i, j):
        # swaps array elements at indices i and j
        # update the pos{}
        self.pos[self.array[i][1]] = j
        self.pos[self.array[j][1]] = i
        temp = self.array[i]
        self.array[i] = self.array[j]
        self.array[j] = temp

    def decrease_key(self, tup, new_d):
        idx = self.pos[tup[1]]
        # assuming the new_d is atmost old_d
        self.array[idx] = (new_d, tup[1])
        while idx > 0 and self.array[self.par(idx)][0] > self.array[idx][0]:
            self.swap(idx, self.par(idx))
            idx = self.par(idx)


class Graph:
    def __init__(self, num):
        self.adjList = {}   # To store graph: u -> (v,w)
        self.num_nodes = num    # Number of nodes in graph
        # To store the distance from source vertex
        self.dist = [0] * self.num_nodes
        self.par = [-1] * self.num_nodes  # To store the path

    def add_edge(self, u, v, w):
        #  Edge going from node u to v and v to u with weight w
        # u (w)-> v, v (w) -> u
        # Check if u already in graph
        if u in self.adjList.keys():
            self.adjList[u].append((v, w))
        else:
            self.adjList[u] = [(v, w)]

        # Assuming undirected graph
        if v in self.adjList.keys():
            self.adjList[v].append((u, w))
        else:
            self.adjList[v] = [(u, w)]

    def show_graph(self):
        # u -> v(w)
        for u in self.adjList:
            print(u, '->', ' -> '.join(str("{}({})".format(v, w))
                                       for v, w in self.adjList[u]))

    def dijkstra(self, src):
        # Flush old junk values in par[]
        self.par = [-1] * self.num_nodes
        # src is the source node
        self.dist[src] = 0
        Q = PriorityQueue()
        Q.insert((0, src))  # (dist from src, node)
        for u in self.adjList.keys():
            if u != src:
                self.dist[u] = sys.maxsize  # Infinity
                self.par[u] = -1

        while not Q.isEmpty():
            u = Q.extract_min()  # Returns node with the min dist from source
            # Update the distance of all the neighbours of u and
            # if their prev dist was INFINITY then push them in Q
            for v, w in self.adjList[u]:
                new_dist = self.dist[u] + w
                if self.dist[v] > new_dist:
                    if self.dist[v] == sys.maxsize:
                        Q.insert((new_dist, v))
                    else:
                        Q.decrease_key((self.dist[v], v), new_dist)
                    self.dist[v] = new_dist
                    self.par[v] = u

        # Show the shortest distances from src
        self.show_distances(src)

    def show_distances(self, src):
        print("Distance from node: {}".format(src))
        for u in range(self.num_nodes):
            print('Node {} has distance: {}'.format(u, self.dist[u]))

    def show_path(self, src, dest):
        # To show the shortest path from src to dest
        # WARNING: Use it *after* calling dijkstra
        path = []
        cost = 0
        temp = dest
        # Backtracking from dest to src
        while self.par[temp] != -1:
            path.append(temp)
            if temp != src:
                for v, w in self.adjList[temp]:
                    if v == self.par[temp]:
                        cost += w
                        break
            temp = self.par[temp]
        path.append(src)
        path.reverse()

        print('----Path to reach {} from {}----'.format(dest, src))
        for u in path:
            print('{}'.format(u), end=' ')
            if u != dest:
                print('-> ', end='')

        print('\nTotal cost of path: ', cost)


if __name__ == '__main__':
    graph = Graph(9)
    graph.add_edge(0, 1, 4)
    graph.add_edge(0, 7, 8)
    graph.add_edge(1, 2, 8)
    graph.add_edge(1, 7, 11)
    graph.add_edge(2, 3, 7)
    graph.add_edge(2, 8, 2)
    graph.add_edge(2, 5, 4)
    graph.add_edge(3, 4, 9)
    graph.add_edge(3, 5, 14)
    graph.add_edge(4, 5, 10)
    graph.add_edge(5, 6, 2)
    graph.add_edge(6, 7, 1)
    graph.add_edge(6, 8, 6)
    graph.add_edge(7, 8, 7)
    graph.show_graph()
    graph.dijkstra(0)
    graph.show_path(0, 4)

# OUTPUT
# 0 -> 1(4) -> 7(8)
# 1 -> 0(4) -> 2(8) -> 7(11)
# 7 -> 0(8) -> 1(11) -> 6(1) -> 8(7)
# 2 -> 1(8) -> 3(7) -> 8(2) -> 5(4)
# 3 -> 2(7) -> 4(9) -> 5(14)
# 8 -> 2(2) -> 6(6) -> 7(7)
# 5 -> 2(4) -> 3(14) -> 4(10) -> 6(2)
# 4 -> 3(9) -> 5(10)
# 6 -> 5(2) -> 7(1) -> 8(6)
# Distance from node: 0
# Node 0 has distance: 0
# Node 1 has distance: 4
# Node 2 has distance: 12
# Node 3 has distance: 19
# Node 4 has distance: 21
# Node 5 has distance: 11
# Node 6 has distance: 9
# Node 7 has distance: 8
# Node 8 has distance: 14
# ----Path to reach 4 from 0----
# 0 -> 7 -> 6 -> 5 -> 4
# Total cost of path:  21
<EOF>
<BOF>
from __future__ import print_function


class Node:  # create a Node
    def __init__(self, data):
        self.data = data  # given data
        self.next = None  # given next to None


class Linked_List:
    def __init__(self):
        self.Head = None    # Initialize Head to None
        
    def insert_tail(self, data):
        if(self.Head is None): self.insert_head(data)    #If this is first node, call insert_head
        else:
            temp = self.Head
            while(temp.next != None):    #traverse to last node
                temp = temp.next
            temp.next = Node(data)    #create node & link to tail

    def insert_head(self, data):
        newNod = Node(data)    # create a new node
        if self.Head != None:
            newNod.next = self.Head     # link newNode to head
        self.Head = newNod    # make NewNode as Head

    def printList(self):  # print every node data
        tamp = self.Head
        while tamp is not None:
            print(tamp.data)
            tamp = tamp.next

    def delete_head(self):  # delete from head
        temp = self.Head
        if self.Head != None:
            self.Head = self.Head.next
            temp.next = None
        return temp
        
    def delete_tail(self):  # delete from tail
        tamp = self.Head
        if self.Head != None:
            if(self.Head.next is None):    # if Head is the only Node in the Linked List
                self.Head = None
            else:
                while tamp.next.next is not None:  # find the 2nd last element
                    tamp = tamp.next
                tamp.next, tamp = None, tamp.next    #(2nd last element).next = None and tamp = last element 
        return tamp

    def isEmpty(self):
        return self.Head is None  # Return if Head is none

    def reverse(self):
        prev = None
        current = self.Head

        while current:
            # Store the current node's next node.
            next_node = current.next
            # Make the current node's next point backwards
            current.next = prev
            # Make the previous node be the current node
            prev = current
            # Make the current node the next node (to progress iteration)
            current = next_node
        # Return prev in order to put the head at the end
        self.Head = prev

def main():
    A = Linked_List()
    print("Inserting 10 at Head")
    A.insert_head(10)
    print("Inserting 0 at Head")
    A.insert_head(0)
    print("\nPrint List : ")
    A.printList()
    print("\nInserting 100 at Tail")
    A.insert_tail(100)
    print("Inserting 1000 at Tail")
    A.insert_tail(1000)
    print("\nPrint List : ")
    A.printList()
    print("\nDelete Head")
    A.delete_head()
    print("Delete Tail")
    A.delete_tail()
    print("\nPrint List : ")
    A.printList()
    print("\nReverse Linked List")
    A.reverse()
    print("\nPrint List : ")
    A.printList()
    
if __name__ == '__main__':
	main()
<EOF>
<BOF>
'''
- A linked list is similar to an array, it holds values. However, links in a linked list do not have indexes.
- This is an example of a double ended, doubly linked list.
- Each link references the next link and the previous one.
- A Doubly Linked List (DLL) contains an extra pointer, typically called previous pointer, together with next pointer and data which are there in singly linked list.
 - Advantages over SLL - IT can be traversed in both forward and backward direction.,Delete operation is more efficent'''
from __future__ import print_function


class LinkedList:           #making main class named linked list
    def __init__(self):
        self.head = None
        self.tail = None
        
    def insertHead(self, x):
        newLink = Link(x)                            #Create a new link with a value attached to it
        if(self.isEmpty() == True):                  #Set the first element added to be the tail
            self.tail = newLink
        else:
            self.head.previous = newLink             # newLink <-- currenthead(head)
        newLink.next = self.head                     # newLink <--> currenthead(head)
        self.head = newLink                          # newLink(head) <--> oldhead
    
    def deleteHead(self):
        temp = self.head
        self.head = self.head.next                   # oldHead <--> 2ndElement(head) 
        self.head.previous = None                    # oldHead --> 2ndElement(head) nothing pointing at it so the old head will be removed
        if(self.head is None):
            self.tail = None                         #if empty linked list
        return temp
    
    def insertTail(self, x):
        newLink = Link(x)
        newLink.next = None                         # currentTail(tail)    newLink -->
        self.tail.next = newLink                    # currentTail(tail) --> newLink -->
        newLink.previous = self.tail                #currentTail(tail) <--> newLink -->
        self.tail = newLink                         # oldTail <--> newLink(tail) -->
    
    def deleteTail(self):
        temp = self.tail
        self.tail = self.tail.previous              # 2ndLast(tail) <--> oldTail --> None
        self.tail.next = None                       # 2ndlast(tail) --> None
        return temp
    
    def delete(self, x):
        current = self.head
        
        while(current.value != x):                  # Find the position to delete
            current = current.next
            
        if(current == self.head):
            self.deleteHead()
            
        elif(current == self.tail):
            self.deleteTail()
            
        else: #Before: 1 <--> 2(current) <--> 3
            current.previous.next = current.next # 1 --> 3
            current.next.previous = current.previous # 1 <--> 3
    
    def isEmpty(self):                               #Will return True if the list is empty
        return(self.head is None)
        
    def display(self):                                #Prints contents of the list
        current = self.head
        while(current != None):
            current.displayLink()
            current = current.next  
        print()

class Link:
    next = None                                       #This points to the link in front of the new link
    previous = None                                   #This points to the link behind the new link
    def __init__(self, x):
        self.value = x
    def displayLink(self):
        print("{}".format(self.value), end=" ")
<EOF>
<BOF>
class Node:
    def __init__(self, item, next):
        self.item = item
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None

    def add(self, item):
        self.head = Node(item, self.head)

    def remove(self):
        if self.is_empty():
            return None
        else:
            item = self.head.item
            self.head = self.head.next
            return item

    def is_empty(self):
        return self.head is None
<EOF>
<BOF>
#!/usr/bin/env python3
from number_theory.prime_numbers import next_prime


class HashTable:
    """
        Basic Hash Table example with open addressing and linear probing
    """

    def __init__(self, size_table, charge_factor=None, lim_charge=None):
        self.size_table = size_table
        self.values = [None] * self.size_table
        self.lim_charge = 0.75 if lim_charge is None else lim_charge
        self.charge_factor = 1 if charge_factor is None else charge_factor
        self.__aux_list = []
        self._keys = {}

    def keys(self):
        return self._keys

    def balanced_factor(self):
        return sum([1 for slot in self.values
                    if slot is not None]) / (self.size_table * self.charge_factor)

    def hash_function(self, key):
        return key % self.size_table

    def _step_by_step(self, step_ord):

        print("step {0}".format(step_ord))
        print([i for i in range(len(self.values))])
        print(self.values)

    def bulk_insert(self, values):
        i = 1
        self.__aux_list = values
        for value in values:
            self.insert_data(value)
            self._step_by_step(i)
            i += 1

    def _set_value(self, key, data):
        self.values[key] = data
        self._keys[key] = data

    def _colision_resolution(self, key, data=None):
        new_key = self.hash_function(key + 1)

        while self.values[new_key] is not None \
                and self.values[new_key] != key:

            if self.values.count(None) > 0:
                new_key = self.hash_function(new_key + 1)
            else:
                new_key = None
                break

        return new_key

    def rehashing(self):
        survivor_values = [value for value in self.values if value is not None]
        self.size_table = next_prime(self.size_table, factor=2)
        self._keys.clear()
        self.values = [None] * self.size_table #hell's pointers D: don't DRY ;/
        map(self.insert_data, survivor_values)

    def insert_data(self, data):
        key = self.hash_function(data)

        if self.values[key] is None:
            self._set_value(key, data)

        elif self.values[key] == data:
            pass

        else:
            colision_resolution = self._colision_resolution(key, data)
            if colision_resolution is not None:
                self._set_value(colision_resolution, data)
            else:
                self.rehashing()
                self.insert_data(data)


<EOF>
<BOF>
from .hash_table import HashTable
from collections import deque


class HashTableWithLinkedList(HashTable):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def _set_value(self, key, data):
        self.values[key] = deque([]) if self.values[key] is None else self.values[key]  
        self.values[key].appendleft(data)
        self._keys[key] = self.values[key]

    def balanced_factor(self):
        return sum([self.charge_factor - len(slot) for slot in self.values])\
               / self.size_table * self.charge_factor
    
    def _colision_resolution(self, key, data=None):
        if not (len(self.values[key]) == self.charge_factor
                and self.values.count(None) == 0):
            return key
        return super()._colision_resolution(key, data)


<EOF>
<BOF>
from .hash_table import HashTable

class QuadraticProbing(HashTable):

    def __init__(self):
        super(self.__class__, self).__init__()
<EOF>
<BOF>
#!/usr/bin/env python3

from .hash_table import HashTable


class QuadraticProbing(HashTable):
    """
        Basic Hash Table example with open addressing using Quadratic Probing 
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def _colision_resolution(self, key, data=None):
        i = 1
        new_key = self.hash_function(key + i*i)

        while self.values[new_key] is not None \
                and self.values[new_key] != key:
            i += 1
            new_key = self.hash_function(key + i*i) if not \
                self.balanced_factor() >= self.lim_charge else None

            if new_key is None:
                break

        return new_key
<EOF>
<BOF>
#!/usr/bin/env python3

from .hash_table import HashTable
from number_theory.prime_numbers import next_prime, check_prime


class DoubleHash(HashTable):
    """
        Hash Table example with open addressing and Double Hash
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def __hash_function_2(self, value, data):

        next_prime_gt = next_prime(value % self.size_table) \
            if not check_prime(value % self.size_table) else value % self.size_table  #gt = bigger than
        return next_prime_gt - (data % next_prime_gt)

    def __hash_double_function(self, key, data, increment):
        return (increment * self.__hash_function_2(key, data)) % self.size_table

    def _colision_resolution(self, key, data=None):
        i = 1
        new_key = self.hash_function(data)

        while self.values[new_key] is not None and self.values[new_key] != key:
            new_key = self.__hash_double_function(key, data, i) if \
                self.balanced_factor() >= self.lim_charge else None
            if new_key is None: break 
            else: i += 1

        return new_key
<EOF>
<BOF>
#!/usr/bin/env python3
"""
    module to operations with prime numbers
"""


def check_prime(number):
        """
            it's not the best solution
        """
        special_non_primes = [0,1,2]
        if number in special_non_primes[:2]:
            return 2
        elif number == special_non_primes[-1]:
            return 3
            
        return all([number % i for i in range(2, number)])


def next_prime(value, factor=1, **kwargs):
    value = factor * value
    first_value_val = value
    
    while not check_prime(value):
        value += 1 if not ("desc" in kwargs.keys() and kwargs["desc"] is True) else -1
    
    if value == first_value_val:
        return next_prime(value + 1, **kwargs)
    return value
<EOF>
<BOF>
"""
A Trie/Prefix Tree is a kind of search tree used to provide quick lookup
of words/patterns in a set of words. A basic Trie however has O(n^2) space complexity
making it impractical in practice. It however provides O(max(search_string, length of longest word)) lookup
time making it an optimal approach when space is not an issue.

"""


class TrieNode:
    def __init__(self):
        self.nodes = dict()  # Mapping from char to TrieNode
        self.is_leaf = False

    def insert_many(self, words: [str]):  # noqa: E999 This syntax is Python 3 only
        """
        Inserts a list of words into the Trie
        :param words: list of string words
        :return: None
        """
        for word in words:
            self.insert(word)

    def insert(self, word: str):  # noqa: E999 This syntax is Python 3 only
        """
        Inserts a word into the Trie
        :param word: word to be inserted
        :return: None
        """
        curr = self
        for char in word:
            if char not in curr.nodes:
                curr.nodes[char] = TrieNode()
            curr = curr.nodes[char]
        curr.is_leaf = True

    def find(self, word: str) -> bool:  # noqa: E999 This syntax is Python 3 only
        """
        Tries to find word in a Trie
        :param word: word to look for
        :return: Returns True if word is found, False otherwise
        """
        curr = self
        for char in word:
            if char not in curr.nodes:
                return False
            curr = curr.nodes[char]
        return curr.is_leaf


def print_words(node: TrieNode, word: str):  # noqa: E999 This syntax is Python 3 only
    """
    Prints all the words in a Trie
    :param node: root node of Trie
    :param word: Word variable should be empty at start
    :return: None
    """
    if node.is_leaf:
        print(word, end=' ')

    for key, value in node.nodes.items():
        print_words(value, word + key)


def test():
    words = ['banana', 'bananas', 'bandana', 'band', 'apple', 'all', 'beast']
    root = TrieNode()
    root.insert_many(words)
    # print_words(root, '')
    assert root.find('banana')
    assert not root.find('bandanas')
    assert not root.find('apps')
    assert root.find('apple')

test()
<EOF>
<BOF>
#!/usr/bin/python

from __future__ import print_function, division

try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3

class Heap:
	def __init__(self):
	    self.h = []
	    self.currsize = 0

	def leftChild(self,i):
		if 2*i+1 < self.currsize:
			return 2*i+1
		return None

	def rightChild(self,i):
		if 2*i+2 < self.currsize:
			return 2*i+2
		return None

	def maxHeapify(self,node):
		if node < self.currsize:
			m = node
			lc = self.leftChild(node)
			rc = self.rightChild(node)
			if lc is not None and self.h[lc] > self.h[m]:
				m = lc
			if rc is not None and self.h[rc] > self.h[m]:
				m = rc
			if m!=node:
				temp = self.h[node]
				self.h[node] = self.h[m]
				self.h[m] = temp
				self.maxHeapify(m)

	def buildHeap(self,a):
		self.currsize = len(a)
		self.h = list(a)
		for i in range(self.currsize//2,-1,-1):
			self.maxHeapify(i)

	def getMax(self):
		if self.currsize >= 1:
			me = self.h[0]
			temp = self.h[0]
			self.h[0] = self.h[self.currsize-1]
			self.h[self.currsize-1] = temp
			self.currsize -= 1
			self.maxHeapify(0)
			return me
		return None

	def heapSort(self):
		size = self.currsize
		while self.currsize-1 >= 0:
			temp = self.h[0]
			self.h[0] = self.h[self.currsize-1]
			self.h[self.currsize-1] = temp
			self.currsize -= 1
			self.maxHeapify(0)
		self.currsize = size

	def insert(self,data):
		self.h.append(data)
		curr = self.currsize
		self.currsize+=1
		while self.h[curr] > self.h[curr/2]:
			temp = self.h[curr/2]
			self.h[curr/2] = self.h[curr]
			self.h[curr] = temp
			curr = curr/2

	def display(self):
		print(self.h)

def main():
	l = list(map(int, raw_input().split()))
	h = Heap()
	h.buildHeap(l)
	h.heapSort()
	h.display()

if __name__=='__main__':
	main()


<EOF>
<BOF>
"""Queue represented by a pseudo stack (represented by a list with pop and append)"""
class Queue():
    def __init__(self):
        self.stack = []
        self.length = 0

    def __str__(self):
        printed = '<' + str(self.stack)[1:-1] + '>'
        return printed

    """Enqueues {@code item}
    @param item
        item to enqueue"""
    def put(self, item):
        self.stack.append(item)
        self.length = self.length + 1

    """Dequeues {@code item}
    @requirement: |self.length| > 0
    @return dequeued
        item that was dequeued"""
    def get(self):
        self.rotate(1)
        dequeued = self.stack[self.length-1]
        self.stack = self.stack[:-1]
        self.rotate(self.length-1)
        self.length = self.length -1
        return dequeued

    """Rotates the queue {@code rotation} times
    @param rotation
        number of times to rotate queue"""
    def rotate(self, rotation):
        for i in range(rotation):
            temp = self.stack[0]
            self.stack = self.stack[1:]
            self.put(temp)
            self.length = self.length - 1

    """Reports item at the front of self
    @return item at front of self.stack"""
    def front(self):
        front = self.get()
        self.put(front)
        self.rotate(self.length-1)
        return front

    """Returns the length of this.stack"""
    def size(self):
        return self.length
<EOF>
<BOF>
"""Queue represented by a python list"""
class Queue():
    def __init__(self):
        self.entries = []
        self.length = 0
        self.front=0

    def __str__(self):
        printed = '<' + str(self.entries)[1:-1] + '>'
        return printed

    """Enqueues {@code item}
    @param item
        item to enqueue"""
    def put(self, item):
        self.entries.append(item)
        self.length = self.length + 1


    """Dequeues {@code item}
    @requirement: |self.length| > 0
    @return dequeued
        item that was dequeued"""
    def get(self):
        self.length = self.length - 1
        dequeued = self.entries[self.front]
        self.front-=1
        self.entries = self.entries[self.front:]
        return dequeued

    """Rotates the queue {@code rotation} times
    @param rotation
        number of times to rotate queue"""
    def rotate(self, rotation):
        for i in range(rotation):
            self.put(self.get())

    """Enqueues {@code item}
    @return item at front of self.entries"""
    def front(self):
        return self.entries[0]

    """Returns the length of this.entries"""
    def size(self):
        return self.length
<EOF>
<BOF>
from __future__ import print_function
# Python code to demonstrate working of 
# extend(), extendleft(), rotate(), reverse()
 
# importing "collections" for deque operations
import collections
 
# initializing deque
de = collections.deque([1, 2, 3,])
 
# using extend() to add numbers to right end 
# adds 4,5,6 to right end
de.extend([4,5,6])
 
# printing modified deque
print ("The deque after extending deque at end is : ")
print (de)
 
# using extendleft() to add numbers to left end 
# adds 7,8,9 to right end
de.extendleft([7,8,9])
 
# printing modified deque
print ("The deque after extending deque at beginning is : ")
print (de)
 
# using rotate() to rotate the deque
# rotates by 3 to left
de.rotate(-3)
 
# printing modified deque
print ("The deque after rotating deque is : ")
print (de)
 
# using reverse() to reverse the deque
de.reverse()
 
# printing modified deque
print ("The deque after reversing deque is : ")
print (de)
<EOF>
<BOF>
from __future__ import print_function
import math

class SegmentTree:
    
    def __init__(self, N):
        self.N = N
        self.st = [0 for i in range(0,4*N)] # approximate the overall size of segment tree with array N
        self.lazy = [0 for i in range(0,4*N)] # create array to store lazy update
        self.flag = [0 for i in range(0,4*N)] # flag for lazy update
        
    def left(self, idx):
        return idx*2

    def right(self, idx):
        return idx*2 + 1

    def build(self, idx, l, r, A):
        if l==r:
            self.st[idx] = A[l-1]
        else :
            mid = (l+r)//2
            self.build(self.left(idx),l,mid, A)
            self.build(self.right(idx),mid+1,r, A)
            self.st[idx] = max(self.st[self.left(idx)] , self.st[self.right(idx)])

    # update with O(lg N) (Normal segment tree without lazy update will take O(Nlg N) for each update)
    def update(self, idx, l, r, a, b, val): # update(1, 1, N, a, b, v) for update val v to [a,b]
        if self.flag[idx] == True:
            self.st[idx] = self.lazy[idx]
            self.flag[idx] = False
            if l!=r:
                self.lazy[self.left(idx)] = self.lazy[idx]
                self.lazy[self.right(idx)] = self.lazy[idx]
                self.flag[self.left(idx)] = True
                self.flag[self.right(idx)] = True
            
        if r < a or l > b:
            return True
        if l >= a and r <= b :
            self.st[idx] = val
            if l!=r:
                self.lazy[self.left(idx)] = val
                self.lazy[self.right(idx)] = val
                self.flag[self.left(idx)] = True
                self.flag[self.right(idx)] = True
            return True
        mid = (l+r)//2
        self.update(self.left(idx),l,mid,a,b,val)
        self.update(self.right(idx),mid+1,r,a,b,val)
        self.st[idx] = max(self.st[self.left(idx)] , self.st[self.right(idx)])
        return True

    # query with O(lg N)
    def query(self, idx, l, r, a, b): #query(1, 1, N, a, b) for query max of [a,b]
        if self.flag[idx] == True:
            self.st[idx] = self.lazy[idx]
            self.flag[idx] = False
            if l != r:
                self.lazy[self.left(idx)] = self.lazy[idx]
                self.lazy[self.right(idx)] = self.lazy[idx]
                self.flag[self.left(idx)] = True
                self.flag[self.right(idx)] = True
        if r < a or l > b:
            return -math.inf
        if l >= a and r <= b:
            return self.st[idx]
        mid = (l+r)//2
        q1 = self.query(self.left(idx),l,mid,a,b)
        q2 = self.query(self.right(idx),mid+1,r,a,b)
        return max(q1,q2)

    def showData(self):
        showList = []
        for i in range(1,N+1):
            showList += [self.query(1, 1, self.N, i, i)]
        print (showList)
            

if __name__ == '__main__':
    A = [1,2,-4,7,3,-5,6,11,-20,9,14,15,5,2,-8]
    N = 15
    segt = SegmentTree(N)
    segt.build(1,1,N,A)
    print (segt.query(1,1,N,4,6))
    print (segt.query(1,1,N,7,11))
    print (segt.query(1,1,N,7,12))
    segt.update(1,1,N,1,3,111)
    print (segt.query(1,1,N,1,15))
    segt.update(1,1,N,7,8,235)
    segt.showData()
<EOF>
<BOF>
from __future__ import print_function
class FenwickTree:

    def __init__(self, SIZE): # create fenwick tree with size SIZE
        self.Size = SIZE
        self.ft = [0 for i in range (0,SIZE)]

    def update(self, i, val): # update data (adding) in index i in O(lg N)
        while (i < self.Size):
            self.ft[i] += val
            i += i & (-i)

    def query(self, i): # query cumulative data from index 0 to i in O(lg N)
        ret = 0
        while (i > 0):
            ret += self.ft[i]
            i -= i & (-i)
        return ret
            
if __name__ == '__main__':
    f = FenwickTree(100)
    f.update(1,20)
    f.update(4,4)
    print (f.query(1))
    print (f.query(3))
    print (f.query(4))
    f.update(2,-5)
    print (f.query(1))
    print (f.query(3))
<EOF>
<BOF>
# -*- coding: utf-8 -*-
'''
An auto-balanced binary tree!
'''
import math
import random
class my_queue:
    def __init__(self):
        self.data = []
        self.head = 0
        self.tail = 0
    def isEmpty(self):
        return self.head == self.tail
    def push(self,data):
        self.data.append(data)
        self.tail = self.tail + 1
    def pop(self):
        ret = self.data[self.head]
        self.head = self.head + 1
        return ret
    def count(self):
        return self.tail - self.head
    def print(self):
        print(self.data)
        print("**************")
        print(self.data[self.head:self.tail])
        
class my_node:
    def __init__(self,data):
        self.data = data
        self.left = None
        self.right = None
        self.height = 1
    def getdata(self):
        return self.data
    def getleft(self):
        return self.left
    def getright(self):
        return self.right
    def getheight(self):
        return self.height
    def setdata(self,data):
        self.data = data
        return
    def setleft(self,node):
        self.left = node
        return
    def setright(self,node):
        self.right = node
        return
    def setheight(self,height):
        self.height = height
        return

def getheight(node):
    if node is None:
        return 0
    return node.getheight()

def my_max(a,b):
    if a > b:
        return a
    return b



def leftrotation(node):
    '''
            A                      B
           / \                    / \
          B   C                  Bl  A
         / \       -->          /   / \
        Bl  Br                 UB Br  C
       /
     UB
  
    UB = unbalanced node  
    '''
    print("left rotation node:",node.getdata())
    ret = node.getleft()
    node.setleft(ret.getright())
    ret.setright(node)
    h1 = my_max(getheight(node.getright()),getheight(node.getleft())) + 1
    node.setheight(h1)
    h2 = my_max(getheight(ret.getright()),getheight(ret.getleft())) + 1         
    ret.setheight(h2)
    return ret

def rightrotation(node):
    '''
        a mirror symmetry rotation of the leftrotation
    '''
    print("right rotation node:",node.getdata())
    ret = node.getright()
    node.setright(ret.getleft())
    ret.setleft(node)
    h1 = my_max(getheight(node.getright()),getheight(node.getleft())) + 1
    node.setheight(h1)
    h2 = my_max(getheight(ret.getright()),getheight(ret.getleft())) + 1         
    ret.setheight(h2)
    return ret

def rlrotation(node):
    '''
            A              A                    Br      
           / \            / \                  /  \
          B   C    RR    Br  C       LR       B    A
         / \       -->  /  \         -->    /     / \
        Bl  Br         B   UB              Bl    UB  C  
             \        /
             UB     Bl
    RR = rightrotation   LR = leftrotation
    '''
    node.setleft(rightrotation(node.getleft()))
    return leftrotation(node)

def lrrotation(node):
    node.setright(leftrotation(node.getright()))
    return rightrotation(node)


def insert_node(node,data):
    if node is None:
        return my_node(data)
    if data < node.getdata():
        node.setleft(insert_node(node.getleft(),data))
        if getheight(node.getleft()) - getheight(node.getright()) == 2: #an unbalance detected
            if data < node.getleft().getdata():       #new node is the left child of the left child
                node = leftrotation(node)
            else:
                node = rlrotation(node)             #new node is the right child of the left child
    else:
        node.setright(insert_node(node.getright(),data))
        if getheight(node.getright()) - getheight(node.getleft()) == 2:
            if data < node.getright().getdata():
                node = lrrotation(node)
            else:
                node = rightrotation(node)
    h1 = my_max(getheight(node.getright()),getheight(node.getleft())) + 1
    node.setheight(h1)
    return node

def getRightMost(root):
    while root.getright() is not None:
        root = root.getright()
    return root.getdata()
def getLeftMost(root):
    while root.getleft() is not None:
        root = root.getleft()
    return root.getdata()

def del_node(root,data):
    if root.getdata() == data:
        if root.getleft() is not None and root.getright() is not None:
            temp_data = getLeftMost(root.getright())
            root.setdata(temp_data)
            root.setright(del_node(root.getright(),temp_data))
        elif root.getleft() is not None:
            root = root.getleft()
        else:
            root = root.getright()
    elif root.getdata() > data:
        if root.getleft() is None:
            print("No such data")
            return root
        else:
            root.setleft(del_node(root.getleft(),data))
    elif root.getdata() < data:
        if root.getright() is None:
            return root
        else:
            root.setright(del_node(root.getright(),data))
    if root is None:
        return root
    if getheight(root.getright()) - getheight(root.getleft()) == 2:
        if getheight(root.getright().getright()) > getheight(root.getright().getleft()):
            root = rightrotation(root)
        else:
            root = lrrotation(root)
    elif getheight(root.getright()) - getheight(root.getleft()) == -2:
        if getheight(root.getleft().getleft()) > getheight(root.getleft().getright()):
            root = leftrotation(root)
        else:
            root = rlrotation(root)
    height = my_max(getheight(root.getright()),getheight(root.getleft())) + 1
    root.setheight(height)
    return root

class AVLtree:
    def __init__(self):
        self.root = None
    def getheight(self):
#        print("yyy")
        return getheight(self.root)
    def insert(self,data):
        print("insert:"+str(data))
        self.root = insert_node(self.root,data)
        
    def del_node(self,data):
        print("delete:"+str(data))
        if self.root is None:
            print("Tree is empty!")
            return
        self.root = del_node(self.root,data)
    def traversale(self): #a level traversale, gives a more intuitive look on the tree
        q = my_queue()
        q.push(self.root)
        layer = self.getheight()
        if layer == 0:
            return
        cnt = 0
        while not q.isEmpty():
            node = q.pop()
            space = " "*int(math.pow(2,layer-1))
            print(space,end = "")
            if node is None:
                print("*",end = "")
                q.push(None)
                q.push(None)
            else:
                print(node.getdata(),end = "")
                q.push(node.getleft())
                q.push(node.getright())
            print(space,end = "")
            cnt = cnt + 1
            for i in range(100):
                if cnt == math.pow(2,i) - 1:
                    layer = layer -1 
                    if layer == 0:
                        print()
                        print("*************************************")
                        return
                    print()
                    break
        print()
        print("*************************************")
        return
    
    def test(self):
        getheight(None)
        print("****")
        self.getheight()
if __name__ == "__main__":
    t = AVLtree()
    t.traversale()
    l = list(range(10))
    random.shuffle(l)
    for i in l:
        t.insert(i)
        t.traversale()
        
    random.shuffle(l)
    for i in l:
        t.del_node(i)
        t.traversale()
<EOF>
<BOF>
from __future__ import print_function
import math

class SegmentTree:
    
    def __init__(self, A):
        self.N = len(A)
        self.st = [0] * (4 * self.N) # approximate the overall size of segment tree with array N
        self.build(1, 0, self.N - 1)
        
    def left(self, idx):
        return idx * 2

    def right(self, idx):
        return idx * 2 + 1

    def build(self, idx, l, r):
        if l == r:
            self.st[idx] = A[l]
        else:
            mid = (l + r) // 2
            self.build(self.left(idx), l, mid)
            self.build(self.right(idx), mid + 1, r)
            self.st[idx] = max(self.st[self.left(idx)] , self.st[self.right(idx)])
    
    def update(self, a, b, val):
        return self.update_recursive(1, 0, self.N - 1, a - 1, b - 1, val)
    
    def update_recursive(self, idx, l, r, a, b, val): # update(1, 1, N, a, b, v) for update val v to [a,b]
        if r < a or l > b:
            return True
        if l == r :
            self.st[idx] = val
            return True
        mid = (l+r)//2
        self.update_recursive(self.left(idx), l, mid, a, b, val)
        self.update_recursive(self.right(idx), mid+1, r, a, b, val)
        self.st[idx] = max(self.st[self.left(idx)] , self.st[self.right(idx)])
        return True

    def query(self, a, b):
        return self.query_recursive(1, 0, self.N - 1, a - 1, b - 1)

    def query_recursive(self, idx, l, r, a, b): #query(1, 1, N, a, b) for query max of [a,b]
        if r < a or l > b:
            return -math.inf
        if l >= a and r <= b:
            return self.st[idx]
        mid = (l+r)//2
        q1 = self.query_recursive(self.left(idx), l, mid, a, b)
        q2 = self.query_recursive(self.right(idx), mid + 1, r, a, b)
        return max(q1, q2)

    def showData(self):
        showList = []
        for i in range(1,N+1):
            showList += [self.query(i, i)]
        print (showList)
            

if __name__ == '__main__':
    A = [1,2,-4,7,3,-5,6,11,-20,9,14,15,5,2,-8]
    N = 15
    segt = SegmentTree(A)
    print (segt.query(4, 6))
    print (segt.query(7, 11))
    print (segt.query(7, 12))
    segt.update(1,3,111)
    print (segt.query(1, 15))
    segt.update(7,8,235)
    segt.showData()
<EOF>
<BOF>
'''
A binary search Tree
'''
from __future__ import print_function
class Node:

    def __init__(self, label, parent):
        self.label = label
        self.left = None
        self.right = None
        #Added in order to delete a node easier
        self.parent = parent

    def getLabel(self):
        return self.label

    def setLabel(self, label):
        self.label = label

    def getLeft(self):
        return self.left

    def setLeft(self, left):
        self.left = left

    def getRight(self):
        return self.right

    def setRight(self, right):
        self.right = right

    def getParent(self):
        return self.parent

    def setParent(self, parent):
        self.parent = parent

class BinarySearchTree:

    def __init__(self):
        self.root = None

    def insert(self, label):
        # Create a new Node
        new_node = Node(label, None)
        # If Tree is empty
        if self.empty():
            self.root = new_node
        else:
            #If Tree is not empty
            curr_node = self.root
            #While we don't get to a leaf
            while curr_node is not None:
                #We keep reference of the parent node
                parent_node = curr_node
                #If node label is less than current node
                if new_node.getLabel() < curr_node.getLabel():
                #We go left
                    curr_node = curr_node.getLeft()
                else:
                    #Else we go right
                    curr_node = curr_node.getRight()
            #We insert the new node in a leaf
            if new_node.getLabel() < parent_node.getLabel():
                parent_node.setLeft(new_node)
            else:
                parent_node.setRight(new_node)
            #Set parent to the new node
            new_node.setParent(parent_node)      
    
    def delete(self, label):
        if (not self.empty()):
            #Look for the node with that label
            node = self.getNode(label)
            #If the node exists
            if(node is not None):
                #If it has no children
                if(node.getLeft() is None and node.getRight() is None):
                    self.__reassignNodes(node, None)
                    node = None
                #Has only right children
                elif(node.getLeft() is None and node.getRight() is not None):
                    self.__reassignNodes(node, node.getRight())
                #Has only left children
                elif(node.getLeft() is not None and node.getRight() is None):
                    self.__reassignNodes(node, node.getLeft())
                #Has two children
                else:
                    #Gets the max value of the left branch
                    tmpNode = self.getMax(node.getLeft())
                    #Deletes the tmpNode
                    self.delete(tmpNode.getLabel())
                    #Assigns the value to the node to delete and keesp tree structure
                    node.setLabel(tmpNode.getLabel())
    
    def getNode(self, label):
        curr_node = None
        #If the tree is not empty
        if(not self.empty()):
            #Get tree root
            curr_node = self.getRoot()
            #While we don't find the node we look for
            #I am using lazy evaluation here to avoid NoneType Attribute error
            while curr_node is not None and curr_node.getLabel() is not label:
                #If node label is less than current node
                if label < curr_node.getLabel():
                    #We go left
                    curr_node = curr_node.getLeft()
                else:
                    #Else we go right
                    curr_node = curr_node.getRight()
        return curr_node

    def getMax(self, root = None):
        if(root is not None):
            curr_node = root
        else:
            #We go deep on the right branch
            curr_node = self.getRoot()
        if(not self.empty()):
            while(curr_node.getRight() is not None):
                curr_node = curr_node.getRight()
        return curr_node

    def getMin(self, root = None):
        if(root is not None):
            curr_node = root
        else:
            #We go deep on the left branch
            curr_node = self.getRoot()
        if(not self.empty()):
            curr_node = self.getRoot()
            while(curr_node.getLeft() is not None):
                curr_node = curr_node.getLeft()
        return curr_node

    def empty(self):
        if self.root is None:
            return True
        return False

    def __InOrderTraversal(self, curr_node):
        nodeList = []
        if curr_node is not None:
            nodeList.insert(0, curr_node)
            nodeList = nodeList + self.__InOrderTraversal(curr_node.getLeft())
            nodeList = nodeList + self.__InOrderTraversal(curr_node.getRight())
        return nodeList

    def getRoot(self):
        return self.root

    def __isRightChildren(self, node):
        if(node == node.getParent().getRight()):
            return True
        return False

    def __reassignNodes(self, node, newChildren):
        if(newChildren is not None):
            newChildren.setParent(node.getParent())
        if(node.getParent() is not None):
            #If it is the Right Children
            if(self.__isRightChildren(node)):
                node.getParent().setRight(newChildren)
            else:
                #Else it is the left children
                node.getParent().setLeft(newChildren)

    #This function traversal the tree. By default it returns an
    #In order traversal list. You can pass a function to traversal
    #The tree as needed by client code
    def traversalTree(self, traversalFunction = None, root = None):
        if(traversalFunction is None):
            #Returns a list of nodes in preOrder by default
            return self.__InOrderTraversal(self.root)
        else:
            #Returns a list of nodes in the order that the users wants to
            return traversalFunction(self.root)

    #Returns an string of all the nodes labels in the list 
    #In Order Traversal
    def __str__(self):
        list = self.__InOrderTraversal(self.root)
        str = ""
        for x in list:
            str = str + " " + x.getLabel().__str__()
        return str

def InPreOrder(curr_node):
    nodeList = []
    if curr_node is not None:
        nodeList = nodeList + InPreOrder(curr_node.getLeft())
        nodeList.insert(0, curr_node.getLabel())
        nodeList = nodeList + InPreOrder(curr_node.getRight())
    return nodeList

def testBinarySearchTree():
    '''
    Example
                  8
                 / \
                3   10
               / \    \
              1   6    14
                 / \   /
                4   7 13 
    '''

    '''
    Example After Deletion
                  7
                 / \
                1   4

    '''
    t = BinarySearchTree()
    t.insert(8)
    t.insert(3)
    t.insert(6)
    t.insert(1)
    t.insert(10)
    t.insert(14)
    t.insert(13)
    t.insert(4)
    t.insert(7)

    #Prints all the elements of the list in order traversal
    print(t.__str__())

    if(t.getNode(6) is not None):
        print("The label 6 exists")
    else:
        print("The label 6 doesn't exist")

    if(t.getNode(-1) is not None):
        print("The label -1 exists")
    else:
        print("The label -1 doesn't exist")
    
    if(not t.empty()):
        print(("Max Value: ", t.getMax().getLabel()))
        print(("Min Value: ", t.getMin().getLabel()))
    
    t.delete(13)
    t.delete(10)
    t.delete(8)
    t.delete(3)
    t.delete(6)
    t.delete(14)

    #Gets all the elements of the tree In pre order
    #And it prints them
    list = t.traversalTree(InPreOrder, t.root)
    for x in list:
        print(x)

if __name__ == "__main__":
    testBinarySearchTree()
<EOF>
<BOF>
from __future__ import print_function
# Function to print element and NGE pair for all elements of list
def printNGE(arr):
 
    for i in range(0, len(arr), 1):
 
        next = -1
        for j in range(i+1, len(arr), 1):
            if arr[i] < arr[j]:
                next = arr[j]
                break
             
        print(str(arr[i]) + " -- " + str(next))
 
# Driver program to test above function
arr = [11,13,21,3]
printNGE(arr)
<EOF>
<BOF>
class Stack:

   def __init__(self):
      self.stack = []
      self.top = 0

   def is_empty(self):
      return (self.top == 0)

   def push(self, item):
      if self.top < len(self.stack):
         self.stack[self.top] = item
      else:
         self.stack.append(item)

      self.top += 1

   def pop(self):
      if self.is_empty():
         return None
      else:
         self.top -= 1
         return self.stack[self.top]
<EOF>
<BOF>
'''
The stock span problem is a financial problem where we have a series of n daily 
price quotes for a stock and we need to calculate span of stock's price for all n days.

The span Si of the stock's price on a given day i is defined as the maximum 
number of consecutive days just before the given day, for which the price of the stock 
on the current day is less than or equal to its price on the given day.
'''
from __future__ import print_function
def calculateSpan(price, S): 
      
    n = len(price) 
    # Create a stack and push index of fist element to it 
    st = []  
    st.append(0) 
  
    # Span value of first element is always 1 
    S[0] = 1 
  
    # Calculate span values for rest of the elements 
    for i in range(1, n): 
          
        # Pop elements from stack whlie stack is not 
        # empty and top of stack is smaller than price[i] 
        while( len(st) > 0 and price[st[0]] <= price[i]): 
            st.pop() 
  
        # If stack becomes empty, then price[i] is greater 
        # than all elements on left of it, i.e. price[0], 
        # price[1], ..price[i-1]. Else the price[i]  is 
        # greater than elements after top of stack 
        S[i] = i+1 if len(st) <= 0 else (i - st[0]) 
  
        # Push this element to stack 
        st.append(i) 
  
  
# A utility function to print elements of array 
def printArray(arr, n): 
    for i in range(0,n): 
        print (arr[i],end =" ") 
  
  
# Driver program to test above function 
price = [10, 4, 5, 90, 120, 80] 
S = [0 for i in range(len(price)+1)] 
  
# Fill the span values in array S[] 
calculateSpan(price, S) 
  
# Print the calculated span values 
printArray(S, len(price)) 
<EOF>
<BOF>
from __future__ import print_function
from __future__ import absolute_import
import string

from .Stack import Stack

__author__ = 'Omkar Pathak'


def is_operand(char):
    return char in string.ascii_letters or char in string.digits


def precedence(char):
    """ Return integer value representing an operator's precedence, or
    order of operation.

    https://en.wikipedia.org/wiki/Order_of_operations
    """
    dictionary = {'+': 1, '-': 1,
                  '*': 2, '/': 2,
                  '^': 3}
    return dictionary.get(char, -1)


def infix_to_postfix(expression):
    """ Convert infix notation to postfix notation using the Shunting-yard
    algorithm.

    https://en.wikipedia.org/wiki/Shunting-yard_algorithm
    https://en.wikipedia.org/wiki/Infix_notation
    https://en.wikipedia.org/wiki/Reverse_Polish_notation
    """
    stack = Stack(len(expression))
    postfix = []
    for char in expression:
        if is_operand(char):
            postfix.append(char)
        elif char not in {'(', ')'}:
            while (not stack.is_empty()
                    and precedence(char) <= precedence(stack.peek())):
                postfix.append(stack.pop())
            stack.push(char)
        elif char == '(':
            stack.push(char)
        elif char == ')':
            while not stack.is_empty() and stack.peek() != '(':
                postfix.append(stack.pop())
            # Pop '(' from stack. If there is no '(', there is a mismatched
            # parentheses.
            if stack.peek() != '(':
                raise ValueError('Mismatched parentheses')
            stack.pop()
    while not stack.is_empty():
        postfix.append(stack.pop())
    return ' '.join(postfix)


if __name__ == '__main__':
    expression = 'a+b*(c^d-e)^(f+g*h)-i'

    print('Infix to Postfix Notation demonstration:\n')
    print('Infix notation: ' + expression)
    print('Postfix notation: ' + infix_to_postfix(expression))
<EOF>
<BOF>
from __future__ import print_function
from __future__ import absolute_import
from .Stack import Stack

__author__ = 'Omkar Pathak'


def balanced_parentheses(parentheses):
    """ Use a stack to check if a string of parentheses is balanced."""
    stack = Stack(len(parentheses))
    for parenthesis in parentheses:
        if parenthesis == '(':
            stack.push(parenthesis)
        elif parenthesis == ')':
            stack.pop()
    return not stack.is_empty()


if __name__ == '__main__':
    examples = ['((()))', '((())']
    print('Balanced parentheses demonstration:\n')
    for example in examples:
        print(example + ': ' + str(balanced_parentheses(example)))
<EOF>
<BOF>
from __future__ import print_function
__author__ = 'Omkar Pathak'


class Stack(object):
    """ A stack is an abstract data type that serves as a collection of
    elements with two principal operations: push() and pop(). push() adds an
    element to the top of the stack, and pop() removes an element from the top
    of a stack. The order in which elements come off of a stack are
    Last In, First Out (LIFO).

    https://en.wikipedia.org/wiki/Stack_(abstract_data_type)
    """

    def __init__(self, limit=10):
        self.stack = []
        self.limit = limit

    def __bool__(self):
        return not bool(self.stack)

    def __str__(self):
        return str(self.stack)

    def push(self, data):
        """ Push an element to the top of the stack."""
        if len(self.stack) >= self.limit:
            raise StackOverflowError
        self.stack.append(data)

    def pop(self):
        """ Pop an element off of the top of the stack."""
        if self.stack:
            return self.stack.pop()
        else:
            raise IndexError('pop from an empty stack')

    def peek(self):
        """ Peek at the top-most element of the stack."""
        if self.stack:
            return self.stack[-1]

    def is_empty(self):
        """ Check if a stack is empty."""
        return not bool(self.stack)

    def size(self):
        """ Return the size of the stack."""
        return len(self.stack)


class StackOverflowError(BaseException):
    pass


if __name__ == '__main__':
    stack = Stack()
    for i in range(10):
        stack.push(i)

    print('Stack demonstration:\n')
    print('Initial stack: ' + str(stack))
    print('pop(): ' + str(stack.pop()))
    print('After pop(), the stack is now: ' + str(stack))
    print('peek(): ' + str(stack.peek()))
    stack.push(100)
    print('After push(100), the stack is now: ' + str(stack))
    print('is_empty(): ' + str(stack.is_empty()))
    print('size(): ' + str(stack.size()))
<EOF>
<BOF>
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


def depth_of_tree(tree):
    if tree is None:
        return 0
    else:
        depth_l_tree = depth_of_tree(tree.left)
        depth_r_tree = depth_of_tree(tree.right)
        if depth_l_tree > depth_r_tree:
            return 1 + depth_l_tree
        else:
            return 1 + depth_r_tree


def is_full_binary_tree(tree):
    if tree is None:
        return True
    if (tree.left is None) and (tree.right is None):
        return True
    if (tree.left is not None) and (tree.right is not None):
        return (is_full_binary_tree(tree.left) and is_full_binary_tree(tree.right))
    else:
        return False


def main():
    tree = Node(1)
    tree.left = Node(2)
    tree.right = Node(3)
    tree.left.left = Node(4)
    tree.left.right = Node(5)
    tree.left.right.left = Node(6)
    tree.right.left = Node(7)
    tree.right.left.left = Node(8)
    tree.right.left.left.right = Node(9)

    print(is_full_binary_tree(tree))
    print(depth_of_tree(tree))


if __name__ == '__main__':
    main()
<EOF>
<BOF>
def find_lcm(num_1, num_2):
    max = num_1 if num_1 > num_2 else num_2
    while (True):
        if ((max % num_1 == 0) and (max % num_2 == 0)):
            break
        max += 1
    return max


def main():
    num_1 = 12
    num_2 = 76
    print(find_lcm(num_1, num_2))


if __name__ == '__main__':
    main()
<EOF>
<BOF>
def absVal(num):
    """
    Function to fins absolute value of numbers.
    >>>absVal(-5)
    5
    >>>absVal(0)
    0
    """
    if num < 0:
        return -num
    else:
        return num

def main():
    print(absVal(-34)) # = 34

if __name__ == '__main__':
    main()
<EOF>
<BOF>
def main():
    def findMin(x):
        minNum = x[0]
        for i in x:
            if minNum > i:
                minNum = i
        return minNum

    print(findMin([0,1,2,3,4,5,-3,24,-56])) # = -56

if __name__ == '__main__':
    main()
<EOF>
<BOF>
def main():
    def n31(a):# a = initial number
        c = 0
        l = [a]
        while a != 1:
            if a % 2 == 0:#if even divide it by 2
                a = a // 2
            elif a % 2 == 1:#if odd 3n+1
                a = 3*a +1
            c += 1#counter
            l += [a]

        return l , c
    print(n31(43))
    print(n31(98)[0][-1])# = a
    print("It took {0} steps.".format(n31(13)[1]))#optional finish

if __name__ == '__main__':
    main()
<EOF>
<BOF>
# NguyenU

def find_max(nums):
    max = nums[0]
    for x in nums:
      if x > max:
        max = x
    print(max)

def main():
  find_max([2, 4, 9, 7, 19, 94, 5])

if __name__ == '__main__':
  main()
<EOF>
<BOF>
from abs import absVal
def absMin(x):
    """
    >>>absMin([0,5,1,11])
    0
    >>absMin([3,-10,-2])
    -2
    """
    j = absVal(x[0])
    for i in x:
        if absVal(i) < j:
            j = i
    return j

def main():
    a = [1,2,-11]
    print(absMin(a)) # = 1

if __name__ == '__main__':
    main()
<EOF>
<BOF>
# Program to find the HCF of two Numbers
def find_hcf(num_1, num_2):
    if num_1 == 0:
        return num_2
    if num_2 == 0:
        return num_1
    # Base Case
    if num_1 == num_2:
        return num_1
    if num_1 > num_2:
        return find_hcf(num_1 - num_2, num_2)
    return find_hcf(num_1, num_2 - num_1)


def main():
    num_1 = 24
    num_2 = 34
    print('HCF of %s and %s is %s:' % (num_1, num_2, find_hcf(num_1, num_2)))


if __name__ == '__main__':
    main()
<EOF>
<BOF>
from abs import absVal
def absMax(x):
    """
    >>>absMax([0,5,1,11])
    11
    >>absMax([3,-10,-2])
    -10
    """
    j = x[0]
    for i in x:
        if absVal(i) < j:
            j = i
    return j
    #BUG: i is apparently a list, TypeError: '<' not supported between instances of 'list' and 'int' in absVal


def main():
    a = [1,2,-11]
    print(absVal(a)) # = -11

if __name__ == '__main__':
    main()
<EOF>
<BOF>
# Finding Articulation Points in Undirected Graph
def computeAP(l):
    n = len(l)
    outEdgeCount = 0
    low = [0] * n
    visited = [False] * n
    isArt = [False] * n

    def dfs(root, at, parent, outEdgeCount):
        if parent == root:
            outEdgeCount += 1
        visited[at] = True
        low[at] = at

        for to in l[at]:
            if to == parent:
                pass
            elif not visited[to]:
                outEdgeCount = dfs(root, to, at, outEdgeCount)
                low[at] = min(low[at], low[to])

                # AP found via bridge
                if at < low[to]:
                    isArt[at] = True
                # AP found via cycle
                if at == low[to]:
                    isArt[at] = True
            else:
                low[at] = min(low[at], to)
        return outEdgeCount

    for i in range(n):
        if not visited[i]:
            outEdgeCount = 0
            outEdgeCount = dfs(i, i, -1, outEdgeCount)
            isArt[i] = (outEdgeCount > 1)

    for x in range(len(isArt)):
        if isArt[x] == True:
            print(x)

# Adjacency list of graph
l = {0:[1,2], 1:[0,2], 2:[0,1,3,5], 3:[2,4], 4:[3], 5:[2,6,8], 6:[5,7], 7:[6,8], 8:[5,7]}
computeAP(l)
<EOF>
<BOF>
from collections import deque


def tarjan(g):
    """
    Tarjan's algo for finding strongly connected components in a directed graph

    Uses two main attributes of each node to track reachability, the index of that node within a component(index),
    and the lowest index reachable from that node(lowlink).

    We then perform a dfs of the each component making sure to update these parameters for each node and saving the
    nodes we visit on the way.

    If ever we find that the lowest reachable node from a current node is equal to the index of the current node then it
    must be the root of a strongly connected component and so we save it and it's equireachable vertices as a strongly
    connected component.

    Complexity: strong_connect() is called at most once for each node and has a complexity of O(|E|) as it is DFS.
    Therefore this has complexity O(|V| + |E|) for a graph G = (V, E)

    """

    n = len(g)
    stack = deque()
    on_stack = [False for _ in range(n)]
    index_of = [-1 for _ in range(n)]
    lowlink_of = index_of[:]

    def strong_connect(v, index, components):
        index_of[v] = index  # the number when this node is seen
        lowlink_of[v] = index  # lowest rank node reachable from here
        index += 1
        stack.append(v)
        on_stack[v] = True

        for w in g[v]:
            if index_of[w] == -1:
                index = strong_connect(w, index, components)
                lowlink_of[v] = lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]
            elif on_stack[w]:
                lowlink_of[v] = lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]

        if lowlink_of[v] == index_of[v]:
            component = []
            w = stack.pop()
            on_stack[w] = False
            component.append(w)
            while w != v:
                w = stack.pop()
                on_stack[w] = False
                component.append(w)
            components.append(component)
        return index

    components = []
    for v in range(n):
        if index_of[v] == -1:
            strong_connect(v, 0, components)

    return components


def create_graph(n, edges):
    g = [[] for _ in range(n)]
    for u, v in edges:
        g[u].append(v)
    return g


if __name__ == '__main__':
    # Test
    n_vertices = 7
    source = [0, 0, 1, 2, 3, 3, 4, 4, 6]
    target = [1, 3, 2, 0, 1, 4, 5, 6, 5]
    edges = [(u, v) for u, v in zip(source, target)]
    g = create_graph(n_vertices, edges)

    assert [[5], [6], [4], [3, 2, 1, 0]] == tarjan(g)
<EOF>
<BOF>
from __future__ import print_function

grid = [[0, 1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0],#0 are free path whereas 1's are obstacles
        [0, 1, 0, 0, 0, 0],
        [0, 1, 0, 0, 1, 0],
        [0, 0, 0, 0, 1, 0]]

'''
heuristic = [[9, 8, 7, 6, 5, 4],
             [8, 7, 6, 5, 4, 3],
             [7, 6, 5, 4, 3, 2],
             [6, 5, 4, 3, 2, 1],
             [5, 4, 3, 2, 1, 0]]'''

init = [0, 0]
goal = [len(grid)-1, len(grid[0])-1] #all coordinates are given in format [y,x] 
cost = 1

#the cost map which pushes the path closer to the goal
heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))]
for i in range(len(grid)):    
    for j in range(len(grid[0])):            
        heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])
        if grid[i][j] == 1:
            heuristic[i][j] = 99 #added extra penalty in the heuristic map


#the actions we can take
delta = [[-1, 0 ], # go up
         [ 0, -1], # go left
         [ 1, 0 ], # go down
         [ 0, 1 ]] # go right


#function to search the path
def search(grid,init,goal,cost,heuristic):

    closed = [[0 for col in range(len(grid[0]))] for row in range(len(grid))]# the referrence grid
    closed[init[0]][init[1]] = 1
    action = [[0 for col in range(len(grid[0]))] for row in range(len(grid))]#the action grid

    x = init[0]
    y = init[1]
    g = 0
    f = g + heuristic[init[0]][init[0]]
    cell = [[f, g, x, y]]

    found = False  # flag that is set when search is complete
    resign = False # flag set if we can't find expand

    while not found and not resign:
        if len(cell) == 0:
            resign = True
            return "FAIL"
        else:
            cell.sort()#to choose the least costliest action so as to move closer to the goal
            cell.reverse()
            next = cell.pop()
            x = next[2]
            y = next[3]
            g = next[1]
            f = next[0]

            
            if x == goal[0] and y == goal[1]:
                found = True
            else:
                for i in range(len(delta)):#to try out different valid actions
                    x2 = x + delta[i][0]
                    y2 = y + delta[i][1]
                    if x2 >= 0 and x2 < len(grid) and y2 >=0 and y2 < len(grid[0]):
                        if closed[x2][y2] == 0 and grid[x2][y2] == 0:
                            g2 = g + cost
                            f2 = g2 + heuristic[x2][y2]
                            cell.append([f2, g2, x2, y2])
                            closed[x2][y2] = 1
                            action[x2][y2] = i
    invpath = []
    x = goal[0]
    y = goal[1]
    invpath.append([x, y])#we get the reverse path from here
    while x != init[0] or y != init[1]:
        x2 = x - delta[action[x][y]][0]
        y2 = y - delta[action[x][y]][1]
        x = x2
        y = y2
        invpath.append([x, y])

    path = []
    for i in range(len(invpath)):
    	path.append(invpath[len(invpath) - 1 - i])
    print("ACTION MAP")
    for i in range(len(action)):
        print(action[i])
                  
    return path
    
a = search(grid,init,goal,cost,heuristic)
for i in range(len(a)):
	print(a[i]) 

<EOF>
<BOF>
from __future__ import print_function
num_nodes, num_edges = list(map(int,input().split()))

edges = []

for i in range(num_edges):
	node1, node2, cost = list(map(int,input().split()))
	edges.append((i,node1,node2,cost))

edges = sorted(edges, key=lambda edge: edge[3])

parent = [i for i in range(num_nodes)]

def find_parent(i):
	if(i != parent[i]):
		parent[i] = find_parent(parent[i])
	return parent[i]

minimum_spanning_tree_cost = 0
minimum_spanning_tree = []

for edge in edges:
	parent_a = find_parent(edge[1])
	parent_b = find_parent(edge[2])
	if(parent_a != parent_b):
		minimum_spanning_tree_cost += edge[3]
		minimum_spanning_tree.append(edge)
		parent[parent_a] = parent_b

print(minimum_spanning_tree_cost)
for edge in minimum_spanning_tree:
	print(edge)
<EOF>
<BOF>
# Check whether Graph is Bipartite or Not using BFS

# A Bipartite Graph is a graph whose vertices can be divided into two independent sets,
# U and V such that every edge (u, v) either connects a vertex from U to V or a vertex
# from V to U. In other words, for every edge (u, v), either u belongs to U and v to V,
# or u belongs to V and v to U. We can also say that there is no edge that connects
# vertices of same set.
def checkBipartite(l):
    queue = []
    visited = [False] * len(l)
    color = [-1] * len(l)

    def bfs():
        while(queue):
            u = queue.pop(0)
            visited[u] = True

            for neighbour in l[u]:

                if neighbour == u:
                    return False

                if color[neighbour] == -1:
                    color[neighbour] = 1 - color[u]
                    queue.append(neighbour)

                elif color[neighbour] == color[u]:
                    return False

        return True

    for i in range(len(l)):
        if not visited[i]:
            queue.append(i)
            color[i] = 0
            if bfs() == False:
                return False

    return True

# Adjacency List of graph
l = {0:[1,3], 1:[0,2], 2:[1,3], 3:[0,2]}
print(checkBipartite(l))
<EOF>
<BOF>
import sys
from collections import defaultdict

def PrimsAlgorithm(l):

    nodePosition = []
    def getPosition(vertex):
        return nodePosition[vertex]

    def setPosition(vertex, pos):
        nodePosition[vertex] = pos

    def topToBottom(heap, start, size, positions):
        if start > size // 2 - 1:
            return
        else:
            if 2 * start + 2 >= size:
                m = 2 * start + 1
            else:
                if heap[2 * start + 1] < heap[2 * start + 2]:
                    m = 2 * start + 1
                else:
                    m = 2 * start + 2
            if heap[m] < heap[start]:
                temp, temp1 = heap[m], positions[m]
                heap[m], positions[m] = heap[start], positions[start]
                heap[start], positions[start] = temp, temp1

                temp = getPosition(positions[m])
                setPosition(positions[m], getPosition(positions[start]))
                setPosition(positions[start], temp)

                topToBottom(heap, m, size, positions)

    # Update function if value of any node in min-heap decreases
    def bottomToTop(val, index, heap, position):
        temp = position[index]

        while(index != 0):
            if index % 2 == 0:
                parent = int( (index-2) / 2 )
            else:
                parent = int( (index-1) / 2 )

            if val < heap[parent]:
                heap[index] = heap[parent]
                position[index] = position[parent]
                setPosition(position[parent], index)
            else:
                heap[index] = val
                position[index] = temp
                setPosition(temp, index)
                break
            index = parent
        else:
            heap[0] = val
            position[0] = temp
            setPosition(temp, 0)

    def heapify(heap, positions):
        start = len(heap) // 2 - 1
        for i in range(start, -1, -1):
            topToBottom(heap, i, len(heap), positions)

    def deleteMinimum(heap, positions):
        temp = positions[0]
        heap[0] = sys.maxsize
        topToBottom(heap, 0, len(heap), positions)
        return temp

    visited = [0 for i in range(len(l))]
    Nbr_TV  = [-1 for i in range(len(l))] # Neighboring Tree Vertex of selected vertex
    # Minimum Distance of explored vertex with neighboring vertex of partial tree formed in graph
    Distance_TV = [] # Heap of Distance of vertices from their neighboring vertex
    Positions = []

    for x in range(len(l)):
        p = sys.maxsize
        Distance_TV.append(p)
        Positions.append(x)
        nodePosition.append(x)

    TreeEdges = []
    visited[0] = 1
    Distance_TV[0] = sys.maxsize
    for x in l[0]:
        Nbr_TV[ x[0] ] = 0
        Distance_TV[ x[0] ] = x[1]
    heapify(Distance_TV, Positions)

    for i in range(1, len(l)):
        vertex = deleteMinimum(Distance_TV, Positions)
        if visited[vertex] == 0:
            TreeEdges.append((Nbr_TV[vertex], vertex))
            visited[vertex] = 1
            for v in l[vertex]:
                if visited[v[0]] == 0 and v[1] < Distance_TV[ getPosition(v[0]) ]:
                    Distance_TV[ getPosition(v[0]) ] = v[1]
                    bottomToTop(v[1], getPosition(v[0]), Distance_TV, Positions)
                    Nbr_TV[ v[0] ] = vertex
    return TreeEdges

# < --------- Prims Algorithm --------- >
n = int(input("Enter number of vertices: "))
e = int(input("Enter number of edges: "))
adjlist = defaultdict(list)
for x in range(e):
    l = [int(x) for x in input().split()]
    adjlist[l[0]].append([ l[1], l[2] ])
    adjlist[l[1]].append([ l[0], l[2] ])
print(PrimsAlgorithm(adjlist))
<EOF>
<BOF>
# Finding longest distance in Directed Acyclic Graph using KahnsAlgorithm
def longestDistance(l):
    indegree = [0] * len(l)
    queue = []
    longDist = [1] * len(l)

    for key, values in l.items():
        for i in values:
            indegree[i] += 1

    for i in range(len(indegree)):
        if indegree[i] == 0:
            queue.append(i)

    while(queue):
        vertex = queue.pop(0)
        for x in l[vertex]:
            indegree[x] -= 1

            if longDist[vertex] + 1 > longDist[x]:
                longDist[x] =  longDist[vertex] + 1

            if indegree[x] == 0:
                queue.append(x)

    print(max(longDist))

# Adjacency list of Graph
l = {0:[2,3,4], 1:[2,7], 2:[5], 3:[5,7], 4:[7], 5:[6], 6:[7], 7:[]}
longestDistance(l)
<EOF>
<BOF>
# Finding Bridges in Undirected Graph
def computeBridges(l):
    id = 0
    n = len(l) # No of vertices in graph
    low = [0] * n
    visited = [False] * n

    def dfs(at, parent, bridges, id):
        visited[at] = True
        low[at] = id
        id += 1
        for to in l[at]:
            if to == parent:
                pass
            elif not visited[to]:
                dfs(to, at, bridges, id)
                low[at] = min(low[at], low[to])
                if at < low[to]:
                    bridges.append([at, to])
            else:
                # This edge is a back edge and cannot be a bridge
                low[at] = min(low[at], to)

    bridges = []
    for i in range(n):
        if (not visited[i]):
            dfs(i, -1, bridges, id)
    print(bridges)
            
l = {0:[1,2], 1:[0,2], 2:[0,1,3,5], 3:[2,4], 4:[3], 5:[2,6,8], 6:[5,7], 7:[6,8], 8:[5,7]}
computeBridges(l)
<EOF>
<BOF>
# Kahn's Algorithm is used to find Topological ordering of Directed Acyclic Graph using BFS
def topologicalSort(l):
    indegree = [0] * len(l)
    queue = []
    topo = []
    cnt = 0

    for key, values in l.items():
        for i in values:
            indegree[i] += 1

    for i in range(len(indegree)):
        if indegree[i] == 0:
            queue.append(i)

    while(queue):
        vertex = queue.pop(0)
        cnt += 1
        topo.append(vertex)
        for x in l[vertex]:
            indegree[x] -= 1
            if indegree[x] == 0:
                queue.append(x)

    if cnt != len(l):
        print("Cycle exists")
    else:
        print(topo)

# Adjacency List of Graph
l = {0:[1,2], 1:[3], 2:[3], 3:[4,5], 4:[], 5:[]}
topologicalSort(l)
<EOF>
<BOF>
from __future__ import print_function
# n - no of nodes, m - no of edges
n, m = list(map(int,input().split()))

g = [[] for i in range(n)] #graph
r = [[] for i in range(n)] #reversed graph
# input graph data (edges)
for i in range(m):
    u, v = list(map(int,input().split()))
    g[u].append(v)
    r[v].append(u)

stack = []
visit = [False]*n
scc = []
component = []

def dfs(u):
    global g, r, scc, component, visit, stack
    if visit[u]: return
    visit[u] = True
    for v in g[u]:
        dfs(v)
    stack.append(u)

def dfs2(u):
    global g, r, scc, component, visit, stack
    if visit[u]: return
    visit[u] = True
    component.append(u)
    for v in r[u]:
        dfs2(v)

def kosaraju():
    global g, r, scc, component, visit, stack
    for i in range(n):
        dfs(i)
    visit = [False]*n
    for i in stack[::-1]:
        if visit[i]: continue
        component = []
        dfs2(i)
        scc.append(component)
    return scc

print(kosaraju())
<EOF>
<BOF>
from __future__ import print_function
import heapq
import numpy as np

try:
    xrange          # Python 2
except NameError:
    xrange = range  # Python 3


class PriorityQueue:
	def __init__(self):
		self.elements = []
		self.set = set()

	def minkey(self):
		if not self.empty():
			return self.elements[0][0]
		else:
			return float('inf')
	
	def empty(self):
		return len(self.elements) == 0

	def put(self, item, priority):
		if item not in self.set:
			heapq.heappush(self.elements, (priority, item))
			self.set.add(item)
		else:
			# update
			# print("update", item)
			temp = []
			(pri, x) = heapq.heappop(self.elements)
			while x != item:
				temp.append((pri, x))
				(pri, x) = heapq.heappop(self.elements)
			temp.append((priority, item))
			for (pro, xxx) in temp:
				heapq.heappush(self.elements, (pro, xxx))

	def remove_element(self, item):
		if item in self.set:
			self.set.remove(item)
			temp = []
			(pro, x) = heapq.heappop(self.elements)
			while x != item:
				temp.append((pro, x))
				(pro, x) = heapq.heappop(self.elements)
			for (prito, yyy) in temp:
				heapq.heappush(self.elements, (prito, yyy))
	
	def top_show(self):
		return self.elements[0][1]
	
	def get(self):
		(priority, item) = heapq.heappop(self.elements)
		self.set.remove(item)
		return (priority, item)

def consistent_hueristic(P, goal):
	# euclidean distance
	a = np.array(P)
	b = np.array(goal)
	return np.linalg.norm(a - b)

def hueristic_2(P, goal):
	# integer division by time variable
	return consistent_hueristic(P, goal) // t 

def hueristic_1(P, goal):
	# manhattan distance
	return abs(P[0] - goal[0]) + abs(P[1] - goal[1])

def key(start, i, goal, g_function):
	ans = g_function[start] + W1 * hueristics[i](start, goal)
	return ans
	
def do_something(back_pointer, goal, start):
	grid = np.chararray((n, n))
	for i in range(n):
		for j in range(n):
			grid[i][j] = '*'
	
	for i in range(n):
		for j in range(n):
			if (j, (n-1)-i) in blocks:
				grid[i][j] = "#"

	grid[0][(n-1)] = "-"
	x = back_pointer[goal]
	while x != start:
		(x_c, y_c) = x
		# print(x)
		grid[(n-1)-y_c][x_c] = "-"
		x = back_pointer[x]
	grid[(n-1)][0] = "-"
	

	for i in xrange(n):
		for j in range(n):
			if (i, j) == (0, n-1):
				print(grid[i][j], end=' ')
				print("<-- End position", end=' ')
			else:
				print(grid[i][j], end=' ')
		print()
	print("^")
	print("Start position")
	print()
	print("# is an obstacle")
	print("- is the path taken by algorithm")
	print("PATH TAKEN BY THE ALGORITHM IS:-")
	x = back_pointer[goal]
	while x != start:
		print(x, end=' ') 
		x = back_pointer[x]
	print(x)
	quit()

def valid(p):
	if p[0] < 0 or p[0] > n-1:
		return False
	if p[1] < 0 or p[1] > n-1:
		return False
	return True

def expand_state(s, j, visited, g_function, close_list_anchor, close_list_inad,  open_list, back_pointer):
	for itera in range(n_hueristic):
		open_list[itera].remove_element(s)
	# print("s", s)
	# print("j", j)
	(x, y) = s
	left = (x-1, y)
	right = (x+1, y)
	up = (x, y+1)
	down = (x, y-1)

	for neighbours in [left, right, up, down]:
		if neighbours not in blocks:
			if valid(neighbours) and neighbours not in visited:
				# print("neighbour", neighbours)
				visited.add(neighbours)
				back_pointer[neighbours] = -1
				g_function[neighbours] = float('inf')

			if valid(neighbours) and g_function[neighbours] > g_function[s] + 1:
				g_function[neighbours] = g_function[s] + 1
				back_pointer[neighbours] = s
				if neighbours not in close_list_anchor:
					open_list[0].put(neighbours, key(neighbours, 0, goal, g_function))
					if neighbours not in close_list_inad:
						for var in range(1,n_hueristic):
							if key(neighbours, var, goal, g_function) <= W2 * key(neighbours, 0, goal, g_function):
								# print("why not plssssssssss")
								open_list[j].put(neighbours, key(neighbours, var, goal, g_function))
			

	# print

def make_common_ground():
	some_list = []
	# block 1
	for x in range(1, 5):
		for y in range(1, 6):
			some_list.append((x, y))

	# line
	for x in range(15, 20):
		some_list.append((x, 17))

	# block 2 big
	for x in range(10, 19):
		for y in range(1, 15):
			some_list.append((x, y))

	# L block
	for x in range(1, 4):
		for y in range(12, 19):
			some_list.append((x, y))
	for x in range(3, 13):
		for y in range(16, 19):
			some_list.append((x, y))
	return some_list

hueristics = {0: consistent_hueristic, 1: hueristic_1, 2: hueristic_2}

blocks_blk = [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1),(6, 1),(7, 1),(8, 1),(9, 1),(10, 1),(11, 1),(12, 1),(13, 1),(14, 1),(15, 1),(16, 1),(17, 1),(18, 1), (19, 1)]
blocks_no = []
blocks_all = make_common_ground()




blocks = blocks_blk
# hyper parameters
W1 = 1
W2 = 1
n = 20
n_hueristic = 3 # one consistent and two other inconsistent

# start and end destination
start = (0, 0)
goal = (n-1, n-1)

t = 1
def multi_a_star(start, goal, n_hueristic):
	g_function = {start: 0, goal: float('inf')}
	back_pointer = {start:-1, goal:-1}
	open_list = []
	visited = set()

	for i in range(n_hueristic):
		open_list.append(PriorityQueue())
		open_list[i].put(start, key(start, i, goal, g_function))
	
	close_list_anchor = []
	close_list_inad = []
	while open_list[0].minkey() < float('inf'):
		for i in range(1, n_hueristic):
			# print("i", i)
			# print(open_list[0].minkey(), open_list[i].minkey())
			if open_list[i].minkey() <= W2 * open_list[0].minkey():
				global t
				t += 1
				# print("less prio")
				if g_function[goal] <= open_list[i].minkey():
					if g_function[goal] < float('inf'):
						do_something(back_pointer, goal, start)
				else:
					_, get_s = open_list[i].top_show()
					visited.add(get_s)
					expand_state(get_s, i, visited, g_function, close_list_anchor, close_list_inad, open_list, back_pointer)
					close_list_inad.append(get_s)
			else:
				# print("more prio")
				if g_function[goal] <= open_list[0].minkey():
					if g_function[goal] < float('inf'):
						do_something(back_pointer, goal, start)
				else:
					# print("hoolla")
					get_s = open_list[0].top_show()
					visited.add(get_s)
					expand_state(get_s, 0, visited, g_function, close_list_anchor, close_list_inad, open_list, back_pointer)
					close_list_anchor.append(get_s)
	print("No path found to goal")
	print()
	for i in range(n-1,-1, -1):
		for j in range(n):
			if (j, i) in blocks:
				print('#', end=' ')
			elif (j, i) in back_pointer:
				if (j, i) == (n-1, n-1):
					print('*', end=' ')
				else:
					print('-', end=' ')
			else:
				print('*', end=' ')
			if (j, i) == (n-1, n-1):
				print('<-- End position', end=' ')
		print()
	print("^")
	print("Start position")
	print()
	print("# is an obstacle")
	print("- is the path taken by algorithm")
multi_a_star(start, goal, n_hueristic)
<EOF>
<BOF>
from __future__ import print_function

try:
    raw_input  # Python 2
except NameError:
    raw_input = input  # Python 3

try:
    xrange  # Python 2
except NameError:
    xrange = range  # Python 3

# Accept No. of Nodes and edges
n, m = map(int, raw_input().split(" "))

# Initialising Dictionary of edges
g = {}
for i in xrange(n):
    g[i + 1] = []

"""
--------------------------------------------------------------------------------
    Accepting edges of Unweighted Directed Graphs
--------------------------------------------------------------------------------
"""
for _ in xrange(m):
    x, y = map(int, raw_input().split(" "))
    g[x].append(y)

"""
--------------------------------------------------------------------------------
    Accepting edges of Unweighted Undirected Graphs
--------------------------------------------------------------------------------
"""
for _ in xrange(m):
    x, y = map(int, raw_input().split(" "))
    g[x].append(y)
    g[y].append(x)

"""
--------------------------------------------------------------------------------
    Accepting edges of Weighted Undirected Graphs
--------------------------------------------------------------------------------
"""
for _ in xrange(m):
    x, y, r = map(int, raw_input().split(" "))
    g[x].append([y, r])
    g[y].append([x, r])

"""
--------------------------------------------------------------------------------
    Depth First Search.
        Args :  G - Dictionary of edges
                s - Starting Node
        Vars :  vis - Set of visited nodes
                S - Traversal Stack
--------------------------------------------------------------------------------
"""


def dfs(G, s):
    vis, S = set([s]), [s]
    print(s)
    while S:
        flag = 0
        for i in G[S[-1]]:
            if i not in vis:
                S.append(i)
                vis.add(i)
                flag = 1
                print(i)
                break
        if not flag:
            S.pop()


"""
--------------------------------------------------------------------------------
    Breadth First Search.
        Args :  G - Dictionary of edges
                s - Starting Node
        Vars :  vis - Set of visited nodes
                Q - Traveral Stack
--------------------------------------------------------------------------------
"""
from collections import deque


def bfs(G, s):
    vis, Q = set([s]), deque([s])
    print(s)
    while Q:
        u = Q.popleft()
        for v in G[u]:
            if v not in vis:
                vis.add(v)
                Q.append(v)
                print(v)


"""
--------------------------------------------------------------------------------
    Dijkstra's shortest path Algorithm
        Args :  G - Dictionary of edges
                s - Starting Node
        Vars :  dist - Dictionary storing shortest distance from s to every other node
                known - Set of knows nodes
                path - Preceding node in path
--------------------------------------------------------------------------------
"""


def dijk(G, s):
    dist, known, path = {s: 0}, set(), {s: 0}
    while True:
        if len(known) == len(G) - 1:
            break
        mini = 100000
        for i in dist:
            if i not in known and dist[i] < mini:
                mini = dist[i]
                u = i
        known.add(u)
        for v in G[u]:
            if v[0] not in known:
                if dist[u] + v[1] < dist.get(v[0], 100000):
                    dist[v[0]] = dist[u] + v[1]
                    path[v[0]] = u
    for i in dist:
        if i != s:
            print(dist[i])


"""
--------------------------------------------------------------------------------
    Topological Sort
--------------------------------------------------------------------------------
"""
from collections import deque


def topo(G, ind=None, Q=[1]):
    if ind is None:
        ind = [0] * (len(G) + 1)  # SInce oth Index is ignored
        for u in G:
            for v in G[u]:
                ind[v] += 1
        Q = deque()
        for i in G:
            if ind[i] == 0:
                Q.append(i)
    if len(Q) == 0:
        return
    v = Q.popleft()
    print(v)
    for w in G[v]:
        ind[w] -= 1
        if ind[w] == 0:
            Q.append(w)
    topo(G, ind, Q)


"""
--------------------------------------------------------------------------------
    Reading an Adjacency matrix
--------------------------------------------------------------------------------
"""


def adjm():
    n, a = raw_input(), []
    for i in xrange(n):
        a.append(map(int, raw_input().split()))
    return a, n


"""
--------------------------------------------------------------------------------
    Floyd Warshall's algorithm
        Args :  G - Dictionary of edges
                s - Starting Node
        Vars :  dist - Dictionary storing shortest distance from s to every other node
                known - Set of knows nodes
                path - Preceding node in path

--------------------------------------------------------------------------------
"""


def floy(A_and_n):
    (A, n) = A_and_n
    dist = list(A)
    path = [[0] * n for i in xrange(n)]
    for k in xrange(n):
        for i in xrange(n):
            for j in xrange(n):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    path[i][k] = k
    print(dist)


"""
--------------------------------------------------------------------------------
    Prim's MST Algorithm
        Args :  G - Dictionary of edges
                s - Starting Node
        Vars :  dist - Dictionary storing shortest distance from s to nearest node
                known - Set of knows nodes
                path - Preceding node in path
--------------------------------------------------------------------------------
"""


def prim(G, s):
    dist, known, path = {s: 0}, set(), {s: 0}
    while True:
        if len(known) == len(G) - 1:
            break
        mini = 100000
        for i in dist:
            if i not in known and dist[i] < mini:
                mini = dist[i]
                u = i
        known.add(u)
        for v in G[u]:
            if v[0] not in known:
                if v[1] < dist.get(v[0], 100000):
                    dist[v[0]] = v[1]
                    path[v[0]] = u


"""
--------------------------------------------------------------------------------
    Accepting Edge list
        Vars :  n - Number of nodes
                m - Number of edges
        Returns : l - Edge list
                n - Number of Nodes
--------------------------------------------------------------------------------
"""


def edglist():
    n, m = map(int, raw_input().split(" "))
    l = []
    for i in xrange(m):
        l.append(map(int, raw_input().split(' ')))
    return l, n


"""
--------------------------------------------------------------------------------
    Kruskal's MST Algorithm
        Args :  E - Edge list
                n - Number of Nodes
        Vars :  s - Set of all nodes as unique disjoint sets (initially)
--------------------------------------------------------------------------------
"""


def krusk(E_and_n):
    # Sort edges on the basis of distance
    (E, n) = E_and_n
    E.sort(reverse=True, key=lambda x: x[2])
    s = [set([i]) for i in range(1, n + 1)]
    while True:
        if len(s) == 1:
            break
        print(s)
        x = E.pop()
        for i in xrange(len(s)):
            if x[0] in s[i]:
                break
        for j in xrange(len(s)):
            if x[1] in s[j]:
                if i == j:
                    break
                s[j].update(s[i])
                s.pop(i)
                break


# find the isolated node in the graph
def find_isolated_nodes(graph):
    isolated = []
    for node in graph:
        if not graph[node]:
            isolated.append(node)
    return isolated
<EOF>
<BOF>
from __future__ import print_function
'''
What is the greatest product of four adjacent numbers (horizontally, vertically, or diagonally) in this 20x20 array?

08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
'''

try:
	xrange			#Python 2
except NameError:
	xrange = range	#Python 2

def largest_product(grid):
	nColumns = len(grid[0])
	nRows = len(grid)

	largest = 0
	lrDiagProduct = 0
	rlDiagProduct = 0

	#Check vertically, horizontally, diagonally at the same time (only works for nxn grid)
	for i in xrange(nColumns):
		for j in xrange(nRows-3):
			vertProduct = grid[j][i]*grid[j+1][i]*grid[j+2][i]*grid[j+3][i]
			horzProduct = grid[i][j]*grid[i][j+1]*grid[i][j+2]*grid[i][j+3]

			#Left-to-right diagonal (\) product
			if (i < nColumns-3):
				lrDiagProduct = grid[i][j]*grid[i+1][j+1]*grid[i+2][j+2]*grid[i+3][j+3]

			#Right-to-left diagonal(/) product
			if (i > 2):
				rlDiagProduct = grid[i][j]*grid[i-1][j+1]*grid[i-2][j+2]*grid[i-3][j+3]

			maxProduct = max(vertProduct, horzProduct, lrDiagProduct, rlDiagProduct)
			if maxProduct > largest:
				largest = maxProduct

	return largest

if __name__ == '__main__':
	grid = []
	with open('grid.txt') as file:
		for line in file:
			grid.append(line.strip('\n').split(' '))

	grid = [[int(i) for i in grid[j]] for j in xrange(len(grid))]

	print(largest_product(grid))
<EOF>
<BOF>
def main():
	with open ("grid.txt", "r") as f:
		l = []
		for i in range(20):
			l.append([int(x) for x in f.readline().split()])

		maximum = 0

		# right
		for i in range(20):
			for j in range(17):
				temp = l[i][j] * l[i][j+1] * l[i][j+2] * l[i][j+3]
				if temp > maximum:
					maximum = temp

		# down 
		for i in range(17):
			for j in range(20):
				temp = l[i][j] * l[i+1][j] * l[i+2][j] * l[i+3][j]
				if temp > maximum:
					maximum = temp

		#diagonal 1
		for i in range(17):
			for j in range(17):
				temp = l[i][j] * l[i+1][j+1] * l[i+2][j+2] * l[i+3][j+3]
				if temp > maximum:
					maximum = temp
				
		#diagonal 2
		for i in range(17):
			for j in range(3, 20):
				temp = l[i][j] * l[i+1][j-1] * l[i+2][j-2] * l[i+3][j-3]
				if temp > maximum:
					maximum = temp
		print(maximum)

if __name__ == '__main__':
	main()
<EOF>
<BOF>
# -*- coding: utf-8 -*-
from __future__ import print_function
try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3
'''
Coin sums
Problem 31
In England the currency is made up of pound, , and pence, p, and there are
eight coins in general circulation:

1p, 2p, 5p, 10p, 20p, 50p, 1 (100p) and 2 (200p).
It is possible to make 2 in the following way:

11 + 150p + 220p + 15p + 12p + 31p
How many different ways can 2 be made using any number of coins?
'''


def one_pence():
    return 1


def two_pence(x):
    return 0 if x < 0 else two_pence(x - 2) + one_pence()


def five_pence(x):
    return 0 if x < 0 else five_pence(x - 5) + two_pence(x)


def ten_pence(x):
    return 0 if x < 0 else ten_pence(x - 10) + five_pence(x)


def twenty_pence(x):
    return 0 if x < 0 else twenty_pence(x - 20) + ten_pence(x)


def fifty_pence(x):
    return 0 if x < 0 else fifty_pence(x - 50) + twenty_pence(x)


def one_pound(x):
    return 0 if x < 0 else one_pound(x - 100) + fifty_pence(x)


def two_pound(x):
    return 0 if x < 0 else two_pound(x - 200) + one_pound(x)


print(two_pound(200))
<EOF>
<BOF>
from __future__ import print_function
'''
Counting Sundays
Problem 19

You are given the following information, but you may prefer to do some research for yourself.

1 Jan 1900 was a Monday.
Thirty days has September,
April, June and November.
All the rest have thirty-one,
Saving February alone,
Which has twenty-eight, rain or shine.
And on leap years, twenty-nine.

A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.

How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
'''

days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

day = 6
month = 1
year = 1901

sundays = 0

while year < 2001:
	day += 7

	if (year%4 == 0 and not year%100 == 0) or (year%400 == 0):
		if day > days_per_month[month-1] and month is not 2:
			month += 1
			day = day-days_per_month[month-2]
		elif day > 29 and month is 2:
			month += 1
			day = day-29
	else:
		if day > days_per_month[month-1]:
			month += 1
			day = day-days_per_month[month-2]
	
	if month > 12:
		year += 1
		month = 1

	if year < 2001 and day is 1:
		sundays += 1

print(sundays)
<EOF>
<BOF>
def main():
    """
    Consider all integer combinations of ab for 2 <= a <= 5 and 2 <= b <= 5:

    22=4, 23=8, 24=16, 25=32
    32=9, 33=27, 34=81, 35=243
    42=16, 43=64, 44=256, 45=1024
    52=25, 53=125, 54=625, 55=3125
    If they are then placed in numerical order, with any repeats removed,
    we get the following sequence of 15 distinct terms:

    4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

    How many distinct terms are in the sequence generated by ab
    for 2 <= a <= 100 and 2 <= b <= 100?
    """

    collectPowers = set()

    currentPow = 0

    N = 101     # maximum limit

    for a in range(2, N):
        for b in range(2, N):
            currentPow = a**b   # calculates the current power
            collectPowers.add(currentPow)   # adds the result to the set

    print("Number of terms ", len(collectPowers))


if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function
# Program to find the product of a,b,c which are Pythagorean Triplet that satisfice the following:
# 1. a < b < c
# 2. a**2 + b**2 = c**2
# 3. a + b + c = 1000

print("Please Wait...")
for a in range(300):
    for b in range(400):
        for c in range(500):
            if(a < b < c):
                if((a**2) + (b**2) == (c**2)):
                    if((a+b+c) == 1000):
                        print(("Product of",a,"*",b,"*",c,"=",(a*b*c)))
                        break
<EOF>
<BOF>
"""A Pythagorean triplet is a set of three natural numbers, for which,
a^2+b^2=c^2
Given N, Check if there exists any Pythagorean triplet for which a+b+c=N
Find maximum possible value of product of a,b,c among all such Pythagorean triplets, If there is no such Pythagorean triplet print -1."""
#!/bin/python3

product=-1
d=0
N = int(input())
for a in range(1,N//3):
    """Solving the two equations a**2+b**2=c**2 and a+b+c=N eliminating c """
    b=(N*N-2*a*N)//(2*N-2*a)
    c=N-a-b
    if c*c==(a*a+b*b):
        d=(a*b*c)
        if d>=product:
            product=d
print(product)
<EOF>
<BOF>
from itertools import permutations
def main():
	result=list(map("".join, permutations('0123456789')))
	print(result[999999])

if __name__ == '__main__':
	main()
<EOF>
<BOF>
#-.- coding: latin-1 -.-
from __future__ import print_function
from math import sqrt
'''
Amicable Numbers
Problem 21

Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
If d(a) = b and d(b) = a, where a  b, then a and b are an amicable pair and each of a and b are called amicable numbers.

For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.

Evaluate the sum of all the amicable numbers under 10000.
'''
try:
	xrange		#Python 2
except NameError:
	xrange = range	#Python 3

def sum_of_divisors(n):
	total = 0
	for i in xrange(1, int(sqrt(n)+1)):
		if n%i == 0 and i != sqrt(n):
			total += i + n//i
		elif i == sqrt(n):
			total += i

	return total-n

sums = []
total = 0

for i in xrange(1, 10000):
	n = sum_of_divisors(i)
	
	if n < len(sums):
		if sums[n-1] == i:
			total += n + i

	sums.append(n)

print(total)
<EOF>
<BOF>
'''
Problem Statement:
Work out the first ten digits of the sum of the N 50-digit numbers.
'''
from __future__ import print_function

n = int(input().strip())

array = []
for i in range(n):
    array.append(int(input().strip()))

print(str(sum(array))[:10])

<EOF>
<BOF>
# Finding the factorial.
def factorial(n):
    fact = 1
    for i in range(1,n+1):
        fact *= i
    return fact

# Spliting the digits and adding it.
def split_and_add(number):
    sum_of_digits = 0
    while(number>0):
        last_digit = number % 10
        sum_of_digits += last_digit
        number = int(number/10) # Removing the last_digit from the given number.
    return sum_of_digits

# Taking the user input.
number = int(input("Enter the Number: "))

# Assigning the factorial from the factorial function.
factorial = factorial(number)

# Spliting and adding the factorial into answer.
answer = split_and_add(factorial)

# Printing the answer.
print(answer)
<EOF>
<BOF>
from math import factorial
def main():
	print(sum([int(x) for x in str(factorial(100))]))
if __name__ == '__main__':
	main()
<EOF>
<BOF>
from __future__ import print_function
from math import ceil

try:
	xrange			#Python 2
except NameError:
	xrange = range	#Python 3

def diagonal_sum(n):
	total = 1

	for i in xrange(1, int(ceil(n/2.0))):
		odd = 2*i+1
		even = 2*i
		total = total + 4*odd**2 - 6*even

	return total

if __name__ == '__main__':
	import sys

	if len(sys.argv) == 1:
		print(diagonal_sum(1001))
	else:
		try:
			n = int(sys.argv[1])
			diagonal_sum(n)
		except ValueError:
			print('Invalid entry - please enter a number')
<EOF>
<BOF>
# -*- coding: utf-8 -*-
'''
Problem:
The sum of the squares of the first ten natural numbers is,
            1^2 + 2^2 + ... + 10^2 = 385
The square of the sum of the first ten natural numbers is,
            (1 + 2 + ... + 10)^2 = 552 = 3025
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025  385 = 2640.
Find the difference between the sum of the squares of the first N natural numbers and the square of the sum.
'''
from __future__ import print_function

suma = 0
sumb = 0
n = int(input())
for i in range(1,n+1):
    suma += i**2
    sumb += i
sum = sumb**2 - suma
print(sum)
<EOF>
<BOF>
# -*- coding: utf-8 -*-
'''
Problem:
The sum of the squares of the first ten natural numbers is,
            1^2 + 2^2 + ... + 10^2 = 385
The square of the sum of the first ten natural numbers is,
            (1 + 2 + ... + 10)^2 = 552 = 3025
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025  385 = 2640.
Find the difference between the sum of the squares of the first N natural numbers and the square of the sum.
'''
from __future__ import print_function
n = int(input())
suma = n*(n+1)/2
suma **= 2
sumb = n*(n+1)*(2*n+1)/6
print(suma-sumb)
<EOF>
<BOF>
import sys
def main():
    LargestProduct = -sys.maxsize-1
    number=input().strip()
    for i in range(len(number)-13):
        product=1
        for j in range(13):
            product *= int(number[i+j])
        if product > LargestProduct:
            LargestProduct = product
    print(LargestProduct)


if __name__ == '__main__':
    main()
<EOF>
<BOF>
# -*- coding: latin-1 -*-
from __future__ import print_function
'''
Name scores
Problem 22

Using names.txt (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it 
into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list 
to obtain a name score.

For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. 
So, COLIN would obtain a score of 938  53 = 49714.

What is the total of all the name scores in the file?
'''
try:
	xrange		#Python 2
except NameError:
	xrange = range	#Python 3

with open('p022_names.txt') as file:
	names = str(file.readlines()[0])
	names = names.replace('"', '').split(',')

names.sort()

name_score = 0
total_score = 0

for i, name in enumerate(names):
	for letter in name:
		name_score += ord(letter) - 64

	total_score += (i+1)*name_score
	name_score = 0

print(total_score)
<EOF>
<BOF>
def main():
	name = [  
	"MARY", "PATRICIA", "LINDA", "BARBARA", "ELIZABETH", "JENNIFER", "MARIA", "SUSAN", "MARGARET", "DOROTHY",
	"LISA", "NANCY", "KAREN", "BETTY", "HELEN", "SANDRA", "DONNA", "CAROL", "RUTH", "SHARON",
	"MICHELLE", "LAURA", "SARAH", "KIMBERLY", "DEBORAH", "JESSICA", "SHIRLEY", "CYNTHIA", "ANGELA", "MELISSA",
	"BRENDA", "AMY", "ANNA", "REBECCA", "VIRGINIA", "KATHLEEN", "PAMELA", "MARTHA", "DEBRA", "AMANDA",
	"STEPHANIE", "CAROLYN", "CHRISTINE", "MARIE", "JANET", "CATHERINE", "FRANCES", "ANN", "JOYCE", "DIANE",
	"ALICE", "JULIE", "HEATHER", "TERESA", "DORIS", "GLORIA", "EVELYN", "JEAN", "CHERYL", "MILDRED",
	"KATHERINE", "JOAN", "ASHLEY", "JUDITH", "ROSE", "JANICE", "KELLY", "NICOLE", "JUDY", "CHRISTINA",
	"KATHY", "THERESA", "BEVERLY", "DENISE", "TAMMY", "IRENE", "JANE", "LORI", "RACHEL", "MARILYN",
	"ANDREA", "KATHRYN", "LOUISE", "SARA", "ANNE", "JACQUELINE", "WANDA", "BONNIE", "JULIA", "RUBY",
	"LOIS", "TINA", "PHYLLIS", "NORMA", "PAULA", "DIANA", "ANNIE", "LILLIAN", "EMILY", "ROBIN",
	"PEGGY", "CRYSTAL", "GLADYS", "RITA", "DAWN", "CONNIE", "FLORENCE", "TRACY", "EDNA", "TIFFANY",
	"CARMEN", "ROSA", "CINDY", "GRACE", "WENDY", "VICTORIA", "EDITH", "KIM", "SHERRY", "SYLVIA",
	"JOSEPHINE", "THELMA", "SHANNON", "SHEILA", "ETHEL", "ELLEN", "ELAINE", "MARJORIE", "CARRIE", "CHARLOTTE",
	"MONICA", "ESTHER", "PAULINE", "EMMA", "JUANITA", "ANITA", "RHONDA", "HAZEL", "AMBER", "EVA",
	"DEBBIE", "APRIL", "LESLIE", "CLARA", "LUCILLE", "JAMIE", "JOANNE", "ELEANOR", "VALERIE", "DANIELLE",
	"MEGAN", "ALICIA", "SUZANNE", "MICHELE", "GAIL", "BERTHA", "DARLENE", "VERONICA", "JILL", "ERIN",
	"GERALDINE", "LAUREN", "CATHY", "JOANN", "LORRAINE", "LYNN", "SALLY", "REGINA", "ERICA", "BEATRICE",
	"DOLORES", "BERNICE", "AUDREY", "YVONNE", "ANNETTE", "JUNE", "SAMANTHA", "MARION", "DANA", "STACY",
	"ANA", "RENEE", "IDA", "VIVIAN", "ROBERTA", "HOLLY", "BRITTANY", "MELANIE", "LORETTA", "YOLANDA",
	"JEANETTE", "LAURIE", "KATIE", "KRISTEN", "VANESSA", "ALMA", "SUE", "ELSIE", "BETH", "JEANNE",
	"VICKI", "CARLA", "TARA", "ROSEMARY", "EILEEN", "TERRI", "GERTRUDE", "LUCY", "TONYA", "ELLA",
	"STACEY", "WILMA", "GINA", "KRISTIN", "JESSIE", "NATALIE", "AGNES", "VERA", "WILLIE", "CHARLENE",
	"BESSIE", "DELORES", "MELINDA", "PEARL", "ARLENE", "MAUREEN", "COLLEEN", "ALLISON", "TAMARA", "JOY",
	"GEORGIA", "CONSTANCE", "LILLIE", "CLAUDIA", "JACKIE", "MARCIA", "TANYA", "NELLIE", "MINNIE", "MARLENE",
	"HEIDI", "GLENDA", "LYDIA", "VIOLA", "COURTNEY", "MARIAN", "STELLA", "CAROLINE", "DORA", "JO",
	"VICKIE", "MATTIE", "TERRY", "MAXINE", "IRMA", "MABEL", "MARSHA", "MYRTLE", "LENA", "CHRISTY",
	"DEANNA", "PATSY", "HILDA", "GWENDOLYN", "JENNIE", "NORA", "MARGIE", "NINA", "CASSANDRA", "LEAH",
	"PENNY", "KAY", "PRISCILLA", "NAOMI", "CAROLE", "BRANDY", "OLGA", "BILLIE", "DIANNE", "TRACEY",
	"LEONA", "JENNY", "FELICIA", "SONIA", "MIRIAM", "VELMA", "BECKY", "BOBBIE", "VIOLET", "KRISTINA",
	"TONI", "MISTY", "MAE", "SHELLY", "DAISY", "RAMONA", "SHERRI", "ERIKA", "KATRINA", "CLAIRE",
	"LINDSEY", "LINDSAY", "GENEVA", "GUADALUPE", "BELINDA", "MARGARITA", "SHERYL", "CORA", "FAYE", "ADA",
	"NATASHA", "SABRINA", "ISABEL", "MARGUERITE", "HATTIE", "HARRIET", "MOLLY", "CECILIA", "KRISTI", "BRANDI",
	"BLANCHE", "SANDY", "ROSIE", "JOANNA", "IRIS", "EUNICE", "ANGIE", "INEZ", "LYNDA", "MADELINE",
	"AMELIA", "ALBERTA", "GENEVIEVE", "MONIQUE", "JODI", "JANIE", "MAGGIE", "KAYLA", "SONYA", "JAN",
	"LEE", "KRISTINE", "CANDACE", "FANNIE", "MARYANN", "OPAL", "ALISON", "YVETTE", "MELODY", "LUZ",
	"SUSIE", "OLIVIA", "FLORA", "SHELLEY", "KRISTY", "MAMIE", "LULA", "LOLA", "VERNA", "BEULAH",
	"ANTOINETTE", "CANDICE", "JUANA", "JEANNETTE", "PAM", "KELLI", "HANNAH", "WHITNEY", "BRIDGET", "KARLA",
	"CELIA", "LATOYA", "PATTY", "SHELIA", "GAYLE", "DELLA", "VICKY", "LYNNE", "SHERI", "MARIANNE",
	"KARA", "JACQUELYN", "ERMA", "BLANCA", "MYRA", "LETICIA", "PAT", "KRISTA", "ROXANNE", "ANGELICA",
	"JOHNNIE", "ROBYN", "FRANCIS", "ADRIENNE", "ROSALIE", "ALEXANDRA", "BROOKE", "BETHANY", "SADIE", "BERNADETTE",
	"TRACI", "JODY", "KENDRA", "JASMINE", "NICHOLE", "RACHAEL", "CHELSEA", "MABLE", "ERNESTINE", "MURIEL",
	"MARCELLA", "ELENA", "KRYSTAL", "ANGELINA", "NADINE", "KARI", "ESTELLE", "DIANNA", "PAULETTE", "LORA",
	"MONA", "DOREEN", "ROSEMARIE", "ANGEL", "DESIREE", "ANTONIA", "HOPE", "GINGER", "JANIS", "BETSY",
	"CHRISTIE", "FREDA", "MERCEDES", "MEREDITH", "LYNETTE", "TERI", "CRISTINA", "EULA", "LEIGH", "MEGHAN",
	"SOPHIA", "ELOISE", "ROCHELLE", "GRETCHEN", "CECELIA", "RAQUEL", "HENRIETTA", "ALYSSA", "JANA", "KELLEY",
	"GWEN", "KERRY", "JENNA", "TRICIA", "LAVERNE", "OLIVE", "ALEXIS", "TASHA", "SILVIA", "ELVIRA",
	"CASEY", "DELIA", "SOPHIE", "KATE", "PATTI", "LORENA", "KELLIE", "SONJA", "LILA", "LANA",
	"DARLA", "MAY", "MINDY", "ESSIE", "MANDY", "LORENE", "ELSA", "JOSEFINA", "JEANNIE", "MIRANDA",
	"DIXIE", "LUCIA", "MARTA", "FAITH", "LELA", "JOHANNA", "SHARI", "CAMILLE", "TAMI", "SHAWNA",
	"ELISA", "EBONY", "MELBA", "ORA", "NETTIE", "TABITHA", "OLLIE", "JAIME", "WINIFRED", "KRISTIE",
	"MARINA", "ALISHA", "AIMEE", "RENA", "MYRNA", "MARLA", "TAMMIE", "LATASHA", "BONITA", "PATRICE",
	"RONDA", "SHERRIE", "ADDIE", "FRANCINE", "DELORIS", "STACIE", "ADRIANA", "CHERI", "SHELBY", "ABIGAIL",
	"CELESTE", "JEWEL", "CARA", "ADELE", "REBEKAH", "LUCINDA", "DORTHY", "CHRIS", "EFFIE", "TRINA",
	"REBA", "SHAWN", "SALLIE", "AURORA", "LENORA", "ETTA", "LOTTIE", "KERRI", "TRISHA", "NIKKI",
	"ESTELLA", "FRANCISCA", "JOSIE", "TRACIE", "MARISSA", "KARIN", "BRITTNEY", "JANELLE", "LOURDES", "LAUREL",
	"HELENE", "FERN", "ELVA", "CORINNE", "KELSEY", "INA", "BETTIE", "ELISABETH", "AIDA", "CAITLIN",
	"INGRID", "IVA", "EUGENIA", "CHRISTA", "GOLDIE", "CASSIE", "MAUDE", "JENIFER", "THERESE", "FRANKIE",
	"DENA", "LORNA", "JANETTE", "LATONYA", "CANDY", "MORGAN", "CONSUELO", "TAMIKA", "ROSETTA", "DEBORA",
	"CHERIE", "POLLY", "DINA", "JEWELL", "FAY", "JILLIAN", "DOROTHEA", "NELL", "TRUDY", "ESPERANZA",
	"PATRICA", "KIMBERLEY", "SHANNA", "HELENA", "CAROLINA", "CLEO", "STEFANIE", "ROSARIO", "OLA", "JANINE",
	"MOLLIE", "LUPE", "ALISA", "LOU", "MARIBEL", "SUSANNE", "BETTE", "SUSANA", "ELISE", "CECILE",
	"ISABELLE", "LESLEY", "JOCELYN", "PAIGE", "JONI", "RACHELLE", "LEOLA", "DAPHNE", "ALTA", "ESTER",
	"PETRA", "GRACIELA", "IMOGENE", "JOLENE", "KEISHA", "LACEY", "GLENNA", "GABRIELA", "KERI", "URSULA",
	"LIZZIE", "KIRSTEN", "SHANA", "ADELINE", "MAYRA", "JAYNE", "JACLYN", "GRACIE", "SONDRA", "CARMELA",
	"MARISA", "ROSALIND", "CHARITY", "TONIA", "BEATRIZ", "MARISOL", "CLARICE", "JEANINE", "SHEENA", "ANGELINE",
	"FRIEDA", "LILY", "ROBBIE", "SHAUNA", "MILLIE", "CLAUDETTE", "CATHLEEN", "ANGELIA", "GABRIELLE", "AUTUMN",
	"KATHARINE", "SUMMER", "JODIE", "STACI", "LEA", "CHRISTI", "JIMMIE", "JUSTINE", "ELMA", "LUELLA",
	"MARGRET", "DOMINIQUE", "SOCORRO", "RENE", "MARTINA", "MARGO", "MAVIS", "CALLIE", "BOBBI", "MARITZA",
	"LUCILE", "LEANNE", "JEANNINE", "DEANA", "AILEEN", "LORIE", "LADONNA", "WILLA", "MANUELA", "GALE",
	"SELMA", "DOLLY", "SYBIL", "ABBY", "LARA", "DALE", "IVY", "DEE", "WINNIE", "MARCY",
	"LUISA", "JERI", "MAGDALENA", "OFELIA", "MEAGAN", "AUDRA", "MATILDA", "LEILA", "CORNELIA", "BIANCA",
	"SIMONE", "BETTYE", "RANDI", "VIRGIE", "LATISHA", "BARBRA", "GEORGINA", "ELIZA", "LEANN", "BRIDGETTE",
	"RHODA", "HALEY", "ADELA", "NOLA", "BERNADINE", "FLOSSIE", "ILA", "GRETA", "RUTHIE", "NELDA",
	"MINERVA", "LILLY", "TERRIE", "LETHA", "HILARY", "ESTELA", "VALARIE", "BRIANNA", "ROSALYN", "EARLINE",
	"CATALINA", "AVA", "MIA", "CLARISSA", "LIDIA", "CORRINE", "ALEXANDRIA", "CONCEPCION", "TIA", "SHARRON",
	"RAE", "DONA", "ERICKA", "JAMI", "ELNORA", "CHANDRA", "LENORE", "NEVA", "MARYLOU", "MELISA",
	"TABATHA", "SERENA", "AVIS", "ALLIE", "SOFIA", "JEANIE", "ODESSA", "NANNIE", "HARRIETT", "LORAINE",
	"PENELOPE", "MILAGROS", "EMILIA", "BENITA", "ALLYSON", "ASHLEE", "TANIA", "TOMMIE", "ESMERALDA", "KARINA",
	"EVE", "PEARLIE", "ZELMA", "MALINDA", "NOREEN", "TAMEKA", "SAUNDRA", "HILLARY", "AMIE", "ALTHEA",
	"ROSALINDA", "JORDAN", "LILIA", "ALANA", "GAY", "CLARE", "ALEJANDRA", "ELINOR", "MICHAEL", "LORRIE",
	"JERRI", "DARCY", "EARNESTINE", "CARMELLA", "TAYLOR", "NOEMI", "MARCIE", "LIZA", "ANNABELLE", "LOUISA",
	"EARLENE", "MALLORY", "CARLENE", "NITA", "SELENA", "TANISHA", "KATY", "JULIANNE", "JOHN", "LAKISHA",
	"EDWINA", "MARICELA", "MARGERY", "KENYA", "DOLLIE", "ROXIE", "ROSLYN", "KATHRINE", "NANETTE", "CHARMAINE",
	"LAVONNE", "ILENE", "KRIS", "TAMMI", "SUZETTE", "CORINE", "KAYE", "JERRY", "MERLE", "CHRYSTAL",
	"LINA", "DEANNE", "LILIAN", "JULIANA", "ALINE", "LUANN", "KASEY", "MARYANNE", "EVANGELINE", "COLETTE",
	"MELVA", "LAWANDA", "YESENIA", "NADIA", "MADGE", "KATHIE", "EDDIE", "OPHELIA", "VALERIA", "NONA",
	"MITZI", "MARI", "GEORGETTE", "CLAUDINE", "FRAN", "ALISSA", "ROSEANN", "LAKEISHA", "SUSANNA", "REVA",
	"DEIDRE", "CHASITY", "SHEREE", "CARLY", "JAMES", "ELVIA", "ALYCE", "DEIRDRE", "GENA", "BRIANA",
	"ARACELI", "KATELYN", "ROSANNE", "WENDI", "TESSA", "BERTA", "MARVA", "IMELDA", "MARIETTA", "MARCI",
	"LEONOR", "ARLINE", "SASHA", "MADELYN", "JANNA", "JULIETTE", "DEENA", "AURELIA", "JOSEFA", "AUGUSTA",
	"LILIANA", "YOUNG", "CHRISTIAN", "LESSIE", "AMALIA", "SAVANNAH", "ANASTASIA", "VILMA", "NATALIA", "ROSELLA",
	"LYNNETTE", "CORINA", "ALFREDA", "LEANNA", "CAREY", "AMPARO", "COLEEN", "TAMRA", "AISHA", "WILDA",
	"KARYN", "CHERRY", "QUEEN", "MAURA", "MAI", "EVANGELINA", "ROSANNA", "HALLIE", "ERNA", "ENID",
	"MARIANA", "LACY", "JULIET", "JACKLYN", "FREIDA", "MADELEINE", "MARA", "HESTER", "CATHRYN", "LELIA",
	"CASANDRA", "BRIDGETT", "ANGELITA", "JANNIE", "DIONNE", "ANNMARIE", "KATINA", "BERYL", "PHOEBE", "MILLICENT",
	"KATHERYN", "DIANN", "CARISSA", "MARYELLEN", "LIZ", "LAURI", "HELGA", "GILDA", "ADRIAN", "RHEA",
	"MARQUITA", "HOLLIE", "TISHA", "TAMERA", "ANGELIQUE", "FRANCESCA", "BRITNEY", "KAITLIN", "LOLITA", "FLORINE",
	"ROWENA", "REYNA", "TWILA", "FANNY", "JANELL", "INES", "CONCETTA", "BERTIE", "ALBA", "BRIGITTE",
	"ALYSON", "VONDA", "PANSY", "ELBA", "NOELLE", "LETITIA", "KITTY", "DEANN", "BRANDIE", "LOUELLA",
	"LETA", "FELECIA", "SHARLENE", "LESA", "BEVERLEY", "ROBERT", "ISABELLA", "HERMINIA", "TERRA", "CELINA",
	"TORI", "OCTAVIA", "JADE", "DENICE", "GERMAINE", "SIERRA", "MICHELL", "CORTNEY", "NELLY", "DORETHA",
	"SYDNEY", "DEIDRA", "MONIKA", "LASHONDA", "JUDI", "CHELSEY", "ANTIONETTE", "MARGOT", "BOBBY", "ADELAIDE",
	"NAN", "LEEANN", "ELISHA", "DESSIE", "LIBBY", "KATHI", "GAYLA", "LATANYA", "MINA", "MELLISA",
	"KIMBERLEE", "JASMIN", "RENAE", "ZELDA", "ELDA", "MA", "JUSTINA", "GUSSIE", "EMILIE", "CAMILLA",
	"ABBIE", "ROCIO", "KAITLYN", "JESSE", "EDYTHE", "ASHLEIGH", "SELINA", "LAKESHA", "GERI", "ALLENE",
	"PAMALA", "MICHAELA", "DAYNA", "CARYN", "ROSALIA", "SUN", "JACQULINE", "REBECA", "MARYBETH", "KRYSTLE",
	"IOLA", "DOTTIE", "BENNIE", "BELLE", "AUBREY", "GRISELDA", "ERNESTINA", "ELIDA", "ADRIANNE", "DEMETRIA",
	"DELMA", "CHONG", "JAQUELINE", "DESTINY", "ARLEEN", "VIRGINA", "RETHA", "FATIMA", "TILLIE", "ELEANORE",
	"CARI", "TREVA", "BIRDIE", "WILHELMINA", "ROSALEE", "MAURINE", "LATRICE", "YONG", "JENA", "TARYN",
	"ELIA", "DEBBY", "MAUDIE", "JEANNA", "DELILAH", "CATRINA", "SHONDA", "HORTENCIA", "THEODORA", "TERESITA",
	"ROBBIN", "DANETTE", "MARYJANE", "FREDDIE", "DELPHINE", "BRIANNE", "NILDA", "DANNA", "CINDI", "BESS",
	"IONA", "HANNA", "ARIEL", "WINONA", "VIDA", "ROSITA", "MARIANNA", "WILLIAM", "RACHEAL", "GUILLERMINA",
	"ELOISA", "CELESTINE", "CAREN", "MALISSA", "LONA", "CHANTEL", "SHELLIE", "MARISELA", "LEORA", "AGATHA",
	"SOLEDAD", "MIGDALIA", "IVETTE", "CHRISTEN", "ATHENA", "JANEL", "CHLOE", "VEDA", "PATTIE", "TESSIE",
	"TERA", "MARILYNN", "LUCRETIA", "KARRIE", "DINAH", "DANIELA", "ALECIA", "ADELINA", "VERNICE", "SHIELA",
	"PORTIA", "MERRY", "LASHAWN", "DEVON", "DARA", "TAWANA", "OMA", "VERDA", "CHRISTIN", "ALENE",
	"ZELLA", "SANDI", "RAFAELA", "MAYA", "KIRA", "CANDIDA", "ALVINA", "SUZAN", "SHAYLA", "LYN",
	"LETTIE", "ALVA", "SAMATHA", "ORALIA", "MATILDE", "MADONNA", "LARISSA", "VESTA", "RENITA", "INDIA",
	"DELOIS", "SHANDA", "PHILLIS", "LORRI", "ERLINDA", "CRUZ", "CATHRINE", "BARB", "ZOE", "ISABELL",
	"IONE", "GISELA", "CHARLIE", "VALENCIA", "ROXANNA", "MAYME", "KISHA", "ELLIE", "MELLISSA", "DORRIS",
	"DALIA", "BELLA", "ANNETTA", "ZOILA", "RETA", "REINA", "LAURETTA", "KYLIE", "CHRISTAL", "PILAR",
	"CHARLA", "ELISSA", "TIFFANI", "TANA", "PAULINA", "LEOTA", "BREANNA", "JAYME", "CARMEL", "VERNELL",
	"TOMASA", "MANDI", "DOMINGA", "SANTA", "MELODIE", "LURA", "ALEXA", "TAMELA", "RYAN", "MIRNA",
	"KERRIE", "VENUS", "NOEL", "FELICITA", "CRISTY", "CARMELITA", "BERNIECE", "ANNEMARIE", "TIARA", "ROSEANNE",
	"MISSY", "CORI", "ROXANA", "PRICILLA", "KRISTAL", "JUNG", "ELYSE", "HAYDEE", "ALETHA", "BETTINA",
	"MARGE", "GILLIAN", "FILOMENA", "CHARLES", "ZENAIDA", "HARRIETTE", "CARIDAD", "VADA", "UNA", "ARETHA",
	"PEARLINE", "MARJORY", "MARCELA", "FLOR", "EVETTE", "ELOUISE", "ALINA", "TRINIDAD", "DAVID", "DAMARIS",
	"CATHARINE", "CARROLL", "BELVA", "NAKIA", "MARLENA", "LUANNE", "LORINE", "KARON", "DORENE", "DANITA",
	"BRENNA", "TATIANA", "SAMMIE", "LOUANN", "LOREN", "JULIANNA", "ANDRIA", "PHILOMENA", "LUCILA", "LEONORA",
	"DOVIE", "ROMONA", "MIMI", "JACQUELIN", "GAYE", "TONJA", "MISTI", "JOE", "GENE", "CHASTITY",
	"STACIA", "ROXANN", "MICAELA", "NIKITA", "MEI", "VELDA", "MARLYS", "JOHNNA", "AURA", "LAVERN",
	"IVONNE", "HAYLEY", "NICKI", "MAJORIE", "HERLINDA", "GEORGE", "ALPHA", "YADIRA", "PERLA", "GREGORIA",
	"DANIEL", "ANTONETTE", "SHELLI", "MOZELLE", "MARIAH", "JOELLE", "CORDELIA", "JOSETTE", "CHIQUITA", "TRISTA",
	"LOUIS", "LAQUITA", "GEORGIANA", "CANDI", "SHANON", "LONNIE", "HILDEGARD", "CECIL", "VALENTINA", "STEPHANY",
	"MAGDA", "KAROL", "GERRY", "GABRIELLA", "TIANA", "ROMA", "RICHELLE", "RAY", "PRINCESS", "OLETA",
	"JACQUE", "IDELLA", "ALAINA", "SUZANNA", "JOVITA", "BLAIR", "TOSHA", "RAVEN", "NEREIDA", "MARLYN",
	"KYLA", "JOSEPH", "DELFINA", "TENA", "STEPHENIE", "SABINA", "NATHALIE", "MARCELLE", "GERTIE", "DARLEEN",
	"THEA", "SHARONDA", "SHANTEL", "BELEN", "VENESSA", "ROSALINA", "ONA", "GENOVEVA", "COREY", "CLEMENTINE",
	"ROSALBA", "RENATE", "RENATA", "MI", "IVORY", "GEORGIANNA", "FLOY", "DORCAS", "ARIANA", "TYRA",
	"THEDA", "MARIAM", "JULI", "JESICA", "DONNIE", "VIKKI", "VERLA", "ROSELYN", "MELVINA", "JANNETTE",
	"GINNY", "DEBRAH", "CORRIE", "ASIA", "VIOLETA", "MYRTIS", "LATRICIA", "COLLETTE", "CHARLEEN", "ANISSA",
	"VIVIANA", "TWYLA", "PRECIOUS", "NEDRA", "LATONIA", "LAN", "HELLEN", "FABIOLA", "ANNAMARIE", "ADELL",
	"SHARYN", "CHANTAL", "NIKI", "MAUD", "LIZETTE", "LINDY", "KIA", "KESHA", "JEANA", "DANELLE",
	"CHARLINE", "CHANEL", "CARROL", "VALORIE", "LIA", "DORTHA", "CRISTAL", "SUNNY", "LEONE", "LEILANI",
	"GERRI", "DEBI", "ANDRA", "KESHIA", "IMA", "EULALIA", "EASTER", "DULCE", "NATIVIDAD", "LINNIE",
	"KAMI", "GEORGIE", "CATINA", "BROOK", "ALDA", "WINNIFRED", "SHARLA", "RUTHANN", "MEAGHAN", "MAGDALENE",
	"LISSETTE", "ADELAIDA", "VENITA", "TRENA", "SHIRLENE", "SHAMEKA", "ELIZEBETH", "DIAN", "SHANTA", "MICKEY",
	"LATOSHA", "CARLOTTA", "WINDY", "SOON", "ROSINA", "MARIANN", "LEISA", "JONNIE", "DAWNA", "CATHIE",
	"BILLY", "ASTRID", "SIDNEY", "LAUREEN", "JANEEN", "HOLLI", "FAWN", "VICKEY", "TERESSA", "SHANTE",
	"RUBYE", "MARCELINA", "CHANDA", "CARY", "TERESE", "SCARLETT", "MARTY", "MARNIE", "LULU", "LISETTE",
	"JENIFFER", "ELENOR", "DORINDA", "DONITA", "CARMAN", "BERNITA", "ALTAGRACIA", "ALETA", "ADRIANNA", "ZORAIDA",
	"RONNIE", "NICOLA", "LYNDSEY", "KENDALL", "JANINA", "CHRISSY", "AMI", "STARLA", "PHYLIS", "PHUONG",
	"KYRA", "CHARISSE", "BLANCH", "SANJUANITA", "RONA", "NANCI", "MARILEE", "MARANDA", "CORY", "BRIGETTE",
	"SANJUANA", "MARITA", "KASSANDRA", "JOYCELYN", "IRA", "FELIPA", "CHELSIE", "BONNY", "MIREYA", "LORENZA",
	"KYONG", "ILEANA", "CANDELARIA", "TONY", "TOBY", "SHERIE", "OK", "MARK", "LUCIE", "LEATRICE",
	"LAKESHIA", "GERDA", "EDIE", "BAMBI", "MARYLIN", "LAVON", "HORTENSE", "GARNET", "EVIE", "TRESSA",
	"SHAYNA", "LAVINA", "KYUNG", "JEANETTA", "SHERRILL", "SHARA", "PHYLISS", "MITTIE", "ANABEL", "ALESIA",
	"THUY", "TAWANDA", "RICHARD", "JOANIE", "TIFFANIE", "LASHANDA", "KARISSA", "ENRIQUETA", "DARIA", "DANIELLA",
	"CORINNA", "ALANNA", "ABBEY", "ROXANE", "ROSEANNA", "MAGNOLIA", "LIDA", "KYLE", "JOELLEN", "ERA",
	"CORAL", "CARLEEN", "TRESA", "PEGGIE", "NOVELLA", "NILA", "MAYBELLE", "JENELLE", "CARINA", "NOVA",
	"MELINA", "MARQUERITE", "MARGARETTE", "JOSEPHINA", "EVONNE", "DEVIN", "CINTHIA", "ALBINA", "TOYA", "TAWNYA",
	"SHERITA", "SANTOS", "MYRIAM", "LIZABETH", "LISE", "KEELY", "JENNI", "GISELLE", "CHERYLE", "ARDITH",
	"ARDIS", "ALESHA", "ADRIANE", "SHAINA", "LINNEA", "KAROLYN", "HONG", "FLORIDA", "FELISHA", "DORI",
	"DARCI", "ARTIE", "ARMIDA", "ZOLA", "XIOMARA", "VERGIE", "SHAMIKA", "NENA", "NANNETTE", "MAXIE",
	"LOVIE", "JEANE", "JAIMIE", "INGE", "FARRAH", "ELAINA", "CAITLYN", "STARR", "FELICITAS", "CHERLY",
	"CARYL", "YOLONDA", "YASMIN", "TEENA", "PRUDENCE", "PENNIE", "NYDIA", "MACKENZIE", "ORPHA", "MARVEL",
	"LIZBETH", "LAURETTE", "JERRIE", "HERMELINDA", "CAROLEE", "TIERRA", "MIRIAN", "META", "MELONY", "KORI",
	"JENNETTE", "JAMILA", "ENA", "ANH", "YOSHIKO", "SUSANNAH", "SALINA", "RHIANNON", "JOLEEN", "CRISTINE",
	"ASHTON", "ARACELY", "TOMEKA", "SHALONDA", "MARTI", "LACIE", "KALA", "JADA", "ILSE", "HAILEY",
	"BRITTANI", "ZONA", "SYBLE", "SHERRYL", "RANDY", "NIDIA", "MARLO", "KANDICE", "KANDI", "DEB",
	"DEAN", "AMERICA", "ALYCIA", "TOMMY", "RONNA", "NORENE", "MERCY", "JOSE", "INGEBORG", "GIOVANNA",
	"GEMMA", "CHRISTEL", "AUDRY", "ZORA", "VITA", "VAN", "TRISH", "STEPHAINE", "SHIRLEE", "SHANIKA",
	"MELONIE", "MAZIE", "JAZMIN", "INGA", "HOA", "HETTIE", "GERALYN", "FONDA", "ESTRELLA", "ADELLA",
	"SU", "SARITA", "RINA", "MILISSA", "MARIBETH", "GOLDA", "EVON", "ETHELYN", "ENEDINA", "CHERISE",
	"CHANA", "VELVA", "TAWANNA", "SADE", "MIRTA", "LI", "KARIE", "JACINTA", "ELNA", "DAVINA",
	"CIERRA", "ASHLIE", "ALBERTHA", "TANESHA", "STEPHANI", "NELLE", "MINDI", "LU", "LORINDA", "LARUE",
	"FLORENE", "DEMETRA", "DEDRA", "CIARA", "CHANTELLE", "ASHLY", "SUZY", "ROSALVA", "NOELIA", "LYDA",
	"LEATHA", "KRYSTYNA", "KRISTAN", "KARRI", "DARLINE", "DARCIE", "CINDA", "CHEYENNE", "CHERRIE", "AWILDA",
	"ALMEDA", "ROLANDA", "LANETTE", "JERILYN", "GISELE", "EVALYN", "CYNDI", "CLETA", "CARIN", "ZINA",
	"ZENA", "VELIA", "TANIKA", "PAUL", "CHARISSA", "THOMAS", "TALIA", "MARGARETE", "LAVONDA", "KAYLEE",
	"KATHLENE", "JONNA", "IRENA", "ILONA", "IDALIA", "CANDIS", "CANDANCE", "BRANDEE", "ANITRA", "ALIDA",
	"SIGRID", "NICOLETTE", "MARYJO", "LINETTE", "HEDWIG", "CHRISTIANA", "CASSIDY", "ALEXIA", "TRESSIE", "MODESTA",
	"LUPITA", "LITA", "GLADIS", "EVELIA", "DAVIDA", "CHERRI", "CECILY", "ASHELY", "ANNABEL", "AGUSTINA",
	"WANITA", "SHIRLY", "ROSAURA", "HULDA", "EUN", "BAILEY", "YETTA", "VERONA", "THOMASINA", "SIBYL",
	"SHANNAN", "MECHELLE", "LUE", "LEANDRA", "LANI", "KYLEE", "KANDY", "JOLYNN", "FERNE", "EBONI",
	"CORENE", "ALYSIA", "ZULA", "NADA", "MOIRA", "LYNDSAY", "LORRETTA", "JUAN", "JAMMIE", "HORTENSIA",
	"GAYNELL", "CAMERON", "ADRIA", "VINA", "VICENTA", "TANGELA", "STEPHINE", "NORINE", "NELLA", "LIANA",
	"LESLEE", "KIMBERELY", "ILIANA", "GLORY", "FELICA", "EMOGENE", "ELFRIEDE", "EDEN", "EARTHA", "CARMA",
	"BEA", "OCIE", "MARRY", "LENNIE", "KIARA", "JACALYN", "CARLOTA", "ARIELLE", "YU", "STAR",
	"OTILIA", "KIRSTIN", "KACEY", "JOHNETTA", "JOEY", "JOETTA", "JERALDINE", "JAUNITA", "ELANA", "DORTHEA",
	"CAMI", "AMADA", "ADELIA", "VERNITA", "TAMAR", "SIOBHAN", "RENEA", "RASHIDA", "OUIDA", "ODELL",
	"NILSA", "MERYL", "KRISTYN", "JULIETA", "DANICA", "BREANNE", "AUREA", "ANGLEA", "SHERRON", "ODETTE",
	"MALIA", "LORELEI", "LIN", "LEESA", "KENNA", "KATHLYN", "FIONA", "CHARLETTE", "SUZIE", "SHANTELL",
	"SABRA", "RACQUEL", "MYONG", "MIRA", "MARTINE", "LUCIENNE", "LAVADA", "JULIANN", "JOHNIE", "ELVERA",
	"DELPHIA", "CLAIR", "CHRISTIANE", "CHAROLETTE", "CARRI", "AUGUSTINE", "ASHA", "ANGELLA", "PAOLA", "NINFA",
	"LEDA", "LAI", "EDA", "SUNSHINE", "STEFANI", "SHANELL", "PALMA", "MACHELLE", "LISSA", "KECIA",
	"KATHRYNE", "KARLENE", "JULISSA", "JETTIE", "JENNIFFER", "HUI", "CORRINA", "CHRISTOPHER", "CAROLANN", "ALENA",
	"TESS", "ROSARIA", "MYRTICE", "MARYLEE", "LIANE", "KENYATTA", "JUDIE", "JANEY", "IN", "ELMIRA",
	"ELDORA", "DENNA", "CRISTI", "CATHI", "ZAIDA", "VONNIE", "VIVA", "VERNIE", "ROSALINE", "MARIELA",
	"LUCIANA", "LESLI", "KARAN", "FELICE", "DENEEN", "ADINA", "WYNONA", "TARSHA", "SHERON", "SHASTA",
	"SHANITA", "SHANI", "SHANDRA", "RANDA", "PINKIE", "PARIS", "NELIDA", "MARILOU", "LYLA", "LAURENE",
	"LACI", "JOI", "JANENE", "DOROTHA", "DANIELE", "DANI", "CAROLYNN", "CARLYN", "BERENICE", "AYESHA",
	"ANNELIESE", "ALETHEA", "THERSA", "TAMIKO", "RUFINA", "OLIVA", "MOZELL", "MARYLYN", "MADISON", "KRISTIAN",
	"KATHYRN", "KASANDRA", "KANDACE", "JANAE", "GABRIEL", "DOMENICA", "DEBBRA", "DANNIELLE", "CHUN", "BUFFY",
	"BARBIE", "ARCELIA", "AJA", "ZENOBIA", "SHAREN", "SHAREE", "PATRICK", "PAGE", "MY", "LAVINIA",
	"KUM", "KACIE", "JACKELINE", "HUONG", "FELISA", "EMELIA", "ELEANORA", "CYTHIA", "CRISTIN", "CLYDE",
	"CLARIBEL", "CARON", "ANASTACIA", "ZULMA", "ZANDRA", "YOKO", "TENISHA", "SUSANN", "SHERILYN", "SHAY",
	"SHAWANDA", "SABINE", "ROMANA", "MATHILDA", "LINSEY", "KEIKO", "JOANA", "ISELA", "GRETTA", "GEORGETTA",
	"EUGENIE", "DUSTY", "DESIRAE", "DELORA", "CORAZON", "ANTONINA", "ANIKA", "WILLENE", "TRACEE", "TAMATHA",
	"REGAN", "NICHELLE", "MICKIE", "MAEGAN", "LUANA", "LANITA", "KELSIE", "EDELMIRA", "BREE", "AFTON",
	"TEODORA", "TAMIE", "SHENA", "MEG", "LINH", "KELI", "KACI", "DANYELLE", "BRITT", "ARLETTE",
	"ALBERTINE", "ADELLE", "TIFFINY", "STORMY", "SIMONA", "NUMBERS", "NICOLASA", "NICHOL", "NIA", "NAKISHA",
	"MEE", "MAIRA", "LOREEN", "KIZZY", "JOHNNY", "JAY", "FALLON", "CHRISTENE", "BOBBYE", "ANTHONY",
	"YING", "VINCENZA", "TANJA", "RUBIE", "RONI", "QUEENIE", "MARGARETT", "KIMBERLI", "IRMGARD", "IDELL",
	"HILMA", "EVELINA", "ESTA", "EMILEE", "DENNISE", "DANIA", "CARL", "CARIE", "ANTONIO", "WAI",
	"SANG", "RISA", "RIKKI", "PARTICIA", "MUI", "MASAKO", "MARIO", "LUVENIA", "LOREE", "LONI",
	"LIEN", "KEVIN", "GIGI", "FLORENCIA", "DORIAN", "DENITA", "DALLAS", "CHI", "BILLYE", "ALEXANDER",
	"TOMIKA", "SHARITA", "RANA", "NIKOLE", "NEOMA", "MARGARITE", "MADALYN", "LUCINA", "LAILA", "KALI",
	"JENETTE", "GABRIELE", "EVELYNE", "ELENORA", "CLEMENTINA", "ALEJANDRINA", "ZULEMA", "VIOLETTE", "VANNESSA", "THRESA",
	"RETTA", "PIA", "PATIENCE", "NOELLA", "NICKIE", "JONELL", "DELTA", "CHUNG", "CHAYA", "CAMELIA",
	"BETHEL", "ANYA", "ANDREW", "THANH", "SUZANN", "SPRING", "SHU", "MILA", "LILLA", "LAVERNA",
	"KEESHA", "KATTIE", "GIA", "GEORGENE", "EVELINE", "ESTELL", "ELIZBETH", "VIVIENNE", "VALLIE", "TRUDIE",
	"STEPHANE", "MICHEL", "MAGALY", "MADIE", "KENYETTA", "KARREN", "JANETTA", "HERMINE", "HARMONY", "DRUCILLA",
	"DEBBI", "CELESTINA", "CANDIE", "BRITNI", "BECKIE", "AMINA", "ZITA", "YUN", "YOLANDE", "VIVIEN",
	"VERNETTA", "TRUDI", "SOMMER", "PEARLE", "PATRINA", "OSSIE", "NICOLLE", "LOYCE", "LETTY", "LARISA",
	"KATHARINA", "JOSELYN", "JONELLE", "JENELL", "IESHA", "HEIDE", "FLORINDA", "FLORENTINA", "FLO", "ELODIA",
	"DORINE", "BRUNILDA", "BRIGID", "ASHLI", "ARDELLA", "TWANA", "THU", "TARAH", "SUNG", "SHEA",
	"SHAVON", "SHANE", "SERINA", "RAYNA", "RAMONITA", "NGA", "MARGURITE", "LUCRECIA", "KOURTNEY", "KATI",
	"JESUS", "JESENIA", "DIAMOND", "CRISTA", "AYANA", "ALICA", "ALIA", "VINNIE", "SUELLEN", "ROMELIA",
	"RACHELL", "PIPER", "OLYMPIA", "MICHIKO", "KATHALEEN", "JOLIE", "JESSI", "JANESSA", "HANA", "HA",
	"ELEASE", "CARLETTA", "BRITANY", "SHONA", "SALOME", "ROSAMOND", "REGENA", "RAINA", "NGOC", "NELIA",
	"LOUVENIA", "LESIA", "LATRINA", "LATICIA", "LARHONDA", "JINA", "JACKI", "HOLLIS", "HOLLEY", "EMMY",
	"DEEANN", "CORETTA", "ARNETTA", "VELVET", "THALIA", "SHANICE", "NETA", "MIKKI", "MICKI", "LONNA",
	"LEANA", "LASHUNDA", "KILEY", "JOYE", "JACQULYN", "IGNACIA", "HYUN", "HIROKO", "HENRY", "HENRIETTE",
	"ELAYNE", "DELINDA", "DARNELL", "DAHLIA", "COREEN", "CONSUELA", "CONCHITA", "CELINE", "BABETTE", "AYANNA",
	"ANETTE", "ALBERTINA", "SKYE", "SHAWNEE", "SHANEKA", "QUIANA", "PAMELIA", "MIN", "MERRI", "MERLENE",
	"MARGIT", "KIESHA", "KIERA", "KAYLENE", "JODEE", "JENISE", "ERLENE", "EMMIE", "ELSE", "DARYL",
	"DALILA", "DAISEY", "CODY", "CASIE", "BELIA", "BABARA", "VERSIE", "VANESA", "SHELBA", "SHAWNDA",
	"SAM", "NORMAN", "NIKIA", "NAOMA", "MARNA", "MARGERET", "MADALINE", "LAWANA", "KINDRA", "JUTTA",
	"JAZMINE", "JANETT", "HANNELORE", "GLENDORA", "GERTRUD", "GARNETT", "FREEDA", "FREDERICA", "FLORANCE", "FLAVIA",
	"DENNIS", "CARLINE", "BEVERLEE", "ANJANETTE", "VALDA", "TRINITY", "TAMALA", "STEVIE", "SHONNA", "SHA",
	"SARINA", "ONEIDA", "MICAH", "MERILYN", "MARLEEN", "LURLINE", "LENNA", "KATHERIN", "JIN", "JENI",
	"HAE", "GRACIA", "GLADY", "FARAH", "ERIC", "ENOLA", "EMA", "DOMINQUE", "DEVONA", "DELANA",
	"CECILA", "CAPRICE", "ALYSHA", "ALI", "ALETHIA", "VENA", "THERESIA", "TAWNY", "SONG", "SHAKIRA",
	"SAMARA", "SACHIKO", "RACHELE", "PAMELLA", "NICKY", "MARNI", "MARIEL", "MAREN", "MALISA", "LIGIA",
	"LERA", "LATORIA", "LARAE", "KIMBER", "KATHERN", "KAREY", "JENNEFER", "JANETH", "HALINA", "FREDIA",
	"DELISA", "DEBROAH", "CIERA", "CHIN", "ANGELIKA", "ANDREE", "ALTHA", "YEN", "VIVAN", "TERRESA",
	"TANNA", "SUK", "SUDIE", "SOO", "SIGNE", "SALENA", "RONNI", "REBBECCA", "MYRTIE", "MCKENZIE",
	"MALIKA", "MAIDA", "LOAN", "LEONARDA", "KAYLEIGH", "FRANCE", "ETHYL", "ELLYN", "DAYLE", "CAMMIE",
	"BRITTNI", "BIRGIT", "AVELINA", "ASUNCION", "ARIANNA", "AKIKO", "VENICE", "TYESHA", "TONIE", "TIESHA",
	"TAKISHA", "STEFFANIE", "SINDY", "SANTANA", "MEGHANN", "MANDA", "MACIE", "LADY", "KELLYE", "KELLEE",
	"JOSLYN", "JASON", "INGER", "INDIRA", "GLINDA", "GLENNIS", "FERNANDA", "FAUSTINA", "ENEIDA", "ELICIA",
	"DOT", "DIGNA", "DELL", "ARLETTA", "ANDRE", "WILLIA", "TAMMARA", "TABETHA", "SHERRELL", "SARI",
	"REFUGIO", "REBBECA", "PAULETTA", "NIEVES", "NATOSHA", "NAKITA", "MAMMIE", "KENISHA", "KAZUKO", "KASSIE",
	"GARY", "EARLEAN", "DAPHINE", "CORLISS", "CLOTILDE", "CAROLYNE", "BERNETTA", "AUGUSTINA", "AUDREA", "ANNIS",
	"ANNABELL", "YAN", "TENNILLE", "TAMICA", "SELENE", "SEAN", "ROSANA", "REGENIA", "QIANA", "MARKITA",
	"MACY", "LEEANNE", "LAURINE", "KYM", "JESSENIA", "JANITA", "GEORGINE", "GENIE", "EMIKO", "ELVIE",
	"DEANDRA", "DAGMAR", "CORIE", "COLLEN", "CHERISH", "ROMAINE", "PORSHA", "PEARLENE", "MICHELINE", "MERNA",
	"MARGORIE", "MARGARETTA", "LORE", "KENNETH", "JENINE", "HERMINA", "FREDERICKA", "ELKE", "DRUSILLA", "DORATHY",
	"DIONE", "DESIRE", "CELENA", "BRIGIDA", "ANGELES", "ALLEGRA", "THEO", "TAMEKIA", "SYNTHIA", "STEPHEN",
	"SOOK", "SLYVIA", "ROSANN", "REATHA", "RAYE", "MARQUETTA", "MARGART", "LING", "LAYLA", "KYMBERLY",
	"KIANA", "KAYLEEN", "KATLYN", "KARMEN", "JOELLA", "IRINA", "EMELDA", "ELENI", "DETRA", "CLEMMIE",
	"CHERYLL", "CHANTELL", "CATHEY", "ARNITA", "ARLA", "ANGLE", "ANGELIC", "ALYSE", "ZOFIA", "THOMASINE",
	"TENNIE", "SON", "SHERLY", "SHERLEY", "SHARYL", "REMEDIOS", "PETRINA", "NICKOLE", "MYUNG", "MYRLE",
	"MOZELLA", "LOUANNE", "LISHA", "LATIA", "LANE", "KRYSTA", "JULIENNE", "JOEL", "JEANENE", "JACQUALINE",
	"ISAURA", "GWENDA", "EARLEEN", "DONALD", "CLEOPATRA", "CARLIE", "AUDIE", "ANTONIETTA", "ALISE", "ALEX",
	"VERDELL", "VAL", "TYLER", "TOMOKO", "THAO", "TALISHA", "STEVEN", "SO", "SHEMIKA", "SHAUN",
	"SCARLET", "SAVANNA", "SANTINA", "ROSIA", "RAEANN", "ODILIA", "NANA", "MINNA", "MAGAN", "LYNELLE",
	"LE", "KARMA", "JOEANN", "IVANA", "INELL", "ILANA", "HYE", "HONEY", "HEE", "GUDRUN",
	"FRANK", "DREAMA", "CRISSY", "CHANTE", "CARMELINA", "ARVILLA", "ARTHUR", "ANNAMAE", "ALVERA", "ALEIDA",
	"AARON", "YEE", "YANIRA", "VANDA", "TIANNA", "TAM", "STEFANIA", "SHIRA", "PERRY", "NICOL",
	"NANCIE", "MONSERRATE", "MINH", "MELYNDA", "MELANY", "MATTHEW", "LOVELLA", "LAURE", "KIRBY", "KACY",
	"JACQUELYNN", "HYON", "GERTHA", "FRANCISCO", "ELIANA", "CHRISTENA", "CHRISTEEN", "CHARISE", "CATERINA", "CARLEY",
	"CANDYCE", "ARLENA", "AMMIE", "YANG", "WILLETTE", "VANITA", "TUYET", "TINY", "SYREETA", "SILVA",
	"SCOTT", "RONALD", "PENNEY", "NYLA", "MICHAL", "MAURICE", "MARYAM", "MARYA", "MAGEN", "LUDIE",
	"LOMA", "LIVIA", "LANELL", "KIMBERLIE", "JULEE", "DONETTA", "DIEDRA", "DENISHA", "DEANE", "DAWNE",
	"CLARINE", "CHERRYL", "BRONWYN", "BRANDON", "ALLA", "VALERY", "TONDA", "SUEANN", "SORAYA", "SHOSHANA",
	"SHELA", "SHARLEEN", "SHANELLE", "NERISSA", "MICHEAL", "MERIDITH", "MELLIE", "MAYE", "MAPLE", "MAGARET",
	"LUIS", "LILI", "LEONILA", "LEONIE", "LEEANNA", "LAVONIA", "LAVERA", "KRISTEL", "KATHEY", "KATHE",
	"JUSTIN", "JULIAN", "JIMMY", "JANN", "ILDA", "HILDRED", "HILDEGARDE", "GENIA", "FUMIKO", "EVELIN",
	"ERMELINDA", "ELLY", "DUNG", "DOLORIS", "DIONNA", "DANAE", "BERNEICE", "ANNICE", "ALIX", "VERENA",
	"VERDIE", "TRISTAN", "SHAWNNA", "SHAWANA", "SHAUNNA", "ROZELLA", "RANDEE", "RANAE", "MILAGRO", "LYNELL",
	"LUISE", "LOUIE", "LOIDA", "LISBETH", "KARLEEN", "JUNITA", "JONA", "ISIS", "HYACINTH", "HEDY",
	"GWENN", "ETHELENE", "ERLINE", "EDWARD", "DONYA", "DOMONIQUE", "DELICIA", "DANNETTE", "CICELY", "BRANDA",
	"BLYTHE", "BETHANN", "ASHLYN", "ANNALEE", "ALLINE", "YUKO", "VELLA", "TRANG", "TOWANDA", "TESHA",
	"SHERLYN", "NARCISA", "MIGUELINA", "MERI", "MAYBELL", "MARLANA", "MARGUERITA", "MADLYN", "LUNA", "LORY",
	"LORIANN", "LIBERTY", "LEONORE", "LEIGHANN", "LAURICE", "LATESHA", "LARONDA", "KATRICE", "KASIE", "KARL",
	"KALEY", "JADWIGA", "GLENNIE", "GEARLDINE", "FRANCINA", "EPIFANIA", "DYAN", "DORIE", "DIEDRE", "DENESE",
	"DEMETRICE", "DELENA", "DARBY", "CRISTIE", "CLEORA", "CATARINA", "CARISA", "BERNIE", "BARBERA", "ALMETA",
	"TRULA", "TEREASA", "SOLANGE", "SHEILAH", "SHAVONNE", "SANORA", "ROCHELL", "MATHILDE", "MARGARETA", "MAIA",
	"LYNSEY", "LAWANNA", "LAUNA", "KENA", "KEENA", "KATIA", "JAMEY", "GLYNDA", "GAYLENE", "ELVINA",
	"ELANOR", "DANUTA", "DANIKA", "CRISTEN", "CORDIE", "COLETTA", "CLARITA", "CARMON", "BRYNN", "AZUCENA",
	"AUNDREA", "ANGELE", "YI", "WALTER", "VERLIE", "VERLENE", "TAMESHA", "SILVANA", "SEBRINA", "SAMIRA",
	"REDA", "RAYLENE", "PENNI", "PANDORA", "NORAH", "NOMA", "MIREILLE", "MELISSIA", "MARYALICE", "LARAINE",
	"KIMBERY", "KARYL", "KARINE", "KAM", "JOLANDA", "JOHANA", "JESUSA", "JALEESA", "JAE", "JACQUELYNE",
	"IRISH", "ILUMINADA", "HILARIA", "HANH", "GENNIE", "FRANCIE", "FLORETTA", "EXIE", "EDDA", "DREMA",
	"DELPHA", "BEV", "BARBAR", "ASSUNTA", "ARDELL", "ANNALISA", "ALISIA", "YUKIKO", "YOLANDO", "WONDA",
	"WEI", "WALTRAUD", "VETA", "TEQUILA", "TEMEKA", "TAMEIKA", "SHIRLEEN", "SHENITA", "PIEDAD", "OZELLA",
	"MIRTHA", "MARILU", "KIMIKO", "JULIANE", "JENICE", "JEN", "JANAY", "JACQUILINE", "HILDE", "FE",
	"FAE", "EVAN", "EUGENE", "ELOIS", "ECHO", "DEVORAH", "CHAU", "BRINDA", "BETSEY", "ARMINDA",
	"ARACELIS", "APRYL", "ANNETT", "ALISHIA", "VEOLA", "USHA", "TOSHIKO", "THEOLA", "TASHIA", "TALITHA",
	"SHERY", "RUDY", "RENETTA", "REIKO", "RASHEEDA", "OMEGA", "OBDULIA", "MIKA", "MELAINE", "MEGGAN",
	"MARTIN", "MARLEN", "MARGET", "MARCELINE", "MANA", "MAGDALEN", "LIBRADA", "LEZLIE", "LEXIE", "LATASHIA",
	"LASANDRA", "KELLE", "ISIDRA", "ISA", "INOCENCIA", "GWYN", "FRANCOISE", "ERMINIA", "ERINN", "DIMPLE",
	"DEVORA", "CRISELDA", "ARMANDA", "ARIE", "ARIANE", "ANGELO", "ANGELENA", "ALLEN", "ALIZA", "ADRIENE",
	"ADALINE", "XOCHITL", "TWANNA", "TRAN", "TOMIKO", "TAMISHA", "TAISHA", "SUSY", "SIU", "RUTHA",
	"ROXY", "RHONA", "RAYMOND", "OTHA", "NORIKO", "NATASHIA", "MERRIE", "MELVIN", "MARINDA", "MARIKO",
	"MARGERT", "LORIS", "LIZZETTE", "LEISHA", "KAILA", "KA", "JOANNIE", "JERRICA", "JENE", "JANNET",
	"JANEE", "JACINDA", "HERTA", "ELENORE", "DORETTA", "DELAINE", "DANIELL", "CLAUDIE", "CHINA", "BRITTA",
	"APOLONIA", "AMBERLY", "ALEASE", "YURI", "YUK", "WEN", "WANETA", "UTE", "TOMI", "SHARRI",
	"SANDIE", "ROSELLE", "REYNALDA", "RAGUEL", "PHYLICIA", "PATRIA", "OLIMPIA", "ODELIA", "MITZIE", "MITCHELL",
	"MISS", "MINDA", "MIGNON", "MICA", "MENDY", "MARIVEL", "MAILE", "LYNETTA", "LAVETTE", "LAURYN",
	"LATRISHA", "LAKIESHA", "KIERSTEN", "KARY", "JOSPHINE", "JOLYN", "JETTA", "JANISE", "JACQUIE", "IVELISSE",
	"GLYNIS", "GIANNA", "GAYNELLE", "EMERALD", "DEMETRIUS", "DANYELL", "DANILLE", "DACIA", "CORALEE", "CHER",
	"CEOLA", "BRETT", "BELL", "ARIANNE", "ALESHIA", "YUNG", "WILLIEMAE", "TROY", "TRINH", "THORA",
	"TAI", "SVETLANA", "SHERIKA", "SHEMEKA", "SHAUNDA", "ROSELINE", "RICKI", "MELDA", "MALLIE", "LAVONNA",
	"LATINA", "LARRY", "LAQUANDA", "LALA", "LACHELLE", "KLARA", "KANDIS", "JOHNA", "JEANMARIE", "JAYE",
	"HANG", "GRAYCE", "GERTUDE", "EMERITA", "EBONIE", "CLORINDA", "CHING", "CHERY", "CAROLA", "BREANN",
	"BLOSSOM", "BERNARDINE", "BECKI", "ARLETHA", "ARGELIA", "ARA", "ALITA", "YULANDA", "YON", "YESSENIA",
	"TOBI", "TASIA", "SYLVIE", "SHIRL", "SHIRELY", "SHERIDAN", "SHELLA", "SHANTELLE", "SACHA", "ROYCE",
	"REBECKA", "REAGAN", "PROVIDENCIA", "PAULENE", "MISHA", "MIKI", "MARLINE", "MARICA", "LORITA", "LATOYIA",
	"LASONYA", "KERSTIN", "KENDA", "KEITHA", "KATHRIN", "JAYMIE", "JACK", "GRICELDA", "GINETTE", "ERYN",
	"ELINA", "ELFRIEDA", "DANYEL", "CHEREE", "CHANELLE", "BARRIE", "AVERY", "AURORE", "ANNAMARIA", "ALLEEN",
	"AILENE", "AIDE", "YASMINE", "VASHTI", "VALENTINE", "TREASA", "TORY", "TIFFANEY", "SHERYLL", "SHARIE",
	"SHANAE", "SAU", "RAISA", "PA", "NEDA", "MITSUKO", "MIRELLA", "MILDA", "MARYANNA", "MARAGRET",
	"MABELLE", "LUETTA", "LORINA", "LETISHA", "LATARSHA", "LANELLE", "LAJUANA", "KRISSY", "KARLY", "KARENA",
	"JON", "JESSIKA", "JERICA", "JEANELLE", "JANUARY", "JALISA", "JACELYN", "IZOLA", "IVEY", "GREGORY",
	"EUNA", "ETHA", "DREW", "DOMITILA", "DOMINICA", "DAINA", "CREOLA", "CARLI", "CAMIE", "BUNNY",
	"BRITTNY", "ASHANTI", "ANISHA", "ALEEN", "ADAH", "YASUKO", "WINTER", "VIKI", "VALRIE", "TONA",
	"TINISHA", "THI", "TERISA", "TATUM", "TANEKA", "SIMONNE", "SHALANDA", "SERITA", "RESSIE", "REFUGIA",
	"PAZ", "OLENE", "NA", "MERRILL", "MARGHERITA", "MANDIE", "MAN", "MAIRE", "LYNDIA", "LUCI",
	"LORRIANE", "LORETA", "LEONIA", "LAVONA", "LASHAWNDA", "LAKIA", "KYOKO", "KRYSTINA", "KRYSTEN", "KENIA",
	"KELSI", "JUDE", "JEANICE", "ISOBEL", "GEORGIANN", "GENNY", "FELICIDAD", "EILENE", "DEON", "DELOISE",
	"DEEDEE", "DANNIE", "CONCEPTION", "CLORA", "CHERILYN", "CHANG", "CALANDRA", "BERRY", "ARMANDINA", "ANISA",
	"ULA", "TIMOTHY", "TIERA", "THERESSA", "STEPHANIA", "SIMA", "SHYLA", "SHONTA", "SHERA", "SHAQUITA",
	"SHALA", "SAMMY", "ROSSANA", "NOHEMI", "NERY", "MORIAH", "MELITA", "MELIDA", "MELANI", "MARYLYNN",
	"MARISHA", "MARIETTE", "MALORIE", "MADELENE", "LUDIVINA", "LORIA", "LORETTE", "LORALEE", "LIANNE", "LEON",
	"LAVENIA", "LAURINDA", "LASHON", "KIT", "KIMI", "KEILA", "KATELYNN", "KAI", "JONE", "JOANE",
	"JI", "JAYNA", "JANELLA", "JA", "HUE", "HERTHA", "FRANCENE", "ELINORE", "DESPINA", "DELSIE",
	"DEEDRA", "CLEMENCIA", "CARRY", "CAROLIN", "CARLOS", "BULAH", "BRITTANIE", "BOK", "BLONDELL", "BIBI",
	"BEAULAH", "BEATA", "ANNITA", "AGRIPINA", "VIRGEN", "VALENE", "UN", "TWANDA", "TOMMYE", "TOI",
	"TARRA", "TARI", "TAMMERA", "SHAKIA", "SADYE", "RUTHANNE", "ROCHEL", "RIVKA", "PURA", "NENITA",
	"NATISHA", "MING", "MERRILEE", "MELODEE", "MARVIS", "LUCILLA", "LEENA", "LAVETA", "LARITA", "LANIE",
	"KEREN", "ILEEN", "GEORGEANN", "GENNA", "GENESIS", "FRIDA", "EWA", "EUFEMIA", "EMELY", "ELA",
	"EDYTH", "DEONNA", "DEADRA", "DARLENA", "CHANELL", "CHAN", "CATHERN", "CASSONDRA", "CASSAUNDRA", "BERNARDA",
	"BERNA", "ARLINDA", "ANAMARIA", "ALBERT", "WESLEY", "VERTIE", "VALERI", "TORRI", "TATYANA", "STASIA",
	"SHERISE", "SHERILL", "SEASON", "SCOTTIE", "SANDA", "RUTHE", "ROSY", "ROBERTO", "ROBBI", "RANEE",
	"QUYEN", "PEARLY", "PALMIRA", "ONITA", "NISHA", "NIESHA", "NIDA", "NEVADA", "NAM", "MERLYN",
	"MAYOLA", "MARYLOUISE", "MARYLAND", "MARX", "MARTH", "MARGENE", "MADELAINE", "LONDA", "LEONTINE", "LEOMA",
	"LEIA", "LAWRENCE", "LAURALEE", "LANORA", "LAKITA", "KIYOKO", "KETURAH", "KATELIN", "KAREEN", "JONIE",
	"JOHNETTE", "JENEE", "JEANETT", "IZETTA", "HIEDI", "HEIKE", "HASSIE", "HAROLD", "GIUSEPPINA", "GEORGANN",
	"FIDELA", "FERNANDE", "ELWANDA", "ELLAMAE", "ELIZ", "DUSTI", "DOTTY", "CYNDY", "CORALIE", "CELESTA",
	"ARGENTINA", "ALVERTA", "XENIA", "WAVA", "VANETTA", "TORRIE", "TASHINA", "TANDY", "TAMBRA", "TAMA",
	"STEPANIE", "SHILA", "SHAUNTA", "SHARAN", "SHANIQUA", "SHAE", "SETSUKO", "SERAFINA", "SANDEE", "ROSAMARIA",
	"PRISCILA", "OLINDA", "NADENE", "MUOI", "MICHELINA", "MERCEDEZ", "MARYROSE", "MARIN", "MARCENE", "MAO",
	"MAGALI", "MAFALDA", "LOGAN", "LINN", "LANNIE", "KAYCE", "KAROLINE", "KAMILAH", "KAMALA", "JUSTA",
	"JOLINE", "JENNINE", "JACQUETTA", "IRAIDA", "GERALD", "GEORGEANNA", "FRANCHESCA", "FAIRY", "EMELINE", "ELANE",
	"EHTEL", "EARLIE", "DULCIE", "DALENE", "CRIS", "CLASSIE", "CHERE", "CHARIS", "CAROYLN", "CARMINA",
	"CARITA", "BRIAN", "BETHANIE", "AYAKO", "ARICA", "AN", "ALYSA", "ALESSANDRA", "AKILAH", "ADRIEN",
	"ZETTA", "YOULANDA", "YELENA", "YAHAIRA", "XUAN", "WENDOLYN", "VICTOR", "TIJUANA", "TERRELL", "TERINA",
	"TERESIA", "SUZI", "SUNDAY", "SHERELL", "SHAVONDA", "SHAUNTE", "SHARDA", "SHAKITA", "SENA", "RYANN",
	"RUBI", "RIVA", "REGINIA", "REA", "RACHAL", "PARTHENIA", "PAMULA", "MONNIE", "MONET", "MICHAELE",
	"MELIA", "MARINE", "MALKA", "MAISHA", "LISANDRA", "LEO", "LEKISHA", "LEAN", "LAURENCE", "LAKENDRA",
	"KRYSTIN", "KORTNEY", "KIZZIE", "KITTIE", "KERA", "KENDAL", "KEMBERLY", "KANISHA", "JULENE", "JULE",
	"JOSHUA", "JOHANNE", "JEFFREY", "JAMEE", "HAN", "HALLEY", "GIDGET", "GALINA", "FREDRICKA", "FLETA",
	"FATIMAH", "EUSEBIA", "ELZA", "ELEONORE", "DORTHEY", "DORIA", "DONELLA", "DINORAH", "DELORSE", "CLARETHA",
	"CHRISTINIA", "CHARLYN", "BONG", "BELKIS", "AZZIE", "ANDERA", "AIKO", "ADENA", "YER", "YAJAIRA",
	"WAN", "VANIA", "ULRIKE", "TOSHIA", "TIFANY", "STEFANY", "SHIZUE", "SHENIKA", "SHAWANNA", "SHAROLYN",
	"SHARILYN", "SHAQUANA", "SHANTAY", "SEE", "ROZANNE", "ROSELEE", "RICKIE", "REMONA", "REANNA", "RAELENE",
	"QUINN", "PHUNG", "PETRONILA", "NATACHA", "NANCEY", "MYRL", "MIYOKO", "MIESHA", "MERIDETH", "MARVELLA",
	"MARQUITTA", "MARHTA", "MARCHELLE", "LIZETH", "LIBBIE", "LAHOMA", "LADAWN", "KINA", "KATHELEEN", "KATHARYN",
	"KARISA", "KALEIGH", "JUNIE", "JULIEANN", "JOHNSIE", "JANEAN", "JAIMEE", "JACKQUELINE", "HISAKO", "HERMA",
	"HELAINE", "GWYNETH", "GLENN", "GITA", "EUSTOLIA", "EMELINA", "ELIN", "EDRIS", "DONNETTE", "DONNETTA",
	"DIERDRE", "DENAE", "DARCEL", "CLAUDE", "CLARISA", "CINDERELLA", "CHIA", "CHARLESETTA", "CHARITA", "CELSA",
	"CASSY", "CASSI", "CARLEE", "BRUNA", "BRITTANEY", "BRANDE", "BILLI", "BAO", "ANTONETTA", "ANGLA",
	"ANGELYN", "ANALISA", "ALANE", "WENONA", "WENDIE", "VERONIQUE", "VANNESA", "TOBIE", "TEMPIE", "SUMIKO",
	"SULEMA", "SPARKLE", "SOMER", "SHEBA", "SHAYNE", "SHARICE", "SHANEL", "SHALON", "SAGE", "ROY",
	"ROSIO", "ROSELIA", "RENAY", "REMA", "REENA", "PORSCHE", "PING", "PEG", "OZIE", "ORETHA",
	"ORALEE", "ODA", "NU", "NGAN", "NAKESHA", "MILLY", "MARYBELLE", "MARLIN", "MARIS", "MARGRETT",
	"MARAGARET", "MANIE", "LURLENE", "LILLIA", "LIESELOTTE", "LAVELLE", "LASHAUNDA", "LAKEESHA", "KEITH", "KAYCEE",
	"KALYN", "JOYA", "JOETTE", "JENAE", "JANIECE", "ILLA", "GRISEL", "GLAYDS", "GENEVIE", "GALA",
	"FREDDA", "FRED", "ELMER", "ELEONOR", "DEBERA", "DEANDREA", "DAN", "CORRINNE", "CORDIA", "CONTESSA",
	"COLENE", "CLEOTILDE", "CHARLOTT", "CHANTAY", "CECILLE", "BEATRIS", "AZALEE", "ARLEAN", "ARDATH", "ANJELICA",
	"ANJA", "ALFREDIA", "ALEISHA", "ADAM", "ZADA", "YUONNE", "XIAO", "WILLODEAN", "WHITLEY", "VENNIE",
	"VANNA", "TYISHA", "TOVA", "TORIE", "TONISHA", "TILDA", "TIEN", "TEMPLE", "SIRENA", "SHERRIL",
	"SHANTI", "SHAN", "SENAIDA", "SAMELLA", "ROBBYN", "RENDA", "REITA", "PHEBE", "PAULITA", "NOBUKO",
	"NGUYET", "NEOMI", "MOON", "MIKAELA", "MELANIA", "MAXIMINA", "MARG", "MAISIE", "LYNNA", "LILLI",
	"LAYNE", "LASHAUN", "LAKENYA", "LAEL", "KIRSTIE", "KATHLINE", "KASHA", "KARLYN", "KARIMA", "JOVAN",
	"JOSEFINE", "JENNELL", "JACQUI", "JACKELYN", "HYO", "HIEN", "GRAZYNA", "FLORRIE", "FLORIA", "ELEONORA",
	"DWANA", "DORLA", "DONG", "DELMY", "DEJA", "DEDE", "DANN", "CRYSTA", "CLELIA", "CLARIS",
	"CLARENCE", "CHIEKO", "CHERLYN", "CHERELLE", "CHARMAIN", "CHARA", "CAMMY", "BEE", "ARNETTE", "ARDELLE",
	"ANNIKA", "AMIEE", "AMEE", "ALLENA", "YVONE", "YUKI", "YOSHIE", "YEVETTE", "YAEL", "WILLETTA",
	"VONCILE", "VENETTA", "TULA", "TONETTE", "TIMIKA", "TEMIKA", "TELMA", "TEISHA", "TAREN", "TA",
	"STACEE", "SHIN", "SHAWNTA", "SATURNINA", "RICARDA", "POK", "PASTY", "ONIE", "NUBIA", "MORA",
	"MIKE", "MARIELLE", "MARIELLA", "MARIANELA", "MARDELL", "MANY", "LUANNA", "LOISE", "LISABETH", "LINDSY",
	"LILLIANA", "LILLIAM", "LELAH", "LEIGHA", "LEANORA", "LANG", "KRISTEEN", "KHALILAH", "KEELEY", "KANDRA",
	"JUNKO", "JOAQUINA", "JERLENE", "JANI", "JAMIKA", "JAME", "HSIU", "HERMILA", "GOLDEN", "GENEVIVE",
	"EVIA", "EUGENA", "EMMALINE", "ELFREDA", "ELENE", "DONETTE", "DELCIE", "DEEANNA", "DARCEY", "CUC",
	"CLARINDA", "CIRA", "CHAE", "CELINDA", "CATHERYN", "CATHERIN", "CASIMIRA", "CARMELIA", "CAMELLIA", "BREANA",
	"BOBETTE", "BERNARDINA", "BEBE", "BASILIA", "ARLYNE", "AMAL", "ALAYNA", "ZONIA", "ZENIA", "YURIKO",
	"YAEKO", "WYNELL", "WILLOW", "WILLENA", "VERNIA", "TU", "TRAVIS", "TORA", "TERRILYN", "TERICA",
	"TENESHA", "TAWNA", "TAJUANA", "TAINA", "STEPHNIE", "SONA", "SOL", "SINA", "SHONDRA", "SHIZUKO",
	"SHERLENE", "SHERICE", "SHARIKA", "ROSSIE", "ROSENA", "RORY", "RIMA", "RIA", "RHEBA", "RENNA",
	"PETER", "NATALYA", "NANCEE", "MELODI", "MEDA", "MAXIMA", "MATHA", "MARKETTA", "MARICRUZ", "MARCELENE",
	"MALVINA", "LUBA", "LOUETTA", "LEIDA", "LECIA", "LAURAN", "LASHAWNA", "LAINE", "KHADIJAH", "KATERINE",
	"KASI", "KALLIE", "JULIETTA", "JESUSITA", "JESTINE", "JESSIA", "JEREMY", "JEFFIE", "JANYCE", "ISADORA",
	"GEORGIANNE", "FIDELIA", "EVITA", "EURA", "EULAH", "ESTEFANA", "ELSY", "ELIZABET", "ELADIA", "DODIE",
	"DION", "DIA", "DENISSE", "DELORAS", "DELILA", "DAYSI", "DAKOTA", "CURTIS", "CRYSTLE", "CONCHA",
	"COLBY", "CLARETTA", "CHU", "CHRISTIA", "CHARLSIE", "CHARLENA", "CARYLON", "BETTYANN", "ASLEY", "ASHLEA",
	"AMIRA", "AI", "AGUEDA", "AGNUS", "YUETTE", "VINITA", "VICTORINA", "TYNISHA", "TREENA", "TOCCARA",
	"TISH", "THOMASENA", "TEGAN", "SOILA", "SHILOH", "SHENNA", "SHARMAINE", "SHANTAE", "SHANDI", "SEPTEMBER",
	"SARAN", "SARAI", "SANA", "SAMUEL", "SALLEY", "ROSETTE", "ROLANDE", "REGINE", "OTELIA", "OSCAR",
	"OLEVIA", "NICHOLLE", "NECOLE", "NAIDA", "MYRTA", "MYESHA", "MITSUE", "MINTA", "MERTIE", "MARGY",
	"MAHALIA", "MADALENE", "LOVE", "LOURA", "LOREAN", "LEWIS", "LESHA", "LEONIDA", "LENITA", "LAVONE",
	"LASHELL", "LASHANDRA", "LAMONICA", "KIMBRA", "KATHERINA", "KARRY", "KANESHA", "JULIO", "JONG", "JENEVA",
	"JAQUELYN", "HWA", "GILMA", "GHISLAINE", "GERTRUDIS", "FRANSISCA", "FERMINA", "ETTIE", "ETSUKO", "ELLIS",
	"ELLAN", "ELIDIA", "EDRA", "DORETHEA", "DOREATHA", "DENYSE", "DENNY", "DEETTA", "DAINE", "CYRSTAL",
	"CORRIN", "CAYLA", "CARLITA", "CAMILA", "BURMA", "BULA", "BUENA", "BLAKE", "BARABARA", "AVRIL",
	"AUSTIN", "ALAINE", "ZANA", "WILHEMINA", "WANETTA", "VIRGIL", "VI", "VERONIKA", "VERNON", "VERLINE",
	"VASILIKI", "TONITA", "TISA", "TEOFILA", "TAYNA", "TAUNYA", "TANDRA", "TAKAKO", "SUNNI", "SUANNE",
	"SIXTA", "SHARELL", "SEEMA", "RUSSELL", "ROSENDA", "ROBENA", "RAYMONDE", "PEI", "PAMILA", "OZELL",
	"NEIDA", "NEELY", "MISTIE", "MICHA", "MERISSA", "MAURITA", "MARYLN", "MARYETTA", "MARSHALL", "MARCELL",
	"MALENA", "MAKEDA", "MADDIE", "LOVETTA", "LOURIE", "LORRINE", "LORILEE", "LESTER", "LAURENA", "LASHAY",
	"LARRAINE", "LAREE", "LACRESHA", "KRISTLE", "KRISHNA", "KEVA", "KEIRA", "KAROLE", "JOIE", "JINNY",
	"JEANNETTA", "JAMA", "HEIDY", "GILBERTE", "GEMA", "FAVIOLA", "EVELYNN", "ENDA", "ELLI", "ELLENA",
	"DIVINA", "DAGNY", "COLLENE", "CODI", "CINDIE", "CHASSIDY", "CHASIDY", "CATRICE", "CATHERINA", "CASSEY",
	"CAROLL", "CARLENA", "CANDRA", "CALISTA", "BRYANNA", "BRITTENY", "BEULA", "BARI", "AUDRIE", "AUDRIA",
	"ARDELIA", "ANNELLE", "ANGILA", "ALONA", "ALLYN", "DOUGLAS", "ROGER", "JONATHAN", "RALPH", "NICHOLAS",
	"BENJAMIN", "BRUCE", "HARRY", "WAYNE", "STEVE", "HOWARD", "ERNEST", "PHILLIP", "TODD", "CRAIG",
	"ALAN", "PHILIP", "EARL", "DANNY", "BRYAN", "STANLEY", "LEONARD", "NATHAN", "MANUEL", "RODNEY",
	"MARVIN", "VINCENT", "JEFFERY", "JEFF", "CHAD", "JACOB", "ALFRED", "BRADLEY", "HERBERT", "FREDERICK",
	"EDWIN", "DON", "RICKY", "RANDALL", "BARRY", "BERNARD", "LEROY", "MARCUS", "THEODORE", "CLIFFORD",
	"MIGUEL", "JIM", "TOM", "CALVIN", "BILL", "LLOYD", "DEREK", "WARREN", "DARRELL", "JEROME",
	"FLOYD", "ALVIN", "TIM", "GORDON", "GREG", "JORGE", "DUSTIN", "PEDRO", "DERRICK", "ZACHARY",
	"HERMAN", "GLEN", "HECTOR", "RICARDO", "RICK", "BRENT", "RAMON", "GILBERT", "MARC", "REGINALD",
	"RUBEN", "NATHANIEL", "RAFAEL", "EDGAR", "MILTON", "RAUL", "BEN", "CHESTER", "DUANE", "FRANKLIN",
	"BRAD", "RON", "ROLAND", "ARNOLD", "HARVEY", "JARED", "ERIK", "DARRYL", "NEIL", "JAVIER",
	"FERNANDO", "CLINTON", "TED", "MATHEW", "TYRONE", "DARREN", "LANCE", "KURT", "ALLAN", "NELSON",
	"GUY", "CLAYTON", "HUGH", "MAX", "DWAYNE", "DWIGHT", "ARMANDO", "FELIX", "EVERETT", "IAN",
	"WALLACE", "KEN", "BOB", "ALFREDO", "ALBERTO", "DAVE", "IVAN", "BYRON", "ISAAC", "MORRIS",
	"CLIFTON", "WILLARD", "ROSS", "ANDY", "SALVADOR", "KIRK", "SERGIO", "SETH", "KENT", "TERRANCE",
	"EDUARDO", "TERRENCE", "ENRIQUE", "WADE", "STUART", "FREDRICK", "ARTURO", "ALEJANDRO", "NICK", "LUTHER",
	"WENDELL", "JEREMIAH", "JULIUS", "OTIS", "TREVOR", "OLIVER", "LUKE", "HOMER", "GERARD", "DOUG",
	"KENNY", "HUBERT", "LYLE", "MATT", "ALFONSO", "ORLANDO", "REX", "CARLTON", "ERNESTO", "NEAL",
	"PABLO", "LORENZO", "OMAR", "WILBUR", "GRANT", "HORACE", "RODERICK", "ABRAHAM", "WILLIS", "RICKEY",
	"ANDRES", "CESAR", "JOHNATHAN", "MALCOLM", "RUDOLPH", "DAMON", "KELVIN", "PRESTON", "ALTON", "ARCHIE",
	"MARCO", "WM", "PETE", "RANDOLPH", "GARRY", "GEOFFREY", "JONATHON", "FELIPE", "GERARDO", "ED",
	"DOMINIC", "DELBERT", "COLIN", "GUILLERMO", "EARNEST", "LUCAS", "BENNY", "SPENCER", "RODOLFO", "MYRON",
	"EDMUND", "GARRETT", "SALVATORE", "CEDRIC", "LOWELL", "GREGG", "SHERMAN", "WILSON", "SYLVESTER", "ROOSEVELT",
	"ISRAEL", "JERMAINE", "FORREST", "WILBERT", "LELAND", "SIMON", "CLARK", "IRVING", "BRYANT", "OWEN",
	"RUFUS", "WOODROW", "KRISTOPHER", "MACK", "LEVI", "MARCOS", "GUSTAVO", "JAKE", "LIONEL", "GILBERTO",
	"CLINT", "NICOLAS", "ISMAEL", "ORVILLE", "ERVIN", "DEWEY", "AL", "WILFRED", "JOSH", "HUGO",
	"IGNACIO", "CALEB", "TOMAS", "SHELDON", "ERICK", "STEWART", "DOYLE", "DARREL", "ROGELIO", "TERENCE",
	"SANTIAGO", "ALONZO", "ELIAS", "BERT", "ELBERT", "RAMIRO", "CONRAD", "NOAH", "GRADY", "PHIL",
	"CORNELIUS", "LAMAR", "ROLANDO", "CLAY", "PERCY", "DEXTER", "BRADFORD", "DARIN", "AMOS", "MOSES",
	"IRVIN", "SAUL", "ROMAN", "RANDAL", "TIMMY", "DARRIN", "WINSTON", "BRENDAN", "ABEL", "DOMINICK",
	"BOYD", "EMILIO", "ELIJAH", "DOMINGO", "EMMETT", "MARLON", "EMANUEL", "JERALD", "EDMOND", "EMIL",
	"DEWAYNE", "WILL", "OTTO", "TEDDY", "REYNALDO", "BRET", "JESS", "TRENT", "HUMBERTO", "EMMANUEL",
	"STEPHAN", "VICENTE", "LAMONT", "GARLAND", "MILES", "EFRAIN", "HEATH", "RODGER", "HARLEY", "ETHAN",
	"ELDON", "ROCKY", "PIERRE", "JUNIOR", "FREDDY", "ELI", "BRYCE", "ANTOINE", "STERLING", "CHASE",
	"GROVER", "ELTON", "CLEVELAND", "DYLAN", "CHUCK", "DAMIAN", "REUBEN", "STAN", "AUGUST", "LEONARDO",
	"JASPER", "RUSSEL", "ERWIN", "BENITO", "HANS", "MONTE", "BLAINE", "ERNIE", "CURT", "QUENTIN",
	"AGUSTIN", "MURRAY", "JAMAL", "ADOLFO", "HARRISON", "TYSON", "BURTON", "BRADY", "ELLIOTT", "WILFREDO",
	"BART", "JARROD", "VANCE", "DENIS", "DAMIEN", "JOAQUIN", "HARLAN", "DESMOND", "ELLIOT", "DARWIN",
	"GREGORIO", "BUDDY", "XAVIER", "KERMIT", "ROSCOE", "ESTEBAN", "ANTON", "SOLOMON", "SCOTTY", "NORBERT",
	"ELVIN", "WILLIAMS", "NOLAN", "ROD", "QUINTON", "HAL", "BRAIN", "ROB", "ELWOOD", "KENDRICK",
	"DARIUS", "MOISES", "FIDEL", "THADDEUS", "CLIFF", "MARCEL", "JACKSON", "RAPHAEL", "BRYON", "ARMAND",
	"ALVARO", "JEFFRY", "DANE", "JOESPH", "THURMAN", "NED", "RUSTY", "MONTY", "FABIAN", "REGGIE",
	"MASON", "GRAHAM", "ISAIAH", "VAUGHN", "GUS", "LOYD", "DIEGO", "ADOLPH", "NORRIS", "MILLARD",
	"ROCCO", "GONZALO", "DERICK", "RODRIGO", "WILEY", "RIGOBERTO", "ALPHONSO", "TY", "NOE", "VERN",
	"REED", "JEFFERSON", "ELVIS", "BERNARDO", "MAURICIO", "HIRAM", "DONOVAN", "BASIL", "RILEY", "NICKOLAS",
	"MAYNARD", "SCOT", "VINCE", "QUINCY", "EDDY", "SEBASTIAN", "FEDERICO", "ULYSSES", "HERIBERTO", "DONNELL",
	"COLE", "DAVIS", "GAVIN", "EMERY", "WARD", "ROMEO", "JAYSON", "DANTE", "CLEMENT", "COY",
	"MAXWELL", "JARVIS", "BRUNO", "ISSAC", "DUDLEY", "BROCK", "SANFORD", "CARMELO", "BARNEY", "NESTOR",
	"STEFAN", "DONNY", "ART", "LINWOOD", "BEAU", "WELDON", "GALEN", "ISIDRO", "TRUMAN", "DELMAR",
	"JOHNATHON", "SILAS", "FREDERIC", "DICK", "IRWIN", "MERLIN", "CHARLEY", "MARCELINO", "HARRIS", "CARLO",
	"TRENTON", "KURTIS", "HUNTER", "AURELIO", "WINFRED", "VITO", "COLLIN", "DENVER", "CARTER", "LEONEL",
	"EMORY", "PASQUALE", "MOHAMMAD", "MARIANO", "DANIAL", "LANDON", "DIRK", "BRANDEN", "ADAN", "BUFORD",
	"GERMAN", "WILMER", "EMERSON", "ZACHERY", "FLETCHER", "JACQUES", "ERROL", "DALTON", "MONROE", "JOSUE",
	"EDWARDO", "BOOKER", "WILFORD", "SONNY", "SHELTON", "CARSON", "THERON", "RAYMUNDO", "DAREN", "HOUSTON",
	"ROBBY", "LINCOLN", "GENARO", "BENNETT", "OCTAVIO", "CORNELL", "HUNG", "ARRON", "ANTONY", "HERSCHEL",
	"GIOVANNI", "GARTH", "CYRUS", "CYRIL", "RONNY", "LON", "FREEMAN", "DUNCAN", "KENNITH", "CARMINE",
	"ERICH", "CHADWICK", "WILBURN", "RUSS", "REID", "MYLES", "ANDERSON", "MORTON", "JONAS", "FOREST",
	"MITCHEL", "MERVIN", "ZANE", "RICH", "JAMEL", "LAZARO", "ALPHONSE", "RANDELL", "MAJOR", "JARRETT",
	"BROOKS", "ABDUL", "LUCIANO", "SEYMOUR", "EUGENIO", "MOHAMMED", "VALENTIN", "CHANCE", "ARNULFO", "LUCIEN",
	"FERDINAND", "THAD", "EZRA", "ALDO", "RUBIN", "ROYAL", "MITCH", "EARLE", "ABE", "WYATT",
	"MARQUIS", "LANNY", "KAREEM", "JAMAR", "BORIS", "ISIAH", "EMILE", "ELMO", "ARON", "LEOPOLDO",
	"EVERETTE", "JOSEF", "ELOY", "RODRICK", "REINALDO", "LUCIO", "JERROD", "WESTON", "HERSHEL", "BARTON",
	"PARKER", "LEMUEL", "BURT", "JULES", "GIL", "ELISEO", "AHMAD", "NIGEL", "EFREN", "ANTWAN",
	"ALDEN", "MARGARITO", "COLEMAN", "DINO", "OSVALDO", "LES", "DEANDRE", "NORMAND", "KIETH", "TREY",
	"NORBERTO", "NAPOLEON", "JEROLD", "FRITZ", "ROSENDO", "MILFORD", "CHRISTOPER", "ALFONZO", "LYMAN", "JOSIAH",
	"BRANT", "WILTON", "RICO", "JAMAAL", "DEWITT", "BRENTON", "OLIN", "FOSTER", "FAUSTINO", "CLAUDIO",
	"JUDSON", "GINO", "EDGARDO", "ALEC", "TANNER", "JARRED", "DONN", "TAD", "PRINCE", "PORFIRIO",
	"ODIS", "LENARD", "CHAUNCEY", "TOD", "MEL", "MARCELO", "KORY", "AUGUSTUS", "KEVEN", "HILARIO",
	"BUD", "SAL", "ORVAL", "MAURO", "ZACHARIAH", "OLEN", "ANIBAL", "MILO", "JED", "DILLON",
	"AMADO", "NEWTON", "LENNY", "RICHIE", "HORACIO", "BRICE", "MOHAMED", "DELMER", "DARIO", "REYES",
	"MAC", "JONAH", "JERROLD", "ROBT", "HANK", "RUPERT", "ROLLAND", "KENTON", "DAMION", "ANTONE",
	"WALDO", "FREDRIC", "BRADLY", "KIP", "BURL", "WALKER", "TYREE", "JEFFEREY", "AHMED", "WILLY",
	"STANFORD", "OREN", "NOBLE", "MOSHE", "MIKEL", "ENOCH", "BRENDON", "QUINTIN", "JAMISON", "FLORENCIO",
	"DARRICK", "TOBIAS", "HASSAN", "GIUSEPPE", "DEMARCUS", "CLETUS", "TYRELL", "LYNDON", "KEENAN", "WERNER",
	"GERALDO", "COLUMBUS", "CHET", "BERTRAM", "MARKUS", "HUEY", "HILTON", "DWAIN", "DONTE", "TYRON",
	"OMER", "ISAIAS", "HIPOLITO", "FERMIN", "ADALBERTO", "BO", "BARRETT", "TEODORO", "MCKINLEY", "MAXIMO",
	"GARFIELD", "RALEIGH", "LAWERENCE", "ABRAM", "RASHAD", "KING", "EMMITT", "DARON", "SAMUAL", "MIQUEL",
	"EUSEBIO", "DOMENIC", "DARRON", "BUSTER", "WILBER", "RENATO", "JC", "HOYT", "HAYWOOD", "EZEKIEL",
	"CHAS", "FLORENTINO", "ELROY", "CLEMENTE", "ARDEN", "NEVILLE", "EDISON", "DESHAWN", "NATHANIAL", "JORDON",
	"DANILO", "CLAUD", "SHERWOOD", "RAYMON", "RAYFORD", "CRISTOBAL", "AMBROSE", "TITUS", "HYMAN", "FELTON",
	"EZEQUIEL", "ERASMO", "STANTON", "LONNY", "LEN", "IKE", "MILAN", "LINO", "JAROD", "HERB",
	"ANDREAS", "WALTON", "RHETT", "PALMER", "DOUGLASS", "CORDELL", "OSWALDO", "ELLSWORTH", "VIRGILIO", "TONEY",
	"NATHANAEL", "DEL", "BENEDICT", "MOSE", "JOHNSON", "ISREAL", "GARRET", "FAUSTO", "ASA", "ARLEN",
	"ZACK", "WARNER", "MODESTO", "FRANCESCO", "MANUAL", "GAYLORD", "GASTON", "FILIBERTO", "DEANGELO", "MICHALE",
	"GRANVILLE", "WES", "MALIK", "ZACKARY", "TUAN", "ELDRIDGE", "CRISTOPHER", "CORTEZ", "ANTIONE", "MALCOM",
	"LONG", "KOREY", "JOSPEH", "COLTON", "WAYLON", "VON", "HOSEA", "SHAD", "SANTO", "RUDOLF",
	"ROLF", "REY", "RENALDO", "MARCELLUS", "LUCIUS", "KRISTOFER", "BOYCE", "BENTON", "HAYDEN", "HARLAND",
	"ARNOLDO", "RUEBEN", "LEANDRO", "KRAIG", "JERRELL", "JEROMY", "HOBERT", "CEDRICK", "ARLIE", "WINFORD",
	"WALLY", "LUIGI", "KENETH", "JACINTO", "GRAIG", "FRANKLYN", "EDMUNDO", "SID", "PORTER", "LEIF",
	"JERAMY", "BUCK", "WILLIAN", "VINCENZO", "SHON", "LYNWOOD", "JERE", "HAI", "ELDEN", "DORSEY",
	"DARELL", "BRODERICK", "ALONSO"
	]
	total_sum = 0
	temp_sum = 0
	name.sort()
	for i in range(len(name)):
		for j in name[i]:
			temp_sum += ord(j) - ord('A') + 1
		total_sum += (i + 1) * temp_sum
		temp_sum = 0
	print(total_sum)


if __name__ == '__main__':
	main()
<EOF>
<BOF>
'''
Problem:
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible(divisible with no remainder) by all of the numbers from 1 to N?
'''
from __future__ import print_function

n = int(input())
i = 0
while 1:
    i+=n*(n-1)
    nfound=0
    for j in range(2,n):
        if (i%j != 0):
            nfound=1
            break
    if(nfound==0):
        if(i==0):
            i=1
        print(i)
        break
<EOF>
<BOF>
#!/bin/python3
'''
Problem:
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible(divisible with no remainder) by all of the numbers from 1 to N?
'''

""" Euclidean GCD Algorithm """
def gcd(x,y):
    return x if y==0 else gcd(y,x%y)

""" Using the property lcm*gcd of two numbers = product of them """
def lcm(x,y):
    return (x*y)//gcd(x,y)

n = int(input())
g=1
for i in range(1,n+1):
    g=lcm(g,i)
print(g)
<EOF>
<BOF>
'''
Problem:
The prime factors of 13195 are 5,7,13 and 29. What is the largest prime factor of a given number N?
e.g. for 10, largest prime factor = 5. For 17, largest prime factor = 17.
'''
from __future__ import print_function, division

import math

def isprime(no):
    if(no==2):
        return True
    elif (no%2==0):
        return False
    sq = int(math.sqrt(no))+1
    for i in range(3,sq,2):
        if(no%i==0):
            return False
    return True

maxNumber = 0
n=int(input())
if(isprime(n)):
    print(n)
else:
    while (n%2==0):
        n=n/2
    if(isprime(n)):
        print(n)
    else:
        n1 = int(math.sqrt(n))+1
        for i in range(3,n1,2):
            if(n%i==0):
                if(isprime(n/i)):
                    maxNumber = n/i
                    break
                elif(isprime(i)):
                    maxNumber = i
        print(maxNumber)
<EOF>
<BOF>
'''
Problem:
The prime factors of 13195 are 5,7,13 and 29. What is the largest prime factor of a given number N?
e.g. for 10, largest prime factor = 5. For 17, largest prime factor = 17.
'''

from __future__ import print_function
n=int(input())
prime=1
i=2
while(i*i<=n):
    while(n%i==0):
        prime=i
        n/=i
    i+=1
if(n>1):
    prime=n
print(prime)
<EOF>
<BOF>
from __future__ import print_function

try:
	xrange			#Python 2
except NameError:
	xrange = range	#Python 3

def fibonacci(n):
	if n == 1 or type(n) is not int:
		return 0
	elif n == 2:
		return 1
	else:
		sequence = [0, 1]
		for i in xrange(2, n+1):
			sequence.append(sequence[i-1] + sequence[i-2])

		return sequence[n]

def fibonacci_digits_index(n):
	digits = 0
	index = 2

	while digits < n:
		index += 1
		digits = len(str(fibonacci(index)))

	return index

if __name__ == '__main__':
	print(fibonacci_digits_index(1000))
<EOF>
<BOF>
from __future__ import print_function
'''
Number letter counts
Problem 17

If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.

If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?


NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) 
contains 20 letters. The use of "and" when writing out numbers is in compliance with British usage.
'''

ones_counts = [0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8] #number of letters in zero, one, two, ..., nineteen (0 for zero since it's never said aloud)
tens_counts = [0, 0, 6, 6, 5, 5, 5, 7, 6, 6] #number of letters in twenty, thirty, ..., ninety (0 for numbers less than 20 due to inconsistency in teens)

count = 0

for i in range(1, 1001):
	if i < 1000:
		if i >= 100:
			count += ones_counts[i/100] + 7 #add number of letters for "n hundred"

			if i%100 is not 0:
				count += 3 #add number of letters for "and" if number is not multiple of 100

		if 0 < i%100 < 20:
			count += ones_counts[i%100] #add number of letters for one, two, three, ..., nineteen (could be combined with below if not for inconsistency in teens)
		else:
			count += ones_counts[i%10] + tens_counts[(i%100-i%10)/10] #add number of letters for twenty, twenty one, ..., ninety nine
	else:
		count += ones_counts[i/1000] + 8

print(count)
<EOF>
<BOF>
from __future__ import print_function
'''
Double-base palindromes
Problem 36
The decimal number, 585 = 10010010012 (binary), is palindromic in both bases.

Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.

(Please note that the palindromic number, in either base, may not include leading zeros.)
'''
try:
	xrange		#Python 2
except NameError:
	xrange = range	#Python 3

def is_palindrome(n):
	n = str(n)

	if n == n[::-1]:
		return True
	else:
		return False

total = 0

for i in xrange(1, 1000000):
	if is_palindrome(i) and is_palindrome(bin(i).split('b')[1]):
		total += i

print(total)
<EOF>
<BOF>
#-.- coding: latin-1 -.-
from __future__ import print_function
from math import factorial
'''
Combinatoric selections
Problem 53

There are exactly ten ways of selecting three from five, 12345:

123, 124, 125, 134, 135, 145, 234, 235, 245, and 345

In combinatorics, we use the notation, 5C3 = 10.

In general,

nCr = n!/(r!(nr)!),where r  n, n! = n(n1)...321, and 0! = 1.
It is not until n = 23, that a value exceeds one-million: 23C10 = 1144066.

How many, not necessarily distinct, values of nCr, for 1  n  100, are greater than one-million?
'''
try:
	xrange		#Python 2
except NameError:
	xrange = range	#Python 3

def combinations(n, r):
	return factorial(n)/(factorial(r)*factorial(n-r))

total = 0

for i in xrange(1, 101):
	for j in xrange(1, i+1):
		if combinations(i, j) > 1e6:
			total += 1

print(total)
<EOF>
<BOF>
'''
Problem:
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.
Find the largest palindrome made from the product of two 3-digit numbers which is less than N.
'''
from __future__ import print_function
limit = int(input("limit? "))

# fetchs the next number
for number in range(limit-1,10000,-1):

    # converts number into string.
    strNumber = str(number)

    # checks whether 'strNumber' is a palindrome.
    if(strNumber == strNumber[::-1]):

        divisor = 999

        # if 'number' is a product of two 3-digit numbers
        # then number is the answer otherwise fetch next number.
        while(divisor != 99): 
            
            if((number % divisor == 0) and (len(str(number / divisor)) == 3)):

                print(number)
                exit(0)

            divisor -=1
<EOF>
<BOF>
'''
Problem:
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.
Find the largest palindrome made from the product of two 3-digit numbers which is less than N.
'''
from __future__ import print_function
arr = []
for i in range(999,100,-1):
    for j in range(999,100,-1):
        t = str(i*j)
        if t == t[::-1]:
            arr.append(i*j)
arr.sort()

n=int(input())
for i in arr[::-1]:
    if(i<n):
        print(i)
        exit(0)
<EOF>
<BOF>
#-.- coding: latin-1 -.-
from __future__ import print_function
'''
Champernowne's constant
Problem 40
An irrational decimal fraction is created by concatenating the positive integers:

0.123456789101112131415161718192021...

It can be seen that the 12th digit of the fractional part is 1.

If dn represents the nth digit of the fractional part, find the value of the following expression.

d1  d10  d100  d1000  d10000  d100000  d1000000
'''

constant = []
i = 1

while len(constant) < 1e6:
	constant.append(str(i))
	i += 1

constant = ''.join(constant)

print(int(constant[0])*int(constant[9])*int(constant[99])*int(constant[999])*int(constant[9999])*int(constant[99999])*int(constant[999999]))
<EOF>
<BOF>
'''
Problem:
Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
                0,1,1,2,3,5,8,13,21,34,55,89,..
Every third term from 0 is even So using this I have written a simple code
By considering the terms in the Fibonacci sequence whose values do not exceed n, find the sum of the even-valued terms.
e.g. for n=10, we have {2,8}, sum is 10.
'''
"""Python 3"""
n = int(input())
a=0
b=2
count=0
while 4*b+a<n:
    c=4*b+a
    a=b
    b=c
    count=count+a
print(count+b)
   
<EOF>
<BOF>
'''
Problem:
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2,
the first 10 terms will be:
                1,2,3,5,8,13,21,34,55,89,..
By considering the terms in the Fibonacci sequence whose values do not exceed n, find the sum of the even-valued terms.
e.g. for n=10, we have {2,8}, sum is 10.
'''
from __future__ import print_function

try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3

n = int(raw_input().strip())
i=1
j=2 
sum=0
while(j<=n):
    if((j&1)==0): #can also use (j%2==0)
        sum+=j
    temp=i
    i=j
    j=temp+i
print(sum)
<EOF>
<BOF>
def fib(n):
    a, b, s = 0, 1, 0
    while b < n:
        if b % 2 == 0 and b < n: s += b
        a, b = b, a+b
    ls.append(s)

T = int(input().strip())
ls = []
for _ in range(T):
    fib(int(input().strip()))
print(ls, sep = '\n')
<EOF>
<BOF>
power = int(input("Enter the power of 2: "))
num = 2**power

string_num = str(num)

list_num = list(string_num)

sum_of_num = 0

print("2 ^",power,"=",num)

for i in list_num:
    sum_of_num += int(i)

print("Sum of the digits are:",sum_of_num)
<EOF>
<BOF>
from __future__ import print_function
'''
Self Powers
Problem 48

The series, 11 + 22 + 33 + ... + 1010 = 10405071317.

Find the last ten digits of the series, 11 + 22 + 33 + ... + 10001000.
'''

try:
	xrange
except NameError:
	xrange = range

total = 0
for i in xrange(1, 1001):
	total += i**i


print(str(total)[-10:])
<EOF>
<BOF>
from __future__ import print_function
from math import factorial

def lattice_paths(n):
	n = 2*n #middle entry of odd rows starting at row 3 is the solution for n = 1, 2, 3,...
	k = n/2

	return factorial(n)/(factorial(k)*factorial(n-k))

if __name__ == '__main__':
	import sys

	if len(sys.argv) == 1:
		print(lattice_paths(20))
	else:
		try:
			n = int(sys.argv[1])
			print(lattice_paths(n))
		except ValueError:
			print('Invalid entry - please enter a number.')
<EOF>
<BOF>
from __future__ import print_function
from math import sqrt
'''
Highly divisible triangular numbers
Problem 12
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
'''
try:
	xrange		#Python 2
except NameError:
	xrange = range	#Python 3

def count_divisors(n):
	nDivisors = 0
	for i in xrange(1, int(sqrt(n))+1):
		if n%i == 0:
			nDivisors += 2

	return nDivisors

tNum = 1
i = 1

while True:
	i += 1
	tNum += i

	if count_divisors(tNum) > 500:
		break

print(tNum)
<EOF>
<BOF>
from __future__ import print_function

'''
Problem Statement:
If we list all the natural numbers below 10 that are multiples of 3 or 5,
we get 3,5,6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below N.
'''
'''
This solution is based on the pattern that the successive numbers in the series follow: 0+3,+2,+1,+3,+1,+2,+3.
'''

try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3
n = int(raw_input().strip())
sum=0
num=0
while(1):
    num+=3
    if(num>=n):
        break
    sum+=num
    num+=2
    if(num>=n):
        break
    sum+=num
    num+=1
    if(num>=n):
        break
    sum+=num
    num+=3
    if(num>=n):
        break
    sum+=num
    num+=1
    if(num>=n):
        break
    sum+=num
    num+=2
    if(num>=n):
        break
    sum+=num
    num+=3
    if(num>=n):
        break
    sum+=num

print(sum);
<EOF>
<BOF>
def mulitples(limit):
    xmulti = []
    zmulti = []
    z = 3
    x = 5
    temp = 1
    while True:
        result = z * temp
        if (result < limit):
            zmulti.append(result)
            temp += 1
        else:
            temp = 1
            break
    while True:
        result = x * temp
        if (result < limit):
            xmulti.append(result)
            temp += 1
        else:
            break
    collection = list(set(xmulti+zmulti))
    return (sum(collection))
    
    
        
        
        
    
print (mulitples(1000))
<EOF>
<BOF>
'''
Problem Statement:
If we list all the natural numbers below 10 that are multiples of 3 or 5,
we get 3,5,6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below N.
'''
from __future__ import print_function
try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3
n = int(raw_input().strip())
sum=0
for a in range(3,n):
    if(a%3==0 or a%5==0):
        sum+=a
print(sum)
<EOF>
<BOF>
'''
Problem Statement:
If we list all the natural numbers below 10 that are multiples of 3 or 5,
we get 3,5,6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below N.
'''
from __future__ import print_function
try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3
n = int(raw_input().strip())
sum = 0
terms = (n-1)//3
sum+= ((terms)*(6+(terms-1)*3))//2 #sum of an A.P.
terms = (n-1)//5
sum+= ((terms)*(10+(terms-1)*5))//2
terms = (n-1)//15
sum-= ((terms)*(30+(terms-1)*15))//2
print(sum)
<EOF>
<BOF>
from __future__ import print_function
'''
Permuted multiples
Problem 52

It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.

Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.
'''
i = 1

while True:
	if sorted(list(str(i))) == \
       sorted(list(str(2*i))) == \
       sorted(list(str(3*i))) == \
       sorted(list(str(4*i))) == \
       sorted(list(str(5*i))) == \
       sorted(list(str(6*i))):
		break

	i += 1

print(i) 
<EOF>
<BOF>
'''
By listing the first six prime numbers:
2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the Nth prime number?
'''
from __future__ import print_function
from math import sqrt
def isprime(n):
    if (n==2):
        return True
    elif (n%2==0):
        return False
    else:
        sq = int(sqrt(n))+1
        for i in range(3,sq,2):
            if(n%i==0):
                return False
    return True
n = int(input())
i=0
j=1
while(i!=n and j<3):
    j+=1
    if (isprime(j)):
        i+=1
while(i!=n):
    j+=2
    if(isprime(j)):
        i+=1
print(j)
<EOF>
<BOF>
# By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13. What is the Nth prime number?
def isprime(number):
	for i in range(2,int(number**0.5)+1):
		if number%i==0:
			return False
	return True
n = int(input('Enter The N\'th Prime Number You Want To Get: ')) # Ask For The N'th Prime Number Wanted
primes = []
num = 2
while len(primes) < n:
	if isprime(num):
		primes.append(num)
		num += 1
	else:
		num += 1
print(primes[len(primes) - 1])
<EOF>
<BOF>
from __future__ import print_function
largest_number = 0
pre_counter = 0

for input1 in range(750000,1000000):
    counter = 1
    number = input1

    while number > 1:
        if number % 2 == 0:
            number /=2
            counter += 1
        else:
            number = (3*number)+1
            counter += 1

    if counter > pre_counter:
        largest_number = input1
        pre_counter = counter

print(('Largest Number:',largest_number,'->',pre_counter,'digits'))
<EOF>
<BOF>
from __future__ import print_function
from math import sqrt

try:
	xrange			#Python 2
except NameError:
	xrange = range	#Python 3

def is_prime(n):
	for i in xrange(2, int(sqrt(n))+1):
		if n%i == 0:
			return False

	return True

def sum_of_primes(n):
	if n > 2:
		sumOfPrimes = 2
	else:
		return 0

	for i in xrange(3, n, 2):
		if is_prime(i):
			sumOfPrimes += i

	return sumOfPrimes

if __name__ == '__main__':
	import sys

	if len(sys.argv) == 1:
		print(sum_of_primes(2000000))
	else:
		try:
			n = int(sys.argv[1])
			print(sum_of_primes(n))
		except ValueError:
			print('Invalid entry - please enter a number.')
<EOF>
<BOF>
from __future__ import print_function
'''
Counting Summations
Problem 76

It is possible to write five as a sum in exactly six different ways:

4 + 1
3 + 2
3 + 1 + 1
2 + 2 + 1
2 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1

How many different ways can one hundred be written as a sum of at least two positive integers?
'''
try:
	xrange		#Python 2
except NameError:
	xrange = range	#Python 3

def partition(m):
	memo = [[0 for _ in xrange(m)] for _ in xrange(m+1)]
	for i in xrange(m+1):
		memo[i][0] = 1

	for n in xrange(m+1):
		for k in xrange(1, m):
			memo[n][k] += memo[n][k-1]
			if n > k:
				memo[n][k] += memo[n-k-1][k]

	return (memo[m][m-1] - 1)

print(partition(100))
<EOF>
<BOF>
"""
	Peak signal-to-noise ratio - PSNR - https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio
    Soruce: https://tutorials.techonical.com/how-to-calculate-psnr-value-of-two-images-using-python/
"""

import math

import cv2
import numpy as np

def psnr(original, contrast):
    mse = np.mean((original - contrast) ** 2)
    if mse == 0:
        return 100
    PIXEL_MAX = 255.0
    PSNR = 20 * math.log10(PIXEL_MAX / math.sqrt(mse))
    return PSNR


def main():

    # Loading images (original image and compressed image)
    original = cv2.imread('original_image.png')
    contrast = cv2.imread('compressed_image.png', 1)

    original2 = cv2.imread('PSNR-example-base.png')
    contrast2 = cv2.imread('PSNR-example-comp-10.jpg', 1)

    # Value expected: 29.73dB
    print("-- First Test --")
    print(f"PSNR value is {psnr(original, contrast)} dB")
    
    # # Value expected: 31.53dB (Wikipedia Example)
    print("\n-- Second Test --")
    print(f"PSNR value is {psnr(original2, contrast2)} dB")


if __name__ == '__main__':
    main()
<EOF>
<BOF>
# -*- coding: utf-8 -*-
"""
Created on Mon Feb 26 15:40:07 2018

@author: Christian Bender
@license: MIT-license

This file contains the test-suite for the linear algebra library.
"""

import unittest
from lib import *

class Test(unittest.TestCase):
    def test_component(self):
        """
            test for method component
        """
        x = Vector([1,2,3])
        self.assertEqual(x.component(0),1)
        self.assertEqual(x.component(2),3)
        try:
            y = Vector()
            self.assertTrue(False)
        except:
            self.assertTrue(True)
    def test_str(self):
        """
            test for toString() method
        """
        x = Vector([0,0,0,0,0,1])
        self.assertEqual(str(x),"(0,0,0,0,0,1)")
    def test_size(self):
        """
            test for size()-method
        """
        x = Vector([1,2,3,4])
        self.assertEqual(len(x),4)
    def test_euclidLength(self):
        """
            test for the eulidean length
        """
        x = Vector([1,2])
        self.assertAlmostEqual(x.eulidLength(),2.236,3)
    def test_add(self):
        """
            test for + operator
        """
        x = Vector([1,2,3])
        y = Vector([1,1,1])
        self.assertEqual((x+y).component(0),2)
        self.assertEqual((x+y).component(1),3)
        self.assertEqual((x+y).component(2),4)
    def test_sub(self):
        """
            test for - operator
        """
        x = Vector([1,2,3])
        y = Vector([1,1,1])
        self.assertEqual((x-y).component(0),0)
        self.assertEqual((x-y).component(1),1)
        self.assertEqual((x-y).component(2),2)
    def test_mul(self):
        """
            test for * operator
        """
        x = Vector([1,2,3])
        a = Vector([2,-1,4]) # for test of dot-product
        b = Vector([1,-2,-1])
        self.assertEqual(str(x*3.0),"(3.0,6.0,9.0)")
        self.assertEqual((a*b),0)
    def test_zeroVector(self):
        """
            test for the global function zeroVector(...)
        """
        self.assertTrue(str(zeroVector(10)).count("0") == 10)
    def test_unitBasisVector(self):
        """
            test for the global function unitBasisVector(...)
        """
        self.assertEqual(str(unitBasisVector(3,1)),"(0,1,0)")
    def test_axpy(self):
        """
            test for the global function axpy(...) (operation)
        """
        x = Vector([1,2,3])
        y = Vector([1,0,1])
        self.assertEqual(str(axpy(2,x,y)),"(3,4,7)")
    def test_copy(self):
        """
            test for the copy()-method
        """
        x = Vector([1,0,0,0,0,0])
        y = x.copy()
        self.assertEqual(str(x),str(y))
    def test_changeComponent(self):
        """
            test for the changeComponent(...)-method
        """
        x = Vector([1,0,0])
        x.changeComponent(0,0)
        x.changeComponent(1,1)
        self.assertEqual(str(x),"(0,1,0)")
    def test_str_matrix(self):
        A = Matrix([[1,2,3],[2,4,5],[6,7,8]],3,3)
        self.assertEqual("|1,2,3|\n|2,4,5|\n|6,7,8|\n",str(A))
    def test__mul__matrix(self):
        A = Matrix([[1,2,3],[4,5,6],[7,8,9]],3,3)
        x = Vector([1,2,3])
        self.assertEqual("(14,32,50)",str(A*x))
        self.assertEqual("|2,4,6|\n|8,10,12|\n|14,16,18|\n",str(A*2))
    def test_changeComponent_matrix(self):
        A = Matrix([[1,2,3],[2,4,5],[6,7,8]],3,3)
        A.changeComponent(0,2,5)
        self.assertEqual("|1,2,5|\n|2,4,5|\n|6,7,8|\n",str(A))
    def test_component_matrix(self):
        A = Matrix([[1,2,3],[2,4,5],[6,7,8]],3,3)
        self.assertEqual(7,A.component(2,1),0.01)
    def test__add__matrix(self):
        A = Matrix([[1,2,3],[2,4,5],[6,7,8]],3,3)
        B = Matrix([[1,2,7],[2,4,5],[6,7,10]],3,3)
        self.assertEqual("|2,4,10|\n|4,8,10|\n|12,14,18|\n",str(A+B))
    def test__sub__matrix(self):
        A = Matrix([[1,2,3],[2,4,5],[6,7,8]],3,3)
        B = Matrix([[1,2,7],[2,4,5],[6,7,10]],3,3)
        self.assertEqual("|0,0,-4|\n|0,0,0|\n|0,0,-2|\n",str(A-B))
    def test_squareZeroMatrix(self):
        self.assertEqual('|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|' 
        +'\n|0,0,0,0,0|\n',str(squareZeroMatrix(5)))
        

if __name__ == "__main__":
    unittest.main()
<EOF>
<BOF>
# -*- coding: utf-8 -*-
"""
Created on Mon Feb 26 14:29:11 2018

@author: Christian Bender
@license: MIT-license

This module contains some useful classes and functions for dealing
with linear algebra in python.

Overview:

- class Vector
- function zeroVector(dimension)
- function unitBasisVector(dimension,pos)
- function axpy(scalar,vector1,vector2)
- function randomVector(N,a,b)
- class Matrix
- function squareZeroMatrix(N)
- function randomMatrix(W,H,a,b)
"""


import math
import random


class Vector(object):
    """
        This class represents a vector of arbitray size.
        You need to give the vector components. 
        
        Overview about the methods:
        
        constructor(components : list) : init the vector
        set(components : list) : changes the vector components.
        __str__() : toString method
        component(i : int): gets the i-th component (start by 0)
        __len__() : gets the size of the vector (number of components)
        euclidLength() : returns the eulidean length of the vector.
        operator + : vector addition
        operator - : vector subtraction
        operator * : scalar multiplication and dot product
        copy() : copies this vector and returns it.
        changeComponent(pos,value) : changes the specified component.
        TODO: compare-operator
    """
    def __init__(self,components=[]):
        """
            input: components or nothing
            simple constructor for init the vector
        """
        self.__components = list(components)
    def set(self,components):
        """
            input: new components
            changes the components of the vector.
            replace the components with newer one.
        """
        if len(components) > 0:
            self.__components = list(components)
        else:
            raise Exception("please give any vector")
    def __str__(self):
        """
            returns a string representation of the vector
        """
        return "(" + ",".join(map(str, self.__components)) + ")"
    def component(self,i):
        """
            input: index (start at 0)
            output: the i-th component of the vector.
        """
        if type(i) is int and -len(self.__components) <= i < len(self.__components) :
            return self.__components[i]
        else:
            raise Exception("index out of range")
    def __len__(self):
        """
            returns the size of the vector
        """
        return len(self.__components)
    def eulidLength(self):
        """
            returns the eulidean length of the vector
        """
        summe = 0
        for c in self.__components:
            summe += c**2
        return math.sqrt(summe)
    def __add__(self,other):
        """
            input: other vector
            assumes: other vector has the same size
            returns a new vector that represents the sum.
        """
        size = len(self)
        if size == len(other):
            result = [self.__components[i] + other.component(i) for i in range(size)]
            return Vector(result)
        else:
            raise Exception("must have the same size")
    def __sub__(self,other):
        """
            input: other vector
            assumes: other vector has the same size
            returns a new vector that represents the differenz.
        """
        size = len(self)
        if size == len(other):
            result = [self.__components[i] - other.component(i) for i in range(size)]
            return result
        else: # error case
            raise Exception("must have the same size")
    def __mul__(self,other):
        """
            mul implements the scalar multiplication 
            and the dot-product
        """
        if isinstance(other,float) or isinstance(other,int):
            ans = [c*other for c in self.__components]
            return ans
        elif (isinstance(other,Vector) and (len(self) == len(other))):
            size = len(self)
            summe = 0
            for i in range(size):
                summe += self.__components[i] * other.component(i)
            return summe
        else: # error case
            raise Exception("invalide operand!")
    def copy(self):
        """
            copies this vector and returns it.
        """
        return Vector(self.__components)
    def changeComponent(self,pos,value):
        """
            input: an index (pos) and a value
            changes the specified component (pos) with the
            'value'
        """
        #precondition
        assert (-len(self.__components) <= pos < len(self.__components))
        self.__components[pos] = value
    
def zeroVector(dimension):
    """
        returns a zero-vector of size 'dimension'
    """        
    #precondition
    assert(isinstance(dimension,int))
    return Vector([0]*dimension)


def unitBasisVector(dimension,pos):
    """
        returns a unit basis vector with a One 
        at index 'pos' (indexing at 0)
    """
    #precondition
    assert(isinstance(dimension,int) and (isinstance(pos,int)))
    ans = [0]*dimension
    ans[pos] = 1
    return Vector(ans)
        

def axpy(scalar,x,y):
    """
        input: a 'scalar' and two vectors 'x' and 'y'
        output: a vector
        computes the axpy operation
    """
    # precondition
    assert(isinstance(x,Vector) and (isinstance(y,Vector)) \
    and (isinstance(scalar,int) or isinstance(scalar,float)))
    return (x*scalar + y)
    

def randomVector(N,a,b):
    """
        input: size (N) of the vector.
               random range (a,b)
        output: returns a random vector of size N, with 
                random integer components between 'a' and 'b'.
    """
    random.seed(None)
    ans = [random.randint(a,b) for i in range(N)]
    return Vector(ans)


class Matrix(object):
    """
    class: Matrix
    This class represents a arbitrary matrix.
    
    Overview about the methods:
    
           __str__() : returns a string representation 
           operator * : implements the matrix vector multiplication
                        implements the matrix-scalar multiplication.
           changeComponent(x,y,value) : changes the specified component.
           component(x,y) : returns the specified component.
           width() : returns the width of the matrix
           height() : returns the height of the matrix
           operator + : implements the matrix-addition.
           operator - _ implements the matrix-subtraction
    """
    def __init__(self,matrix,w,h):
        """
            simple constructor for initialzes 
            the matrix with components.
        """
        self.__matrix = matrix
        self.__width = w
        self.__height = h
    def __str__(self):
        """
            returns a string representation of this
            matrix.
        """
        ans = ""
        for i in range(self.__height):
            ans += "|"
            for j in range(self.__width):
                if j < self.__width -1:
                    ans += str(self.__matrix[i][j]) + ","
                else:
                    ans += str(self.__matrix[i][j]) + "|\n"
        return ans
    def changeComponent(self,x,y, value):
        """
            changes the x-y component of this matrix
        """
        if x >= 0 and x < self.__height and y >= 0 and y < self.__width:
            self.__matrix[x][y] = value
        else:
            raise Exception ("changeComponent: indices out of bounds")
    def component(self,x,y):
        """
            returns the specified (x,y) component
        """
        if x >= 0 and x < self.__height and y >= 0 and y < self.__width:
            return self.__matrix[x][y]
        else:
            raise Exception ("changeComponent: indices out of bounds")
    def width(self):
        """
            getter for the width
        """
        return self.__width
    def height(self):
        """
            getter for the height
        """
        return self.__height
    def __mul__(self,other):
        """
            implements the matrix-vector multiplication.
            implements the matrix-scalar multiplication
        """
        if isinstance(other, Vector): # vector-matrix 
            if (len(other) == self.__width):
                ans = zeroVector(self.__height)
                for i in range(self.__height):
                    summe = 0
                    for j in range(self.__width):
                        summe += other.component(j) * self.__matrix[i][j]
                    ans.changeComponent(i,summe)
                    summe = 0
                return ans
            else:
                raise Exception("vector must have the same size as the " + "number of columns of the matrix!")
        elif isinstance(other,int) or isinstance(other,float): # matrix-scalar
            matrix = [[self.__matrix[i][j] * other for j in range(self.__width)] for i in range(self.__height)]
            return Matrix(matrix,self.__width,self.__height)
    def __add__(self,other):
        """
            implements the matrix-addition.
        """
        if (self.__width == other.width() and self.__height == other.height()):
            matrix = []
            for i in range(self.__height):
                row = []
                for j in range(self.__width):
                    row.append(self.__matrix[i][j] + other.component(i,j))
                matrix.append(row)
            return Matrix(matrix,self.__width,self.__height)
        else:
            raise Exception("matrix must have the same dimension!")
    def __sub__(self,other):
        """
            implements the matrix-subtraction.
        """
        if (self.__width == other.width() and self.__height == other.height()):
            matrix = []
            for i in range(self.__height):
                row = []
                for j in range(self.__width):
                    row.append(self.__matrix[i][j] - other.component(i,j))
                matrix.append(row)
            return Matrix(matrix,self.__width,self.__height)
        else:
            raise Exception("matrix must have the same dimension!")
    

def squareZeroMatrix(N):
    """
        returns a square zero-matrix of dimension NxN
    """
    ans = [[0]*N for i in range(N)]
    return Matrix(ans,N,N)
    
    
def randomMatrix(W,H,a,b):
    """
        returns a random matrix WxH with integer components
        between 'a' and 'b'
    """
    random.seed(None)
    matrix = [[random.randint(a,b) for j in range(W)] for i in range(H)]
    return Matrix(matrix,W,H)
            
        
<EOF>
<BOF>
import base64

def main():
    inp = input('->')
    encoded = inp.encode('utf-8') #encoded the input (we need a bytes like object)
    b16encoded = base64.b16encode(encoded) #b16encoded the encoded string
    print(b16encoded)
    print(base64.b16decode(b16encoded).decode('utf-8'))#decoded it

if __name__ == '__main__':
    main()
<EOF>
<BOF>
import os
import random
import sys
import rabin_miller as rabinMiller, cryptomath_module as cryptoMath

min_primitive_root = 3


def main():
    print('Making key files...')
    makeKeyFiles('elgamal', 2048)
    print('Key files generation successful')


# I have written my code naively same as definition of primitive root
# however every time I run this program, memory exceeded...
# so I used 4.80 Algorithm in Handbook of Applied Cryptography(CRC Press, ISBN : 0-8493-8523-7, October 1996)
# and it seems to run nicely!
def primitiveRoot(p_val):
    print("Generating primitive root of p")
    while True:
        g = random.randrange(3,p_val)
        if pow(g, 2, p_val) == 1:
            continue
        if pow(g, p_val, p_val) == 1:
            continue
        return g


def generateKey(keySize):
    print('Generating prime p...')
    p = rabinMiller.generateLargePrime(keySize)  # select large prime number.
    e_1 = primitiveRoot(p)  # one primitive root on modulo p.
    d = random.randrange(3, p)  # private_key -> have to be greater than 2 for safety.
    e_2 = cryptoMath.findModInverse(pow(e_1, d, p), p)

    publicKey = (keySize, e_1, e_2, p)
    privateKey = (keySize, d)

    return publicKey, privateKey


def makeKeyFiles(name, keySize):
    if os.path.exists('%s_pubkey.txt' % name) or os.path.exists('%s_privkey.txt' % name):
        print('\nWARNING:')
        print('"%s_pubkey.txt" or "%s_privkey.txt" already exists. \n'
              'Use a different name or delete these files and re-run this program.' %
              (name, name))
        sys.exit()

    publicKey, privateKey = generateKey(keySize)
    print('\nWriting public key to file %s_pubkey.txt...' % name)
    with open('%s_pubkey.txt' % name, 'w') as fo:
        fo.write('%d,%d,%d,%d' % (publicKey[0], publicKey[1], publicKey[2], publicKey[3]))

    print('Writing private key to file %s_privkey.txt...' % name)
    with open('%s_privkey.txt' % name, 'w') as fo:
        fo.write('%d,%d' % (privateKey[0], privateKey[1]))


if __name__ == '__main__':
    main()
    
<EOF>
<BOF>
from __future__ import print_function
def decrypt(message):
    """
    >>> decrypt('TMDETUX PMDVU')
    Decryption using Key #0: TMDETUX PMDVU
    Decryption using Key #1: SLCDSTW OLCUT
    Decryption using Key #2: RKBCRSV NKBTS
    Decryption using Key #3: QJABQRU MJASR
    Decryption using Key #4: PIZAPQT LIZRQ
    Decryption using Key #5: OHYZOPS KHYQP
    Decryption using Key #6: NGXYNOR JGXPO
    Decryption using Key #7: MFWXMNQ IFWON
    Decryption using Key #8: LEVWLMP HEVNM
    Decryption using Key #9: KDUVKLO GDUML
    Decryption using Key #10: JCTUJKN FCTLK
    Decryption using Key #11: IBSTIJM EBSKJ
    Decryption using Key #12: HARSHIL DARJI
    Decryption using Key #13: GZQRGHK CZQIH
    Decryption using Key #14: FYPQFGJ BYPHG
    Decryption using Key #15: EXOPEFI AXOGF
    Decryption using Key #16: DWNODEH ZWNFE
    Decryption using Key #17: CVMNCDG YVMED
    Decryption using Key #18: BULMBCF XULDC
    Decryption using Key #19: ATKLABE WTKCB
    Decryption using Key #20: ZSJKZAD VSJBA
    Decryption using Key #21: YRIJYZC URIAZ
    Decryption using Key #22: XQHIXYB TQHZY
    Decryption using Key #23: WPGHWXA SPGYX
    Decryption using Key #24: VOFGVWZ ROFXW
    Decryption using Key #25: UNEFUVY QNEWV
    """
    LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    for key in range(len(LETTERS)):
        translated = ""
        for symbol in message:
            if symbol in LETTERS:
                num = LETTERS.find(symbol)
                num = num - key
                if num < 0:
                    num = num + len(LETTERS)
                translated = translated + LETTERS[num]
            else:
                translated = translated + symbol
        print("Decryption using Key #%s: %s" % (key, translated))

def main():
    message = input("Encrypted message: ")
    message = message.upper()
    decrypt(message)

if __name__ == '__main__':
    import doctest
    doctest.testmod()
    main()
<EOF>
<BOF>
from __future__ import print_function
import time, os, sys
import transposition_cipher as transCipher

def main():
    inputFile = 'Prehistoric Men.txt'
    outputFile = 'Output.txt'
    key = int(input('Enter key: '))
    mode = input('Encrypt/Decrypt [e/d]: ')

    if not os.path.exists(inputFile):
        print('File %s does not exist. Quitting...' % inputFile)
        sys.exit()
    if os.path.exists(outputFile):
        print('Overwrite %s? [y/n]' % outputFile)
        response = input('> ')
        if not response.lower().startswith('y'):
            sys.exit()
            
    startTime = time.time()
    if mode.lower().startswith('e'):
        content = open(inputFile).read()
        translated = transCipher.encryptMessage(key, content)
    elif mode.lower().startswith('d'):
        content = open(outputFile).read()
        translated =transCipher .decryptMessage(key, content)

    outputObj = open(outputFile, 'w')
    outputObj.write(translated)
    outputObj.close()
    
    totalTime = round(time.time() - startTime, 2)
    print(('Done (', totalTime, 'seconds )'))
    
if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function
import random, sys, os
import rabin_miller as rabinMiller, cryptomath_module as cryptoMath

def main():
    print('Making key files...')
    makeKeyFiles('rsa', 1024)
    print('Key files generation successful.')

def generateKey(keySize):
    print('Generating prime p...')
    p = rabinMiller.generateLargePrime(keySize)
    print('Generating prime q...')
    q = rabinMiller.generateLargePrime(keySize)
    n = p * q

    print('Generating e that is relatively prime to (p - 1) * (q - 1)...')
    while True:
        e = random.randrange(2 ** (keySize - 1), 2 ** (keySize))
        if cryptoMath.gcd(e, (p - 1) * (q - 1)) == 1:
            break

    print('Calculating d that is mod inverse of e...')
    d = cryptoMath.findModInverse(e, (p - 1) * (q - 1))

    publicKey = (n, e)
    privateKey = (n, d)
    return (publicKey, privateKey)

def makeKeyFiles(name, keySize):
    if os.path.exists('%s_pubkey.txt' % (name)) or os.path.exists('%s_privkey.txt' % (name)):
        print('\nWARNING:')
        print('"%s_pubkey.txt" or "%s_privkey.txt" already exists. \nUse a different name or delete these files and re-run this program.' % (name, name))
        sys.exit()

    publicKey, privateKey = generateKey(keySize)
    print('\nWriting public key to file %s_pubkey.txt...' % name)
    with open('%s_pubkey.txt' % name, 'w') as fo:
        fo.write('%s,%s,%s' % (keySize, publicKey[0], publicKey[1]))

    print('Writing private key to file %s_privkey.txt...' % name)
    with open('%s_privkey.txt' % name, 'w') as fo:
        fo.write('%s,%s,%s' % (keySize, privateKey[0], privateKey[1]))

if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function
import sys, random, cryptomath_module as cryptoMath

SYMBOLS = """ !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~"""

def main():
    message = input('Enter message: ')
    key = int(input('Enter key [2000 - 9000]: '))
    mode = input('Encrypt/Decrypt [E/D]: ')

    if mode.lower().startswith('e'):
              mode = 'encrypt'
              translated = encryptMessage(key, message)
    elif mode.lower().startswith('d'):
              mode = 'decrypt'
              translated = decryptMessage(key, message)
    print('\n%sed text: \n%s' % (mode.title(), translated))

def getKeyParts(key):
    keyA = key // len(SYMBOLS)
    keyB = key % len(SYMBOLS)
    return (keyA, keyB)

def checkKeys(keyA, keyB, mode):
    if keyA == 1 and mode == 'encrypt':
        sys.exit('The affine cipher becomes weak when key A is set to 1. Choose different key')
    if keyB == 0 and mode == 'encrypt':
        sys.exit('The affine cipher becomes weak when key A is set to 1. Choose different key')
    if keyA < 0 or keyB < 0 or keyB > len(SYMBOLS) - 1:
        sys.exit('Key A must be greater than 0 and key B must be between 0 and %s.' % (len(SYMBOLS) - 1))
    if cryptoMath.gcd(keyA, len(SYMBOLS)) != 1:
        sys.exit('Key A %s and the symbol set size %s are not relatively prime. Choose a different key.' % (keyA, len(SYMBOLS)))

def encryptMessage(key, message):
    '''
    >>> encryptMessage(4545, 'The affine cipher is a type of monoalphabetic substitution cipher.')
    'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF{xIp~{HL}Gi'
    '''
    keyA, keyB = getKeyParts(key)
    checkKeys(keyA, keyB, 'encrypt')
    cipherText = ''
    for symbol in message:
        if symbol in SYMBOLS:
            symIndex = SYMBOLS.find(symbol)
            cipherText += SYMBOLS[(symIndex * keyA + keyB) % len(SYMBOLS)]
        else:
            cipherText += symbol
    return cipherText

def decryptMessage(key, message):
    '''
    >>> decryptMessage(4545, 'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF{xIp~{HL}Gi')
    'The affine cipher is a type of monoalphabetic substitution cipher.'
    '''
    keyA, keyB = getKeyParts(key)
    checkKeys(keyA, keyB, 'decrypt')
    plainText = ''
    modInverseOfkeyA = cryptoMath.findModInverse(keyA, len(SYMBOLS))
    for symbol in message:
        if symbol in SYMBOLS:
            symIndex = SYMBOLS.find(symbol)
            plainText += SYMBOLS[(symIndex - keyB) * modInverseOfkeyA % len(SYMBOLS)]
        else:
            plainText += symbol
    return plainText

def getRandomKey():
    while True:
        keyA = random.randint(2, len(SYMBOLS))
        keyB = random.randint(2, len(SYMBOLS))
        if cryptoMath.gcd(keyA, len(SYMBOLS)) == 1:
            return keyA * len(SYMBOLS) + keyB

if __name__ == '__main__':
    import doctest
    doctest.testmod()
    main()
<EOF>
<BOF>
from __future__ import print_function
LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

def main():
    message = input('Enter message: ')
    key = input('Enter key [alphanumeric]: ')
    mode = input('Encrypt/Decrypt [e/d]: ')

    if mode.lower().startswith('e'):
        mode = 'encrypt'
        translated = encryptMessage(key, message)
    elif mode.lower().startswith('d'):
        mode = 'decrypt'
        translated = decryptMessage(key, message)

    print('\n%sed message:' % mode.title())
    print(translated)

def encryptMessage(key, message):
    '''
    >>> encryptMessage('HDarji', 'This is Harshil Darji from Dharmaj.')
    'Akij ra Odrjqqs Gaisq muod Mphumrs.'
    '''
    return translateMessage(key, message, 'encrypt')

def decryptMessage(key, message):
    '''
    >>> decryptMessage('HDarji', 'Akij ra Odrjqqs Gaisq muod Mphumrs.')
    'This is Harshil Darji from Dharmaj.'
    '''
    return translateMessage(key, message, 'decrypt')

def translateMessage(key, message, mode):
    translated = []
    keyIndex = 0
    key = key.upper()

    for symbol in message:
        num = LETTERS.find(symbol.upper())
        if num != -1:
            if mode == 'encrypt':
                num += LETTERS.find(key[keyIndex])
            elif mode == 'decrypt':
                num -= LETTERS.find(key[keyIndex])

            num %= len(LETTERS)

            if symbol.isupper():
                translated.append(LETTERS[num])
            elif symbol.islower():
                translated.append(LETTERS[num].lower())

            keyIndex += 1
            if keyIndex == len(key):
                keyIndex = 0
        else:
            translated.append(symbol)
    return ''.join(translated)

if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function
# Primality Testing with the Rabin-Miller Algorithm

import random

def rabinMiller(num):
    s = num - 1
    t = 0

    while s % 2 == 0:
        s = s // 2
        t += 1

    for trials in range(5):
        a = random.randrange(2, num - 1)
        v = pow(a, s, num)
        if v != 1:
            i = 0
            while v != (num - 1):
                if i == t - 1:
                    return False
                else:
                    i = i + 1
                    v = (v ** 2) % num
    return True

def isPrime(num):
    if (num < 2):
        return False

    lowPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,
                 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,
                 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191,
                 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,
                 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331,
                 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,
                 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,
                 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,
                 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631,
                 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709,
                 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
                 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,
                 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967,
                 971, 977, 983, 991, 997]

    if num in lowPrimes:
        return True

    for prime in lowPrimes:
        if (num % prime) == 0:
            return False

    return rabinMiller(num)

def generateLargePrime(keysize = 1024):
    while True:
        num = random.randrange(2 ** (keysize - 1), 2 ** (keysize))
        if isPrime(num):
            return num

if __name__ == '__main__':
    num = generateLargePrime()
    print(('Prime number:', num))
    print(('isPrime:', isPrime(num)))
<EOF>
<BOF>
import string
import itertools

def chunker(seq, size):
    it = iter(seq)
    while True:
       chunk = tuple(itertools.islice(it, size))
       if not chunk:
           return
       yield chunk



def prepare_input(dirty):
    """
    Prepare the plaintext by up-casing it
    and separating repeated letters with X's
    """
    
    dirty = ''.join([c.upper() for c in dirty if c in string.ascii_letters])
    clean = ""
    
    if len(dirty) < 2:
        return dirty

    for i in range(len(dirty)-1):
        clean += dirty[i]
        
        if dirty[i] == dirty[i+1]:
            clean += 'X'
    
    clean += dirty[-1]

    if len(clean) & 1:
        clean += 'X'

    return clean

def generate_table(key):

    # I and J are used interchangeably to allow
    # us to use a 5x5 table (25 letters)
    alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ"
    # we're using a list instead of a '2d' array because it makes the math 
    # for setting up the table and doing the actual encoding/decoding simpler
    table = []

    # copy key chars into the table if they are in `alphabet` ignoring duplicates
    for char in key.upper():
        if char not in table and char in alphabet:
            table.append(char)

    # fill the rest of the table in with the remaining alphabet chars
    for char in alphabet:
        if char not in table:
            table.append(char)

    return table

def encode(plaintext, key):
    table = generate_table(key)
    plaintext = prepare_input(plaintext)
    ciphertext = ""

    # https://en.wikipedia.org/wiki/Playfair_cipher#Description
    for char1, char2 in chunker(plaintext, 2):
        row1, col1 = divmod(table.index(char1), 5)
        row2, col2 = divmod(table.index(char2), 5)

        if row1 == row2:
            ciphertext += table[row1*5+(col1+1)%5]
            ciphertext += table[row2*5+(col2+1)%5]
        elif col1 == col2:
            ciphertext += table[((row1+1)%5)*5+col1]
            ciphertext += table[((row2+1)%5)*5+col2]
        else: # rectangle
            ciphertext += table[row1*5+col2]
            ciphertext += table[row2*5+col1]

    return ciphertext


def decode(ciphertext, key):
    table = generate_table(key)
    plaintext = ""

    # https://en.wikipedia.org/wiki/Playfair_cipher#Description
    for char1, char2 in chunker(ciphertext, 2):
        row1, col1 = divmod(table.index(char1), 5)
        row2, col2 = divmod(table.index(char2), 5)

        if row1 == row2:
            plaintext += table[row1*5+(col1-1)%5]
            plaintext += table[row2*5+(col2-1)%5]
        elif col1 == col2:
            plaintext += table[((row1-1)%5)*5+col1]
            plaintext += table[((row2-1)%5)*5+col2]
        else: # rectangle
            plaintext += table[row1*5+col2]
            plaintext += table[row2*5+col1]

    return plaintext
<EOF>
<BOF>
from __future__ import print_function
def dencrypt(s, n):
    out = ''
    for c in s:
        if c >= 'A' and c <= 'Z':
            out += chr(ord('A') + (ord(c) - ord('A') + n) % 26)
        elif c >= 'a' and c <= 'z':
            out += chr(ord('a') + (ord(c) - ord('a') + n) % 26)
        else:
            out += c
    return out


def main():
    s0 = 'HELLO'

    s1 = dencrypt(s0, 13)
    print(s1)  # URYYB

    s2 = dencrypt(s1, 13)
    print(s2)  # HELLO


if __name__ == '__main__':
    main()
<EOF>
<BOF>
import sys
def encrypt(strng, key):
    encrypted = ''
    for x in strng:
        indx = (ord(x) + key) % 256
        if indx > 126:
            indx = indx - 95
        encrypted = encrypted + chr(indx)
    return encrypted


def decrypt(strng, key):
    decrypted = ''
    for x in strng:
        indx = (ord(x) - key) % 256
        if indx < 32:
            indx = indx + 95
        decrypted = decrypted + chr(indx)
    return decrypted

def brute_force(strng):
    key = 1
    decrypted = ''
    while key <= 94:
        for x in strng:
            indx = (ord(x) - key) % 256
            if indx < 32:
                indx = indx + 95
            decrypted = decrypted + chr(indx)
        print("Key: {}\t| Message: {}".format(key, decrypted))
        decrypted = ''
        key += 1
    return None


def main():
    while True:
        print('-' * 10 + "\n**Menu**\n" + '-' * 10)
        print("1.Encrpyt")
        print("2.Decrypt")
        print("3.BruteForce")
        print("4.Quit")
        choice = input("What would you like to do?: ")
        if choice not in ['1', '2', '3', '4']:
            print ("Invalid choice")
        elif choice == '1':
            strng = input("Please enter the string to be ecrypted: ")
            key = int(input("Please enter off-set between 1-94: "))
            if key in range(1, 95):
                print (encrypt(strng.lower(), key))
        elif choice == '2':
            strng = input("Please enter the string to be decrypted: ")
            key = int(input("Please enter off-set between 1-94: "))
            if key > 0 and key <= 94:
                print(decrypt(strng, key))
        elif choice == '3':
            strng = input("Please enter the string to be decrypted: ")
            brute_force(strng)
            main()
        elif choice == '4':
            print ("Goodbye.")
            break
main()
<EOF>
<BOF>
def gcd(a, b):
    while a != 0:
        a, b = b % a, a
    return b

def findModInverse(a, m):
    if gcd(a, m) != 1:
        return None
    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m
    while v3 != 0:
        q = u3 // v3
        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q *v3), v1, v2, v3
    return u1 % m     
<EOF>
<BOF>
import base64

def main():
    inp = input('->')
    encoded = inp.encode('utf-8') #encoded the input (we need a bytes like object)
    b32encoded = base64.b32encode(encoded) #b32encoded the encoded string
    print(b32encoded)
    print(base64.b32decode(b32encoded).decode('utf-8'))#decoded it

if __name__ == '__main__':
    main()
<EOF>
<BOF>
"""
	author: Christian Bender
	date: 21.12.2017
	class: XORCipher

	This class implements the XOR-cipher algorithm and provides
	some useful methods for encrypting and decrypting strings and
	files.

	Overview about methods

	- encrypt : list of char
	- decrypt : list of char
	- encrypt_string : str
	- decrypt_string : str
	- encrypt_file : boolean
	- decrypt_file : boolean
"""
class XORCipher(object):

	def __init__(self, key = 0):
		"""
			simple constructor that receives a key or uses
			default key = 0
		"""

		#private field
		self.__key = key

	def encrypt(self, content, key):
		"""
			input: 'content' of type string and 'key' of type int
			output: encrypted string 'content' as a list of chars
			if key not passed the method uses the key by the constructor.
			otherwise key = 1
		"""

		# precondition
		assert (isinstance(key,int) and isinstance(content,str))

		key = key or self.__key or 1

		# make sure key can be any size
		while (key > 255):
			key -= 255

		# This will be returned
		ans = []

		for ch in content:
			ans.append(chr(ord(ch) ^ key))

		return ans

	def decrypt(self,content,key):
		"""
			input: 'content' of type list and 'key' of type int
			output: decrypted string 'content' as a list of chars
			if key not passed the method uses the key by the constructor.
			otherwise key = 1
		"""

		# precondition
		assert (isinstance(key,int) and isinstance(content,list))

		key = key or self.__key or 1

		# make sure key can be any size
		while (key > 255):
			key -= 255

		# This will be returned
		ans = []

		for ch in content:
			ans.append(chr(ord(ch) ^ key))

		return ans


	def encrypt_string(self,content, key = 0):
		"""
			input: 'content' of type string and 'key' of type int
			output: encrypted string 'content'
			if key not passed the method uses the key by the constructor.
			otherwise key = 1
		"""

		# precondition
		assert (isinstance(key,int) and isinstance(content,str))

		key = key or self.__key or 1

		# make sure key can be any size
		while (key > 255):
			key -= 255

		# This will be returned
		ans = ""

		for ch in content:
			ans += chr(ord(ch) ^ key)

		return ans

	def decrypt_string(self,content,key = 0):
		"""
			input: 'content' of type string and 'key' of type int
			output: decrypted string 'content'
			if key not passed the method uses the key by the constructor.
			otherwise key = 1
		"""

		# precondition
		assert (isinstance(key,int) and isinstance(content,str))

		key = key or self.__key or 1

		# make sure key can be any size
		while (key > 255):
			key -= 255

		# This will be returned
		ans = ""
		
		for ch in content:
			ans += chr(ord(ch) ^ key)

		return ans


	def encrypt_file(self, file, key = 0):
		"""
			input: filename (str) and a key (int)
			output: returns true if encrypt process was
			successful otherwise false
			if key not passed the method uses the key by the constructor.
			otherwise key = 1
		"""

		#precondition
		assert (isinstance(file,str) and isinstance(key,int))

		try:
			with open(file,"r") as fin:
				with open("encrypt.out","w+") as fout:

					# actual encrypt-process
					for line in fin:
						fout.write(self.encrypt_string(line,key))

		except:
			return False

		return True


	def decrypt_file(self,file, key):
		"""
			input: filename (str) and a key (int)
			output: returns true if decrypt process was
			successful otherwise false
			if key not passed the method uses the key by the constructor.
			otherwise key = 1
		"""

		#precondition
		assert (isinstance(file,str) and isinstance(key,int))

		try:
			with open(file,"r") as fin:
				with open("decrypt.out","w+") as fout:

					# actual encrypt-process
					for line in fin:
						fout.write(self.decrypt_string(line,key))

		except:
			return False

		return True




# Tests
# crypt = XORCipher()
# key = 67

# # test enrcypt
# print crypt.encrypt("hallo welt",key)
# # test decrypt
# print crypt.decrypt(crypt.encrypt("hallo welt",key), key)

# # test encrypt_string
# print crypt.encrypt_string("hallo welt",key)

# # test decrypt_string
# print crypt.decrypt_string(crypt.encrypt_string("hallo welt",key),key)

# if (crypt.encrypt_file("test.txt",key)):
# 	print "encrypt successful"
# else:
# 	print "encrypt unsuccessful"

# if (crypt.decrypt_file("encrypt.out",key)):
# 	print "decrypt successful"
# else:
# 	print "decrypt unsuccessful"
<EOF>
<BOF>
import base64

def main():
    inp = input('->')
    encoded = inp.encode('utf-8') #encoded the input (we need a bytes like object)
    b64encoded = base64.b64encode(encoded) #b64encoded the encoded string
    print(b64encoded)
    print(base64.b64decode(b64encoded).decode('utf-8'))#decoded it

if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function

import random


class Onepad:
    def encrypt(self, text):
        '''Function to encrypt text using psedo-random numbers'''
        plain = [ord(i) for i in text]
        key = []
        cipher = []
        for i in plain:
            k = random.randint(1, 300)
            c = (i+k)*k
            cipher.append(c)
            key.append(k)
        return cipher, key
    
    def decrypt(self, cipher, key):
        '''Function to decrypt text using psedo-random numbers.'''
        plain = []
        for i in range(len(key)):
            p = int((cipher[i]-(key[i])**2)/key[i])
            plain.append(chr(p))
        plain = ''.join([i for i in plain])
        return plain


if __name__ == '__main__':
    c, k = Onepad().encrypt('Hello')
    print(c, k)
    print(Onepad().decrypt(c, k))
<EOF>
<BOF>
from __future__ import print_function
import sys, rsa_key_generator as rkg, os

DEFAULT_BLOCK_SIZE = 128
BYTE_SIZE = 256

def main():
    filename = 'encrypted_file.txt'
    response = input('Encrypte\Decrypt [e\d]: ')

    if response.lower().startswith('e'):
        mode = 'encrypt'
    elif response.lower().startswith('d'):
        mode = 'decrypt'

    if mode == 'encrypt':
        if not os.path.exists('rsa_pubkey.txt'):
            rkg.makeKeyFiles('rsa', 1024)
            
        message = input('\nEnter message: ')
        pubKeyFilename = 'rsa_pubkey.txt'
        print('Encrypting and writing to %s...' % (filename))
        encryptedText = encryptAndWriteToFile(filename, pubKeyFilename, message)

        print('\nEncrypted text:')
        print(encryptedText)

    elif mode == 'decrypt':
        privKeyFilename = 'rsa_privkey.txt'
        print('Reading from %s and decrypting...' % (filename))
        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)
        print('writing decryption to rsa_decryption.txt...')
        with open('rsa_decryption.txt', 'w') as dec:
            dec.write(decryptedText)

        print('\nDecryption:')
        print(decryptedText)


def getBlocksFromText(message, blockSize=DEFAULT_BLOCK_SIZE):
    messageBytes = message.encode('ascii')

    blockInts = []
    for blockStart in range(0, len(messageBytes), blockSize):
        blockInt = 0
        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):
            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))
        blockInts.append(blockInt)
    return blockInts


def getTextFromBlocks(blockInts, messageLength, blockSize=DEFAULT_BLOCK_SIZE):
    message = []
    for blockInt in blockInts:
        blockMessage = []
        for i in range(blockSize - 1, -1, -1):
            if len(message) + i < messageLength:
                asciiNumber = blockInt // (BYTE_SIZE ** i)
                blockInt = blockInt % (BYTE_SIZE ** i)
                blockMessage.insert(0, chr(asciiNumber))
        message.extend(blockMessage)
    return ''.join(message)


def encryptMessage(message, key, blockSize=DEFAULT_BLOCK_SIZE):
    encryptedBlocks = []
    n, e = key

    for block in getBlocksFromText(message, blockSize):
        encryptedBlocks.append(pow(block, e, n))
    return encryptedBlocks


def decryptMessage(encryptedBlocks, messageLength, key, blockSize=DEFAULT_BLOCK_SIZE):
    decryptedBlocks = []
    n, d = key
    for block in encryptedBlocks:
        decryptedBlocks.append(pow(block, d, n))
    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)


def readKeyFile(keyFilename):
    fo = open(keyFilename)
    content = fo.read()
    fo.close()
    keySize, n, EorD = content.split(',')
    return (int(keySize), int(n), int(EorD))


def encryptAndWriteToFile(messageFilename, keyFilename, message, blockSize=DEFAULT_BLOCK_SIZE):
    keySize, n, e = readKeyFile(keyFilename)
    if keySize < blockSize * 8:
        sys.exit('ERROR: Block size is %s bits and key size is %s bits. The RSA cipher requires the block size to be equal to or greater than the key size. Either decrease the block size or use different keys.' % (blockSize * 8, keySize))

    encryptedBlocks = encryptMessage(message, (n, e), blockSize)

    for i in range(len(encryptedBlocks)):
        encryptedBlocks[i] = str(encryptedBlocks[i])
    encryptedContent = ','.join(encryptedBlocks)
    encryptedContent = '%s_%s_%s' % (len(message), blockSize, encryptedContent)
    fo = open(messageFilename, 'w')
    fo.write(encryptedContent)
    fo.close()
    return encryptedContent


def readFromFileAndDecrypt(messageFilename, keyFilename):
    keySize, n, d = readKeyFile(keyFilename)
    fo = open(messageFilename)
    content = fo.read()
    messageLength, blockSize, encryptedMessage = content.split('_')
    messageLength = int(messageLength)
    blockSize = int(blockSize)

    if keySize < blockSize * 8:
        sys.exit('ERROR: Block size is %s bits and key size is %s bits. The RSA cipher requires the block size to be equal to or greater than the key size. Did you specify the correct key file and encrypted file?' % (blockSize * 8, keySize))

    encryptedBlocks = []
    for block in encryptedMessage.split(','):
        encryptedBlocks.append(int(block))

    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)

if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function
import math

def main():
    message = input('Enter message: ')
    key = int(input('Enter key [2-%s]: ' % (len(message) - 1)))
    mode = input('Encryption/Decryption [e/d]: ')

    if mode.lower().startswith('e'):
        text = encryptMessage(key, message)
    elif mode.lower().startswith('d'):
        text = decryptMessage(key, message)

    # Append pipe symbol (vertical bar) to identify spaces at the end.
    print('Output:\n%s' %(text + '|'))

def encryptMessage(key, message):
    """
    >>> encryptMessage(6, 'Harshil Darji')
    'Hlia rDsahrij'
    """
    cipherText = [''] * key
    for col in range(key):
        pointer = col
        while pointer < len(message):
            cipherText[col] += message[pointer]
            pointer += key
    return ''.join(cipherText)

def decryptMessage(key, message):
    """
    >>> decryptMessage(6, 'Hlia rDsahrij')
    'Harshil Darji'
    """
    numCols = math.ceil(len(message) / key)
    numRows = key
    numShadedBoxes = (numCols * numRows) - len(message)
    plainText = [""] * numCols
    col = 0; row = 0;

    for symbol in message:
        plainText[col] += symbol
        col += 1

        if (col == numCols) or (col == numCols - 1) and (row >= numRows - numShadedBoxes):
            col = 0
            row += 1

    return "".join(plainText)

if __name__ == '__main__':
    import doctest
    doctest.testmod()
    main()
<EOF>
<BOF>
import base64

def main():
    inp = input('->')
    encoded = inp.encode('utf-8') #encoded the input (we need a bytes like object)
    a85encoded = base64.a85encode(encoded) #a85encoded the encoded string
    print(a85encoded)
    print(base64.a85decode(a85encoded).decode('utf-8'))#decoded it

if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function
import sys, random

LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

def main():
    message = input('Enter message: ')
    key = 'LFWOAYUISVKMNXPBDCRJTQEGHZ'
    resp = input('Encrypt/Decrypt [e/d]: ')

    checkValidKey(key)

    if resp.lower().startswith('e'):
        mode = 'encrypt'
        translated = encryptMessage(key, message)
    elif resp.lower().startswith('d'):
        mode = 'decrypt'
        translated = decryptMessage(key, message)

    print('\n%sion: \n%s' % (mode.title(), translated))
    
def checkValidKey(key):
    keyList = list(key)
    lettersList = list(LETTERS)
    keyList.sort()
    lettersList.sort()

    if keyList != lettersList:
        sys.exit('Error in the key or symbol set.')

def encryptMessage(key, message):
    """
    >>> encryptMessage('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Harshil Darji')
    'Ilcrism Olcvs'
    """
    return translateMessage(key, message, 'encrypt')

def decryptMessage(key, message):
    """
    >>> decryptMessage('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Ilcrism Olcvs')
    'Harshil Darji'
    """
    return translateMessage(key, message, 'decrypt')

def translateMessage(key, message, mode):
    translated = ''
    charsA = LETTERS
    charsB = key

    if mode == 'decrypt':
        charsA, charsB = charsB, charsA
        
    for symbol in message:
        if symbol.upper() in charsA:
            symIndex = charsA.find(symbol.upper())
            if symbol.isupper():
                translated += charsB[symIndex].upper()
            else:
                translated += charsB[symIndex].lower()
        else:
            translated += symbol

    return translated

def getRandomKey():
    key = list(LETTERS)
    random.shuffle(key)
    return ''.join(key)

if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function
# https://en.wikipedia.org/wiki/Euclidean_algorithm

def euclidean_gcd(a, b):
    while b:
        t = b
        b = a % b
        a = t
    return a

def main():
    print("GCD(3, 5) = " + str(euclidean_gcd(3, 5)))
    print("GCD(5, 3) = " + str(euclidean_gcd(5, 3)))
    print("GCD(1, 3) = " + str(euclidean_gcd(1, 3)))
    print("GCD(3, 6) = " + str(euclidean_gcd(3, 6)))
    print("GCD(6, 3) = " + str(euclidean_gcd(6, 3)))

if __name__ == '__main__':
    main()
<EOF>
<BOF>
"""
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
"""
from __future__ import print_function

def twoSum(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    """
    chk_map = {}
    for index, val in enumerate(nums):
      compl = target - val
      if compl in chk_map: 
        indices = [chk_map[compl], index]
        print(indices)
        return [indices]
      else:
        chk_map[val] = index
    return False
<EOF>
<BOF>
"""
* Binary Exponentiation for Powers
* This is a method to find a^b in a time complexity of O(log b)
* This is one of the most commonly used methods of finding powers.
* Also useful in cases where solution to (a^b)%c is required,
* where a,b,c can be numbers over the computers calculation limits.
* Done using iteration, can also be done using recursion

* @author chinmoy159
* @version 1.0 dated 10/08/2017
"""


def b_expo(a, b):
    res = 1
    while b > 0:
        if b&1:
            res *= a

        a *= a
        b >>= 1

    return res


def b_expo_mod(a, b, c):
    res = 1
    while b > 0:
        if b&1:
            res = ((res%c) * (a%c)) % c

        a *= a
        b >>= 1

    return res

"""
* Wondering how this method works !
* It's pretty simple.
* Let's say you need to calculate a ^ b
* RULE 1 : a ^ b = (a*a) ^ (b/2) ---- example : 4 ^ 4 = (4*4) ^ (4/2) = 16 ^ 2
* RULE 2 : IF b is ODD, then ---- a ^ b = a * (a ^ (b - 1)) :: where (b - 1) is even.
* Once b is even, repeat the process to get a ^ b
* Repeat the process till b = 1 OR b = 0, because a^1 = a AND a^0 = 1
*
* As far as the modulo is concerned,
* the fact : (a*b) % c = ((a%c) * (b%c)) % c
* Now apply RULE 1 OR 2 whichever is required.
"""
<EOF>
<BOF>
#!/usr/bin/python
# encoding=utf8

'''Author Anurag Kumar | anuragkumarak95@gmail.com | git/anuragkumarak95

Simple example of Fractal generation using recursive function.

What is Sierpinski Triangle?
>>The Sierpinski triangle (also with the original orthography Sierpinski), also called the Sierpinski gasket or the Sierpinski Sieve, 
is a fractal and attractive fixed set with the overall shape of an equilateral triangle, subdivided recursively into smaller 
equilateral triangles. Originally constructed as a curve, this is one of the basic examples of self-similar sets, i.e., 
it is a mathematically generated pattern that can be reproducible at any magnification or reduction. It is named after 
the Polish mathematician Wacaw Sierpinski, but appeared as a decorative pattern many centuries prior to the work of Sierpinski.

Requirements(pip):
  - turtle

Python:
  - 2.6

Usage:
  - $python sierpinski_triangle.py <int:depth_for_fractal>

Credits: This code was written by editing the code from http://www.lpb-riannetrujillo.com/blog/python-fractal/

'''
import turtle
import sys
PROGNAME = 'Sierpinski Triangle'
if len(sys.argv) !=2: 
    raise Exception('right format for using this script: $python fractals.py <int:depth_for_fractal>')

myPen = turtle.Turtle()
myPen.ht()
myPen.speed(5)
myPen.pencolor('red')

points = [[-175,-125],[0,175],[175,-125]] #size of triangle

def getMid(p1,p2):
    return ( (p1[0]+p2[0]) / 2, (p1[1] + p2[1]) / 2) #find midpoint

def triangle(points,depth):

    myPen.up()
    myPen.goto(points[0][0],points[0][1])
    myPen.down()
    myPen.goto(points[1][0],points[1][1])
    myPen.goto(points[2][0],points[2][1])
    myPen.goto(points[0][0],points[0][1])

    if depth>0:
        triangle([points[0],
                        getMid(points[0], points[1]),
                        getMid(points[0], points[2])],
                   depth-1)
        triangle([points[1],
                        getMid(points[0], points[1]),
                        getMid(points[1], points[2])],
                   depth-1)
        triangle([points[2],
                         getMid(points[2], points[1]),
                         getMid(points[0], points[2])],
                   depth-1)


triangle(points,int(sys.argv[1]))
<EOF>
<BOF>
from __future__ import print_function
import pprint, time

def getWordPattern(word):
    word = word.upper()
    nextNum = 0
    letterNums = {}
    wordPattern = []

    for letter in word:
        if letter not in letterNums:
            letterNums[letter] = str(nextNum)
            nextNum += 1
        wordPattern.append(letterNums[letter])
    return '.'.join(wordPattern)

def main():
    startTime = time.time()
    allPatterns = {}

    with open('Dictionary.txt') as fo:
        wordList = fo.read().split('\n')

    for word in wordList:
        pattern = getWordPattern(word)

        if pattern not in allPatterns:
            allPatterns[pattern] = [word]
        else:
            allPatterns[pattern].append(word)

    with open('Word Patterns.txt', 'w') as fo:
        fo.write(pprint.pformat(allPatterns))

    totalTime = round(time.time() - startTime, 2)
    print(('Done! [', totalTime, 'seconds ]'))

if __name__ == '__main__':
    main()
<EOF>
<BOF>
#!/usr/bin/python
# encoding=utf8
"""
The FisherYates shuffle is an algorithm for generating a random permutation of a finite sequence.
For more details visit
wikipedia/Fischer-Yates-Shuffle.
"""
import random

def FYshuffle(LIST):
    for i in range(len(LIST)):
        a = random.randint(0, len(LIST)-1)
        b = random.randint(0, len(LIST)-1)
        LIST[a], LIST[b] = LIST[b], LIST[a]
    return LIST

if __name__ == '__main__':
    integers = [0,1,2,3,4,5,6,7]
    strings = ['python', 'says', 'hello', '!']
    print ('Fisher-Yates Shuffle:')
    print ('List',integers, strings)
    print ('FY Shuffle',FYshuffle(integers), FYshuffle(strings))
<EOF>
<BOF>
from __future__ import print_function
def moveTower(height, fromPole, toPole, withPole):  
    '''
    >>> moveTower(3, 'A', 'B', 'C')
    moving disk from A to B
    moving disk from A to C
    moving disk from B to C
    moving disk from A to B
    moving disk from C to A
    moving disk from C to B
    moving disk from A to B
    '''
    if height >= 1:
        moveTower(height-1, fromPole, withPole, toPole)
        moveDisk(fromPole, toPole)
        moveTower(height-1, withPole, toPole, fromPole)

def moveDisk(fp,tp):
    print(('moving disk from', fp, 'to', tp))

def main():
    height = int(input('Height of hanoi: '))
    moveTower(height, 'A', 'B', 'C')

if __name__ == '__main__':
    main()
<EOF>
<BOF>
# -*- coding: utf-8 -*-
"""
Created on Thu Oct  5 16:44:23 2017

@author: Christian Bender

This python library contains some useful functions to deal with
prime numbers and whole numbers.

Overview:

isPrime(number)
sieveEr(N)
getPrimeNumbers(N)
primeFactorization(number)
greatestPrimeFactor(number)
smallestPrimeFactor(number)
getPrime(n)
getPrimesBetween(pNumber1, pNumber2) 

----

isEven(number)
isOdd(number)
gcd(number1, number2)  // greatest common divisor
kgV(number1, number2)  // least common multiple
getDivisors(number)    // all divisors of 'number' inclusive 1, number
isPerfectNumber(number)

NEW-FUNCTIONS

simplifyFraction(numerator, denominator)
factorial (n) // n!
fib (n) // calculate the n-th fibonacci term.

-----

goldbach(number)  // Goldbach's assumption

"""

def isPrime(number):
    """
        input: positive integer 'number'
        returns true if 'number' is prime otherwise false.
    """
    import math # for function sqrt
    
    # precondition
    assert isinstance(number,int) and (number >= 0) , \
    "'number' must been an int and positive"
    
    status = True
    
    # 0 and 1 are none primes. 
    if number <= 1:
        status = False
    
    for divisor in range(2,int(round(math.sqrt(number)))+1):
        
        # if 'number' divisible by 'divisor' then sets 'status'
        # of false and break up the loop. 
        if number % divisor == 0:
            status = False
            break
    
    # precondition
    assert isinstance(status,bool), "'status' must been from type bool"    
    
    return status

# ------------------------------------------

def sieveEr(N):
    """
        input: positive integer 'N' > 2
        returns a list of prime numbers from 2 up to N.
        
        This function implements the algorithm called
        sieve of erathostenes.         
        
    """
    
    # precondition
    assert isinstance(N,int) and (N > 2), "'N' must been an int and > 2"
    
    # beginList: conatins all natural numbers from 2 upt to N
    beginList = [x for x in range(2,N+1)]

    ans = [] # this list will be returns.     
    
    # actual sieve of erathostenes
    for i in range(len(beginList)):
        
        for j in range(i+1,len(beginList)):
            
            if (beginList[i] != 0) and \
            (beginList[j] % beginList[i] == 0):
                beginList[j] = 0
    
    # filters actual prime numbers.           
    ans = [x for x in beginList if x != 0]
    
    # precondition
    assert isinstance(ans,list), "'ans' must been from type list"    
    
    return ans
    

# --------------------------------

def getPrimeNumbers(N):
    """
        input: positive integer 'N' > 2
        returns a list of prime numbers from 2 up to N (inclusive)
        This function is more efficient as function 'sieveEr(...)'
    """    
    
    # precondition
    assert isinstance(N,int) and (N > 2), "'N' must been an int and > 2"
    
    ans = []    
    
    # iterates over all numbers between 2 up to N+1 
    # if a number is prime then appends to list 'ans'
    for number in range(2,N+1):
        
        if isPrime(number):
            
            ans.append(number)
   
    # precondition
    assert isinstance(ans,list), "'ans' must been from type list"
        
    return ans


# -----------------------------------------
    
def primeFactorization(number):
    """
        input: positive integer 'number' 
        returns a list of the prime number factors of 'number'
    """

    import math    # for function sqrt
    
    # precondition
    assert isinstance(number,int) and number >= 0, \
    "'number' must been an int and >= 0"
    
    ans = [] # this list will be returns of the function.

    # potential prime number factors.

    factor = 2    

    quotient = number
    
    
    if number == 0 or number == 1:
        
        ans.append(number)
        
    # if 'number' not prime then builds the prime factorization of 'number'    
    elif not isPrime(number):
    
        while (quotient != 1):
            
            if isPrime(factor) and (quotient % factor == 0):
                    ans.append(factor)
                    quotient /= factor
            else:
                    factor += 1
    
    else:
        ans.append(number)
    
    # precondition
    assert isinstance(ans,list), "'ans' must been from type list"    
    
    return ans
    

# -----------------------------------------
    
def greatestPrimeFactor(number):
    """
        input: positive integer 'number' >= 0
        returns the greatest prime number factor of 'number'
    """
    
    # precondition
    assert isinstance(number,int) and (number >= 0), \
    "'number' bust been an int and >= 0"
    
    ans = 0    
    
    # prime factorization of 'number'
    primeFactors = primeFactorization(number)

    ans = max(primeFactors)     
    
    # precondition
    assert isinstance(ans,int), "'ans' must been from type int"    
    
    return ans
    

# ----------------------------------------------
    
    
def smallestPrimeFactor(number):
    """
        input: integer 'number' >= 0
        returns the smallest prime number factor of 'number'
    """
    
    # precondition
    assert isinstance(number,int) and (number >= 0), \
    "'number' bust been an int and >= 0"
    
    ans = 0    
    
    # prime factorization of 'number'
    primeFactors = primeFactorization(number)
    
    ans = min(primeFactors)

    # precondition
    assert isinstance(ans,int), "'ans' must been from type int"    
    
    return ans
    
    
# ----------------------
    
def isEven(number):
    """
        input: integer 'number'
        returns true if 'number' is even, otherwise false.
    """   

    # precondition
    assert isinstance(number, int), "'number' must been an int" 
    assert isinstance(number % 2 == 0, bool), "compare bust been from type bool"
    
    return number % 2 == 0
    
# ------------------------
    
def isOdd(number):
    """
        input: integer 'number'
        returns true if 'number' is odd, otherwise false.
    """   

    # precondition
    assert isinstance(number, int), "'number' must been an int" 
    assert isinstance(number % 2 != 0, bool), "compare bust been from type bool"
    
    return number % 2 != 0
    
# ------------------------
    
    
def goldbach(number):
    """
        Goldbach's assumption
        input: a even positive integer 'number' > 2
        returns a list of two prime numbers whose sum is equal to 'number'
    """
    
    # precondition
    assert isinstance(number,int) and (number > 2) and isEven(number), \
    "'number' must been an int, even and > 2"
    
    ans = [] # this list will returned
    
    # creates a list of prime numbers between 2 up to 'number'
    primeNumbers = getPrimeNumbers(number)
    lenPN = len(primeNumbers)    

    # run variable for while-loops.
    i = 0
    j = 1
    
    # exit variable. for break up the loops
    loop = True
    
    while (i < lenPN and loop):
        
        j = i+1
        
        
        while (j < lenPN and loop):
            
            if primeNumbers[i] + primeNumbers[j] == number:
                loop = False
                ans.append(primeNumbers[i])
                ans.append(primeNumbers[j])
                
            j += 1

        i += 1
        
    # precondition
    assert isinstance(ans,list) and (len(ans) == 2) and \
    (ans[0] + ans[1] == number) and isPrime(ans[0]) and isPrime(ans[1]), \
    "'ans' must contains two primes. And sum of elements must been eq 'number'"
        
    return ans
    
# ----------------------------------------------

def gcd(number1,number2):
    """
        Greatest common divisor
        input: two positive integer 'number1' and 'number2'
        returns the greatest common divisor of 'number1' and 'number2'
    """
    
    # precondition
    assert isinstance(number1,int) and isinstance(number2,int) \
    and (number1 >= 0) and (number2 >= 0), \
    "'number1' and 'number2' must been positive integer."

    rest = 0    
    
    while number2 != 0:
        
        rest = number1 % number2
        number1 = number2
        number2 = rest

    # precondition
    assert isinstance(number1,int) and (number1 >= 0), \
    "'number' must been from type int and positive"    
    
    return number1
    
# ----------------------------------------------------
    
def kgV(number1, number2):
    """
        Least common multiple
        input: two positive integer 'number1' and 'number2'
        returns the least common multiple of 'number1' and 'number2'
    """
    
    # precondition
    assert isinstance(number1,int) and isinstance(number2,int) \
    and (number1 >= 1) and (number2 >= 1), \
    "'number1' and 'number2' must been positive integer."
    
    ans = 1 # actual answer that will be return.
     
    # for kgV (x,1)
    if number1 > 1 and number2 > 1:
        
        # builds the prime factorization of 'number1' and 'number2'
        primeFac1 = primeFactorization(number1)
        primeFac2 = primeFactorization(number2)
        
    elif number1 == 1 or number2 == 1:
        
        primeFac1 = []
        primeFac2 = []
        ans = max(number1,number2)
    
    count1 = 0
    count2 = 0
     
    done = [] # captured numbers int both 'primeFac1' and 'primeFac2'
    
    # iterates through primeFac1
    for n in primeFac1:
        
        if n not in done:
        
            if n in primeFac2:
            
                count1 = primeFac1.count(n)
                count2 = primeFac2.count(n)
            
                for i in range(max(count1,count2)):
                    ans *= n
        
            else:
                
                count1 = primeFac1.count(n)
                
                for i in range(count1):
                    ans *= n
                    
            done.append(n)
    
    # iterates through primeFac2
    for n in primeFac2:
        
        if n not in done:
            
            count2 = primeFac2.count(n)
            
            for i in range(count2):
                ans *= n
                    
            done.append(n)
    
    # precondition
    assert isinstance(ans,int) and (ans >= 0), \
    "'ans' must been from type int and positive"    
    
    return ans
    
# ----------------------------------
    
def getPrime(n):
    """
        Gets the n-th prime number.
        input: positive integer 'n' >= 0
        returns the n-th prime number, beginning at index 0
    """
    
    # precondition
    assert isinstance(n,int) and (n >= 0), "'number' must been a positive int"
    
    index = 0
    ans = 2 # this variable holds the answer
    
    while index < n:
        
        index += 1
        
        ans += 1   # counts to the next number     
        
        # if ans not prime then
        # runs to the next prime number. 
        while not isPrime(ans):
            ans += 1
    
    # precondition
    assert isinstance(ans,int) and isPrime(ans), \
    "'ans' must been a prime number and from type int"    
    
    return ans
    
# ---------------------------------------------------
    
def getPrimesBetween(pNumber1, pNumber2):
    """
        input: prime numbers 'pNumber1' and 'pNumber2'
                pNumber1 < pNumber2
        returns a list of all prime numbers between 'pNumber1' (exclusiv)
                and 'pNumber2' (exclusiv) 
    """
    
    # precondition
    assert isPrime(pNumber1) and isPrime(pNumber2) and (pNumber1 < pNumber2), \
    "The arguments must been prime numbers and 'pNumber1' < 'pNumber2'"
    
    number = pNumber1 + 1 # jump to the next number
    
    ans = [] # this list will be returns.
    
    # if number is not prime then
    # fetch the next prime number. 
    while not isPrime(number):
        number += 1
    
    while number < pNumber2:
        
        ans.append(number)
        
        number += 1
        
        # fetch the next prime number. 
        while not isPrime(number):
            number += 1
            
    # precondition
    assert isinstance(ans,list) and ans[0] != pNumber1 \
    and ans[len(ans)-1] != pNumber2, \
    "'ans' must been a list without the arguments"
            
    # 'ans' contains not 'pNumber1' and 'pNumber2' !
    return ans
    
# ----------------------------------------------------

def getDivisors(n):
    """
        input: positive integer 'n' >= 1
        returns all divisors of n (inclusive 1 and 'n')
    """
    
    # precondition
    assert isinstance(n,int) and (n >= 1), "'n' must been int and >= 1"

    from math import sqrt        
        
    ans = [] # will be returned.
    
    for divisor in range(1,n+1):
        
        if n % divisor == 0:
            ans.append(divisor)
       
       
    #precondition
    assert ans[0] == 1 and ans[len(ans)-1] == n, \
    "Error in function getDivisiors(...)"
    
    
    return ans


# ----------------------------------------------------


def isPerfectNumber(number):
    """
        input: positive integer 'number' > 1
        returns true if 'number' is a perfect number otherwise false.
    """
    
    # precondition
    assert isinstance(number,int) and (number > 1), \
    "'number' must been an int and >= 1"
    
    divisors = getDivisors(number)
 
    # precondition
    assert isinstance(divisors,list) and(divisors[0] == 1) and  \
    (divisors[len(divisors)-1] == number), \
    "Error in help-function getDivisiors(...)"
    
    # summed all divisors up to 'number' (exclusive), hence [:-1]
    return sum(divisors[:-1]) == number

# ------------------------------------------------------------

def simplifyFraction(numerator, denominator):
    """
        input: two integer 'numerator' and 'denominator'
        assumes: 'denominator' != 0
        returns: a tuple with simplify numerator and denominator.
    """      
    
    # precondition
    assert isinstance(numerator, int) and isinstance(denominator,int) \
    and (denominator != 0), \
    "The arguments must been from type int and 'denominator' != 0"
    
    # build the greatest common divisor of numerator and denominator.
    gcdOfFraction = gcd(abs(numerator), abs(denominator))

    # precondition
    assert isinstance(gcdOfFraction, int) and (numerator % gcdOfFraction == 0) \
    and (denominator % gcdOfFraction == 0), \
    "Error in function gcd(...,...)"
    
    return (numerator // gcdOfFraction, denominator // gcdOfFraction)
    
# -----------------------------------------------------------------
    
def factorial(n):
    """
        input: positive integer 'n'
        returns the factorial of 'n' (n!)
    """
    
    # precondition
    assert isinstance(n,int) and (n >= 0), "'n' must been a int and >= 0"
    
    ans = 1 # this will be return.
    
    for factor in range(1,n+1):
        ans *= factor
    
    return ans
    
# -------------------------------------------------------------------
    
def fib(n):
    """
        input: positive integer 'n'
        returns the n-th fibonacci term , indexing by 0
    """  
    
    # precondition
    assert isinstance(n, int) and (n >= 0), "'n' must been an int and >= 0"
    
    tmp = 0
    fib1 = 1
    ans = 1 # this will be return
    
    for i in range(n-1):
        
        tmp = ans
        ans += fib1
        fib1 = tmp
        
    return ans
<EOF>
<BOF>
from __future__ import print_function
import string
import random

letters = [letter for letter in string.ascii_letters]
digits = [digit for digit in string.digits]
symbols = [symbol for symbol in string.punctuation]
chars = letters + digits + symbols
random.shuffle(chars)

min_length = 8
max_length = 16
password = ''.join(random.choice(chars) for x in range(random.randint(min_length, max_length)))
print('Password: ' + password)
print('[ If you are thinking of using this passsword, You better save it. ]')


# ALTERNATIVE METHODS  
# ctbi= characters that must be in password
# i= how many letters or characters the password length will be 
def password_generator(ctbi, i):
  # Password generator = full boot with random_number, random_letters, and random_character FUNCTIONS
  pass  # Put your code here...


def random_number(ctbi, i):
  pass  # Put your code here...


def random_letters(ctbi, i):
  pass  # Put your code here...


def random_characters(ctbi, i):
  pass  # Put your code here...
<EOF>
<BOF>
from __future__ import print_function
import collections, pprint, time, os

start_time = time.time()
print('creating word list...')
path = os.path.split(os.path.realpath(__file__))
word_list = sorted(list(set([word.strip().lower() for word in open(path[0] + '/words')])))

def signature(word):
    return ''.join(sorted(word))

word_bysig = collections.defaultdict(list)
for word in word_list:
    word_bysig[signature(word)].append(word)

def anagram(myword):
    return word_bysig[signature(myword)]

print('finding anagrams...')
all_anagrams = {word: anagram(word)
                for word in word_list if len(anagram(word)) > 1}

print('writing anagrams to file...')
with open('anagrams.txt', 'w') as file:
    file.write('all_anagrams = ')
    file.write(pprint.pformat(all_anagrams))

total_time = round(time.time() - start_time, 2)
print(('Done [', total_time, 'seconds ]'))
<EOF>
<BOF>
# Program to find whether given string is palindrome or not
def is_palindrome(str):
    start_i = 0
    end_i = len(str) - 1
    while start_i < end_i:
        if str[start_i] == str[end_i]:
            start_i += 1
            end_i -= 1
        else:
            return False
    return True


# Recursive method
def recursive_palindrome(str):
    if len(str) <= 1:
        return True
    if str[0] == str[len(str) - 1]:
        return recursive_palindrome(str[1:-1])
    else:
        return False


def main():
    str = 'ama'
    print(recursive_palindrome(str.lower()))
    print(is_palindrome(str.lower()))


if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import print_function
__author__ = "Tobias Carryer"

from time import time

class LinearCongruentialGenerator(object):
    """
    A pseudorandom number generator.
    """
    
    def __init__( self, multiplier, increment, modulo, seed=int(time()) ):
        """
        These parameters are saved and used when nextNumber() is called.
     
        modulo is the largest number that can be generated (exclusive). The most
        efficent values are powers of 2. 2^32 is a common value.
        """
        self.multiplier = multiplier
        self.increment = increment
        self.modulo = modulo
        self.seed = seed
        
    def next_number( self ):
        """
        The smallest number that can be generated is zero.
        The largest number that can be generated is modulo-1. modulo is set in the constructor.
        """
        self.seed = (self.multiplier * self.seed + self.increment) % self.modulo
        return self.seed

if __name__ == "__main__":
    # Show the LCG in action.
    lcg = LinearCongruentialGenerator(1664525, 1013904223, 2<<31)
    while True :
        print(lcg.next_number())
<EOF>
<BOF>
'''
The nested brackets problem is a problem that determines if a sequence of
brackets are properly nested.  A sequence of brackets s is considered properly nested
if any of the following conditions are true:

	- s is empty
	- s has the form (U) or [U] or {U} where U is a properly nested string
	- s has the form VW where V and W are properly nested strings

For example, the string "()()[()]" is properly nested but "[(()]" is not.

The function called is_balanced takes as input a string S which is a sequence of brackets and
returns true if S is nested and false otherwise.

'''
from __future__ import print_function


def is_balanced(S):

    stack = []
    open_brackets = set({'(', '[', '{'})
    closed_brackets = set({')', ']', '}'})
    open_to_closed = dict({'{':'}', '[':']', '(':')'})

    for i in range(len(S)):

        if S[i] in open_brackets:
            stack.append(S[i])

        elif S[i] in closed_brackets:
            if len(stack) == 0 or (len(stack) > 0 and open_to_closed[stack.pop()] != S[i]):
                return False

    return len(stack) == 0


def main():

    S = input("Enter sequence of brackets: ")

    if is_balanced(S):
        print((S, "is balanced"))

    else:
        print((S, "is not balanced"))


if __name__ == "__main__":
    main()
<EOF>
<BOF>
import os

UPPERLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
LETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + ' \t\n'

def loadDictionary():
    path = os.path.split(os.path.realpath(__file__))
    dictionaryFile = open(path[0] + '/Dictionary.txt')
    englishWords = {}
    for word in dictionaryFile.read().split('\n'):
        englishWords[word] = None
    dictionaryFile.close()
    return englishWords

ENGLISH_WORDS = loadDictionary()

def getEnglishCount(message):
    message = message.upper()
    message = removeNonLetters(message)
    possibleWords = message.split()

    if possibleWords == []:
        return 0.0

    matches = 0
    for word in possibleWords:
        if word in ENGLISH_WORDS:
            matches += 1

    return float(matches) / len(possibleWords)

def removeNonLetters(message):
    lettersOnly = []
    for symbol in message:
        if symbol in LETTERS_AND_SPACE:
            lettersOnly.append(symbol)
    return ''.join(lettersOnly)

def isEnglish(message, wordPercentage = 20, letterPercentage = 85):
    """
    >>> isEnglish('Hello World')
    True

    >>> isEnglish('llold HorWd')
    False
    """
    wordsMatch = getEnglishCount(message) * 100 >= wordPercentage
    numLetters = len(removeNonLetters(message))
    messageLettersPercentage = (float(numLetters) / len(message)) * 100
    lettersMatch = messageLettersPercentage >= letterPercentage
    return wordsMatch and lettersMatch


import doctest
doctest.testmod()
<EOF>
<BOF>
"""
* Binary Exponentiation with Multiplication
* This is a method to find a*b in a time complexity of O(log b)
* This is one of the most commonly used methods of finding result of multiplication.
* Also useful in cases where solution to (a*b)%c is required,
* where a,b,c can be numbers over the computers calculation limits.
* Done using iteration, can also be done using recursion

* @author chinmoy159
* @version 1.0 dated 10/08/2017
"""


def b_expo(a, b):
    res = 0
    while b > 0:
        if b&1:
            res += a

        a += a
        b >>= 1

    return res


def b_expo_mod(a, b, c):
    res = 0
    while b > 0:
        if b&1:
            res = ((res%c) + (a%c)) % c

        a += a
        b >>= 1

    return res


"""
* Wondering how this method works !
* It's pretty simple.
* Let's say you need to calculate a ^ b
* RULE 1 : a * b = (a+a) * (b/2) ---- example : 4 * 4 = (4+4) * (4/2) = 8 * 2
* RULE 2 : IF b is ODD, then ---- a * b = a + (a * (b - 1)) :: where (b - 1) is even.
* Once b is even, repeat the process to get a * b
* Repeat the process till b = 1 OR b = 0, because a*1 = a AND a*0 = 0
*
* As far as the modulo is concerned,
* the fact : (a+b) % c = ((a%c) + (b%c)) % c
* Now apply RULE 1 OR 2, whichever is required.
"""
<EOF>
<BOF>
'''
-The sieve of Eratosthenes is an algorithm used to find prime numbers, less than or equal to a given value.
-Illustration: https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif
'''
from __future__ import print_function


from math import sqrt
def SOE(n):
    check = round(sqrt(n)) #Need not check for multiples past the square root of n
    
    sieve = [False if i <2 else True for i in range(n+1)] #Set every index to False except for index 0 and 1
    
    for i in range(2, check):
        if(sieve[i] == True):                  #If i is a prime  
            for j in range(i+i, n+1, i):       #Step through the list in increments of i(the multiples of the prime)   
                sieve[j] = False               #Sets every multiple of i to False 
    
    for i in range(n+1):
        if(sieve[i] == True):
            print(i, end=" ")
<EOF>
<BOF>
# Frequency Finder

# frequency taken from http://en.wikipedia.org/wiki/Letter_frequency
englishLetterFreq = {'E': 12.70, 'T': 9.06, 'A': 8.17, 'O': 7.51, 'I': 6.97,
                     'N': 6.75, 'S': 6.33, 'H': 6.09, 'R': 5.99, 'D': 4.25,
                     'L': 4.03, 'C': 2.78, 'U': 2.76, 'M': 2.41, 'W': 2.36,
                     'F': 2.23, 'G': 2.02, 'Y': 1.97, 'P': 1.93, 'B': 1.29,
                     'V': 0.98, 'K': 0.77, 'J': 0.15, 'X': 0.15, 'Q': 0.10,
                     'Z': 0.07}
ETAOIN = 'ETAOINSHRDLCUMWFGYPBVKJXQZ'
LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

def getLetterCount(message):
    letterCount = {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 0, 'H': 0,
                   'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0,
                   'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0, 'W': 0, 'X': 0,
                   'Y': 0, 'Z': 0}
    for letter in message.upper():
        if letter in LETTERS:
            letterCount[letter] += 1

    return letterCount

def getItemAtIndexZero(x):
    return x[0]

def getFrequencyOrder(message):
    letterToFreq = getLetterCount(message)
    freqToLetter = {}
    for letter in LETTERS:
        if letterToFreq[letter] not in freqToLetter:
            freqToLetter[letterToFreq[letter]] = [letter]
        else:
            freqToLetter[letterToFreq[letter]].append(letter)

    for freq in freqToLetter:
        freqToLetter[freq].sort(key = ETAOIN.find, reverse = True)
        freqToLetter[freq] = ''.join(freqToLetter[freq])

    freqPairs = list(freqToLetter.items())
    freqPairs.sort(key = getItemAtIndexZero, reverse = True)

    freqOrder = []
    for freqPair in freqPairs:
        freqOrder.append(freqPair[1])

    return ''.join(freqOrder)

def englishFreqMatchScore(message):
    '''
    >>> englishFreqMatchScore('Hello World')
    1
    '''
    freqOrder = getFrequencyOrder(message)
    matchScore = 0
    for commonLetter in ETAOIN[:6]:
        if commonLetter in freqOrder[:6]:
            matchScore += 1

    for uncommonLetter in ETAOIN[-6:]:
        if uncommonLetter in freqOrder[-6:]:
            matchScore += 1

    return matchScore

if __name__ == '__main__':
    import doctest
    doctest.testmod()
<EOF>
<BOF>
'''Conway's Game Of Life, Author Anurag Kumar(mailto:anuragkumarak95@gmail.com) 

Requirements:
  - numpy
  - random
  - time
  - matplotlib

Python:
  - 3.5

Usage:
  - $python3 game_o_life <canvas_size:int>

Game-Of-Life Rules:
 
 1.
 Any live cell with fewer than two live neighbours
 dies, as if caused by under-population.
 2.
 Any live cell with two or three live neighbours lives
 on to the next generation.
 3.
 Any live cell with more than three live neighbours
 dies, as if by over-population.
 4.
 Any dead cell with exactly three live neighbours be-
 comes a live cell, as if by reproduction.
 '''
import numpy as np
import random, sys
from matplotlib import pyplot as plt
from matplotlib.colors import ListedColormap

usage_doc='Usage of script: script_nama <size_of_canvas:int>'

choice = [0]*100 + [1]*10
random.shuffle(choice)

def create_canvas(size):
    canvas = [ [False for i in range(size)] for j in range(size)]
    return canvas

def seed(canvas):
    for i,row in enumerate(canvas):
        for j,_ in enumerate(row):
            canvas[i][j]=bool(random.getrandbits(1))

def run(canvas):
    ''' This  function runs the rules of game through all points, and changes their status accordingly.(in the same canvas)
    @Args:
    --
    canvas : canvas of population to run the rules on.

    @returns:
    --
    None
    '''
    canvas = np.array(canvas)
    next_gen_canvas = np.array(create_canvas(canvas.shape[0]))
    for r, row in enumerate(canvas):
        for c, pt in enumerate(row):
            # print(r-1,r+2,c-1,c+2)
            next_gen_canvas[r][c] = __judge_point(pt,canvas[r-1:r+2,c-1:c+2])
    
    canvas = next_gen_canvas
    del next_gen_canvas # cleaning memory as we move on.
    return canvas.tolist()   

def __judge_point(pt,neighbours):
    dead  = 0
    alive = 0
    # finding dead or alive neighbours count.
    for i in neighbours:
        for status in i:
            if status: alive+=1
            else: dead+=1

    # handling duplicate entry for focus pt.
    if pt : alive-=1
    else : dead-=1
    
    # running the rules of game here.
    state = pt
    if pt:
        if alive<2:
            state=False
        elif alive==2 or alive==3:
            state=True
        elif alive>3:
            state=False
    else:
        if alive==3:
            state=True

    return state


if __name__=='__main__':
    if len(sys.argv) != 2: raise Exception(usage_doc)
   
    canvas_size = int(sys.argv[1])
    # main working structure of this module.
    c=create_canvas(canvas_size)
    seed(c)
    fig, ax = plt.subplots()
    fig.show() 
    cmap = ListedColormap(['w','k'])
    try:
        while True:
            c = run(c)            
            ax.matshow(c,cmap=cmap)
            fig.canvas.draw()
            ax.cla() 
    except KeyboardInterrupt:
        # do nothing.
        pass
<EOF>
<BOF>
"""
This is pure python implementation of tree traversal algorithms
"""
from __future__ import print_function
import queue

try:
    raw_input          # Python 2
except NameError:
    raw_input = input  # Python 3


class TreeNode:
    def __init__(self, data):
        self.data = data
        self.right = None
        self.left = None


def build_tree():
    print("\n********Press N to stop entering at any point of time********\n")
    print("Enter the value of the root node: ", end="")
    check = raw_input().strip().lower()
    if check == 'n':
        return None 
    data = int(check)
    q = queue.Queue()
    tree_node = TreeNode(data)
    q.put(tree_node)
    while not q.empty():
        node_found = q.get()
        print("Enter the left node of %s: " % node_found.data, end="")
        check = raw_input().strip().lower()
        if check == 'n':
            return tree_node
        left_data = int(check)
        left_node = TreeNode(left_data)
        node_found.left = left_node
        q.put(left_node)
        print("Enter the right node of %s: " % node_found.data, end="")
        check = raw_input().strip().lower()
        if check == 'n':
            return tree_node
        right_data = int(check)
        right_node = TreeNode(right_data)
        node_found.right = right_node
        q.put(right_node)


def pre_order(node):
    if not isinstance(node, TreeNode) or not node:
        return
    print(node.data, end=" ")
    pre_order(node.left)
    pre_order(node.right)


def in_order(node):
    if not isinstance(node, TreeNode) or not node:
        return
    in_order(node.left)
    print(node.data, end=" ")
    in_order(node.right)


def post_order(node):
    if not isinstance(node, TreeNode) or not node:
        return
    post_order(node.left)
    post_order(node.right)
    print(node.data, end=" ")


def level_order(node):
    if not isinstance(node, TreeNode) or not node:
        return
    q = queue.Queue()
    q.put(node)
    while not q.empty():
        node_dequeued = q.get()
        print(node_dequeued.data, end=" ")
        if node_dequeued.left:
            q.put(node_dequeued.left)
        if node_dequeued.right:
            q.put(node_dequeued.right)


if __name__ == '__main__':
    print("\n********* Binary Tree Traversals ************\n")

    node = build_tree()
    print("\n********* Pre Order Traversal ************")
    pre_order(node)
    print("\n******************************************\n")

    print("\n********* In Order Traversal ************")
    in_order(node)
    print("\n******************************************\n")

    print("\n********* Post Order Traversal ************")
    post_order(node)
    print("\n******************************************\n")

    print("\n********* Level Order Traversal ************")
    level_order(node)
    print("\n******************************************\n")
<EOF>
<BOF>
import math

def primeFactors(n):
    pf = []
    while n % 2 == 0:
        pf.append(2)
        n = int(n / 2)
        
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            pf.append(i)
            n = int(n / i)
    
    if n > 2:
        pf.append(n)
    
    return pf

def numberOfDivisors(n):
    div = 1
    
    temp = 1
    while n % 2 == 0:
        temp += 1
        n = int(n / 2)
    div = div * (temp) 
    
    for i in range(3, int(math.sqrt(n))+1, 2):
        temp = 1
        while n % i == 0:
            temp += 1
            n = int(n / i)
        div = div * (temp)
    
    return div

def sumOfDivisors(n):
    s = 1
    
    temp = 1
    while n % 2 == 0:
        temp += 1
        n = int(n / 2)
    if temp > 1:
        s *= (2**temp - 1) / (2 - 1) 
    
    for i in range(3, int(math.sqrt(n))+1, 2):
        temp = 1
        while n % i == 0:
            temp += 1
            n = int(n / i)
        if temp > 1:
            s *= (i**temp - 1) / (i - 1)
    
    return s

def eulerPhi(n):
    l = primeFactors(n)
    l = set(l)
    s = n
    for x in l:
        s *= (x - 1)/x 
    return s   

def main():
    print(primeFactors(100))
    print(numberOfDivisors(100))
    print(sumOfDivisors(100))
    print(eulerPhi(100))
    
if __name__ == '__main__':
    main()
    
    
<EOF>
<BOF>
import math
def primeCheck(number):
    if number % 2 == 0 and number > 2: 
        return False
    return all(number % i for i in range(3, int(math.sqrt(number)) + 1, 2))

def main():
    print(primeCheck(37))
    print(primeCheck(100))
    print(primeCheck(77))

if __name__ == '__main__':
	main()
<EOF>
<BOF>
# Greater Common Divisor - https://en.wikipedia.org/wiki/Greatest_common_divisor
def gcd(a, b):
    return b if a == 0 else gcd(b % a, a)

def main():
    try:
        nums = input("Enter two Integers separated by comma (,): ").split(',')
        num1 = int(nums[0]); num2 = int(nums[1])
    except (IndexError, UnboundLocalError, ValueError):
        print("Wrong Input")
    print(f"gcd({num1}, {num2}) = {gcd(num1, num2)}")

if __name__ == '__main__':
    main()

<EOF>
<BOF>
def modularExponential(base, power, mod):
	if power < 0:
		return -1
	base %= mod
	result = 1

	while power > 0:
		if power & 1:
			result = (result * base) % mod
		power = power >> 1
		base = (base * base) % mod
	return result


def main():
	print(modularExponential(3, 200, 13))


if __name__ == '__main__':
	main()
<EOF>
<BOF>
# Fibonacci Sequence Using Recursion

def recur_fibo(n):
    if n <= 1:
        return n
    else:
        (recur_fibo(n-1) + recur_fibo(n-2))

def isPositiveInteger(limit):
    return limit >= 0

def main():
    limit = int(input("How many terms to include in fibonacci series: "))
    if isPositiveInteger(limit):
        print("The first {limit} terms of the fibonacci series are as follows:")
        print([recur_fibo(n) for n in range(limit)])
    else:
        print("Please enter a positive integer: ")

if __name__ == '__main__':
    main()
<EOF>
<BOF>

'''
Numerical integration or quadrature for a smooth function f with known values at x_i

This method is the classical approch of suming 'Equally Spaced Abscissas' 

method 2: 
"Simpson Rule"

'''
from __future__ import print_function


def method_2(boundary, steps):
# "Simpson Rule"
# int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)
	h = (boundary[1] - boundary[0]) / steps
	a = boundary[0]
	b = boundary[1]
	x_i = makePoints(a,b,h)
	y = 0.0
	y += (h/3.0)*f(a)
	cnt = 2
	for i in x_i:
		y += (h/3)*(4-2*(cnt%2))*f(i)	
		cnt += 1
	y += (h/3.0)*f(b)
	return y

def makePoints(a,b,h):
	x = a + h
	while x < (b-h):
		yield x
		x = x + h

def f(x): #enter your function here
	y = (x-0)*(x-0)
	return y

def main():
	a = 0.0 #Lower bound of integration
	b = 1.0	#Upper bound of integration
	steps = 10.0		#define number of steps or resolution
	boundary = [a, b]	#define boundary of integration
	y = method_2(boundary, steps)
	print('y = {0}'.format(y))

if __name__ == '__main__':
        main()
<EOF>
<BOF>
import math

def sieve(n):
    in_prime = []
    start = 2
    end   = int(math.sqrt(n)) # Size of every segment
    temp = [True] * (end + 1)
    prime = []
    
    while(start <= end):
        if temp[start] == True:
            in_prime.append(start)
            for i in range(start*start, end+1, start):
                if temp[i] == True:
                    temp[i] = False
        start += 1
    prime += in_prime
    
    low = end + 1
    high = low + end - 1
    if high > n:
        high = n
    
    while(low <= n):
        temp = [True] * (high-low+1)
        for each in in_prime:
            
            t = math.floor(low / each) * each
            if t < low:
                t += each
            
            for j in range(t, high+1, each):
                temp[j - low] = False
                
        for j in range(len(temp)):
            if temp[j] == True:
                prime.append(j+low)
        
        low = high + 1
        high = low + end - 1
        if high > n:
            high = n
            
    return prime

print(sieve(10**6))
<EOF>
<BOF>
'''
Numerical integration or quadrature for a smooth function f with known values at x_i

This method is the classical approch of suming 'Equally Spaced Abscissas' 

method 1: 
"extended trapezoidal rule"

'''
from __future__ import print_function

def method_1(boundary, steps):
# "extended trapezoidal rule"
# int(f) = dx/2 * (f1 + 2f2 + ... + fn)
	h = (boundary[1] - boundary[0]) / steps
	a = boundary[0]
	b = boundary[1]
	x_i = makePoints(a,b,h)
	y = 0.0	
	y += (h/2.0)*f(a)
	for i in x_i:
		#print(i)	
		y += h*f(i)
	y += (h/2.0)*f(b)	
	return y	

def makePoints(a,b,h):
	x = a + h	
	while x < (b-h):
		yield x
		x = x + h
		
def f(x): #enter your function here
	y = (x-0)*(x-0)
	return y

def main():
	a = 0.0 #Lower bound of integration
	b = 1.0	#Upper bound of integration
	steps = 10.0		#define number of steps or resolution	
	boundary = [a, b]	#define boundary of integration
	y = method_1(boundary, steps)
	print('y = {0}'.format(y))

if __name__ == '__main__':
	main()
<EOF>
<BOF>
import math
n = int(input("Enter n: "))

def sieve(n):
    l = [True] * (n+1)
    prime = []
    start = 2
    end   = int(math.sqrt(n))
    while(start <= end):
        if l[start] == True:
            prime.append(start)
            for i in range(start*start, n+1, start):
                if l[i] == True:
                    l[i] = False
        start += 1
    
    for j in range(end+1,n+1):
        if l[j] == True:
            prime.append(j)
    
    return prime

print(sieve(n))
        
<EOF>
