<BOF>
#!/usr/bin/env python

import os
import subprocess
import os.path as p
import glob
import sys

DIR_OF_THIS_SCRIPT = p.dirname( p.abspath( __file__ ) )
DIR_OF_THIRD_PARTY = p.join( DIR_OF_THIS_SCRIPT, 'third_party' )
DIR_OF_YCMD_THIRD_PARTY = p.join( DIR_OF_THIRD_PARTY, 'ycmd', 'third_party' )

python_path = []
for folder in os.listdir( DIR_OF_THIRD_PARTY ):
  python_path.append( p.abspath( p.join( DIR_OF_THIRD_PARTY, folder ) ) )
for folder in os.listdir( DIR_OF_YCMD_THIRD_PARTY ):
  # We skip python-future because it needs to be inserted in sys.path AFTER
  # the standard library imports but we can't do that with PYTHONPATH because
  # the std lib paths are always appended to PYTHONPATH. We do it correctly in
  # prod in ycmd/utils.py because we have access to the right sys.path.
  # So for dev, we rely on python-future being installed correctly with
  #   pip install -r test_requirements.txt
  #
  # Pip knows how to install this correctly so that it doesn't matter where in
  # sys.path the path is.
  if folder == 'python-future':
    continue
  python_path.append( p.abspath( p.join( DIR_OF_YCMD_THIRD_PARTY, folder ) ) )
if os.environ.get( 'PYTHONPATH' ):
  python_path.append( os.environ[ 'PYTHONPATH' ] )
os.environ[ 'PYTHONPATH' ] = os.pathsep.join( python_path )

sys.path.insert( 1, p.abspath( p.join( DIR_OF_YCMD_THIRD_PARTY,
                                       'argparse' ) ) )

import argparse


def RunFlake8():
  print( 'Running flake8' )
  args = [ sys.executable,
           '-m',
           'flake8',
           p.join( DIR_OF_THIS_SCRIPT, 'python' ) ]
  root_dir_scripts = glob.glob( p.join( DIR_OF_THIS_SCRIPT, '*.py' ) )
  args.extend( root_dir_scripts )
  subprocess.check_call( args )


def ParseArguments():
  parser = argparse.ArgumentParser()
  parser.add_argument( '--skip-build', action = 'store_true',
                       help = 'Do not build ycmd before testing' )
  parser.add_argument( '--coverage', action = 'store_true',
                       help = 'Enable coverage report' )
  parser.add_argument( '--no-flake8', action = 'store_true',
                       help = 'Do not run flake8' )

  parsed_args, nosetests_args = parser.parse_known_args()

  if 'COVERAGE' in os.environ:
    parsed_args.coverage = ( os.environ[ 'COVERAGE' ] == 'true' )

  return parsed_args, nosetests_args


def BuildYcmdLibs( args ):
  if not args.skip_build:
    subprocess.check_call( [
      sys.executable,
      p.join( DIR_OF_THIS_SCRIPT, 'third_party', 'ycmd', 'build.py' )
    ] )


def NoseTests( parsed_args, extra_nosetests_args ):
  # Always passing --with-id to nosetests enables non-surprising usage of
  # its --failed flag.
  nosetests_args = [ '-v', '--with-id' ]

  if parsed_args.coverage:
    nosetests_args += [ '--with-coverage',
                        '--cover-erase',
                        '--cover-package=ycm',
                        '--cover-html' ]

  if extra_nosetests_args:
    nosetests_args.extend( extra_nosetests_args )
  else:
    nosetests_args.append( p.join( DIR_OF_THIS_SCRIPT, 'python' ) )

  subprocess.check_call( [ sys.executable, '-m', 'nose' ] + nosetests_args )


def Main():
  ( parsed_args, nosetests_args ) = ParseArguments()
  if not parsed_args.no_flake8:
    RunFlake8()
  BuildYcmdLibs( parsed_args )
  NoseTests( parsed_args, nosetests_args )


if __name__ == "__main__":
  Main()
<EOF>
<BOF>
#!/usr/bin/env python

from __future__ import print_function
from __future__ import division
from __future__ import unicode_literals
from __future__ import absolute_import

import os
import subprocess
import sys
import os.path as p
import glob

PY_MAJOR, PY_MINOR, PY_PATCH = sys.version_info[ 0 : 3 ]
if not ( ( PY_MAJOR == 2 and PY_MINOR == 7 and PY_PATCH >= 1 ) or
         ( PY_MAJOR == 3 and PY_MINOR >= 4 ) or
         PY_MAJOR > 3 ):
  sys.exit( 'YouCompleteMe requires Python >= 2.7.1 or >= 3.4; '
            'your version of Python is ' + sys.version )

DIR_OF_THIS_SCRIPT = p.dirname( p.abspath( __file__ ) )
DIR_OF_OLD_LIBS = p.join( DIR_OF_THIS_SCRIPT, 'python' )


def CheckCall( args, **kwargs ):
  try:
    subprocess.check_call( args, **kwargs )
  except subprocess.CalledProcessError as error:
    sys.exit( error.returncode )


def Main():
  build_file = p.join( DIR_OF_THIS_SCRIPT, 'third_party', 'ycmd', 'build.py' )

  if not p.isfile( build_file ):
    sys.exit(
      'File {0} does not exist; you probably forgot to run:\n'
      '\tgit submodule update --init --recursive\n'.format( build_file ) )

  CheckCall( [ sys.executable, build_file ] + sys.argv[ 1: ] )

  # Remove old YCM libs if present so that YCM can start.
  old_libs = (
    glob.glob( p.join( DIR_OF_OLD_LIBS, '*ycm_core.*' ) ) +
    glob.glob( p.join( DIR_OF_OLD_LIBS, '*ycm_client_support.*' ) ) +
    glob.glob( p.join( DIR_OF_OLD_LIBS, '*clang*.*' ) ) )
  for lib in old_libs:
    os.remove( lib )


if __name__ == "__main__":
  Main()
<EOF>
<BOF>
# Copyright (C) 2011-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from future.utils import iterkeys
import vim
import os
import json
import re
from collections import defaultdict, namedtuple
from ycmd.utils import ( ByteOffsetToCodepointOffset, GetCurrentDirectory,
                         JoinLinesAsUnicode, ToBytes, ToUnicode )

BUFFER_COMMAND_MAP = { 'same-buffer'      : 'edit',
                       'split'            : 'split',
                       # These commands are obsolete. :vertical or :tab should
                       # be used with the 'split' command instead.
                       'horizontal-split' : 'split',
                       'vertical-split'   : 'vsplit',
                       'new-tab'          : 'tabedit' }

FIXIT_OPENING_BUFFERS_MESSAGE_FORMAT = (
    'The requested operation will apply changes to {0} files which are not '
    'currently open. This will therefore open {0} new files in the hidden '
    'buffers. The quickfix list can then be used to review the changes. No '
    'files will be written to disk. Do you wish to continue?' )

NO_SELECTION_MADE_MSG = "No valid selection was made; aborting."

# This is the starting value assigned to the sign's id of each buffer. This
# value is then incremented for each new sign. This should prevent conflicts
# with other plugins using signs.
SIGN_BUFFER_ID_INITIAL_VALUE = 100000000
# This holds the next sign's id to assign for each buffer.
SIGN_ID_FOR_BUFFER = defaultdict( lambda: SIGN_BUFFER_ID_INITIAL_VALUE )

SIGN_PLACE_REGEX = re.compile(
  r"^.*=(?P<line>\d+).*=(?P<id>\d+).*=(?P<name>Ycm\w+)$" )

NO_COMPLETIONS = {
  'line': -1,
  'column': -1,
  'completion_start_column': -1,
  'completions': []
}


def CurrentLineAndColumn():
  """Returns the 0-based current line and 0-based current column."""
  # See the comment in CurrentColumn about the calculation for the line and
  # column number
  line, column = vim.current.window.cursor
  line -= 1
  return line, column


def SetCurrentLineAndColumn( line, column ):
  """Sets the cursor position to the 0-based line and 0-based column."""
  # Line from vim.current.window.cursor is 1-based.
  vim.current.window.cursor = ( line + 1, column )


def CurrentColumn():
  """Returns the 0-based current column. Do NOT access the CurrentColumn in
  vim.current.line. It doesn't exist yet when the cursor is at the end of the
  line. Only the chars before the current column exist in vim.current.line."""

  # vim's columns are 1-based while vim.current.line columns are 0-based
  # ... but vim.current.window.cursor (which returns a (line, column) tuple)
  # columns are 0-based, while the line from that same tuple is 1-based.
  # vim.buffers buffer objects OTOH have 0-based lines and columns.
  # Pigs have wings and I'm a loopy purple duck. Everything makes sense now.
  return vim.current.window.cursor[ 1 ]


def CurrentLineContents():
  return ToUnicode( vim.current.line )


def CurrentLineContentsAndCodepointColumn():
  """Returns the line contents as a unicode string and the 0-based current
  column as a codepoint offset. If the current column is outside the line,
  returns the column position at the end of the line."""
  line = CurrentLineContents()
  byte_column = CurrentColumn()
  # ByteOffsetToCodepointOffset expects 1-based offset.
  column = ByteOffsetToCodepointOffset( line, byte_column + 1 ) - 1
  return line, column


def TextAfterCursor():
  """Returns the text after CurrentColumn."""
  return ToUnicode( vim.current.line[ CurrentColumn(): ] )


def TextBeforeCursor():
  """Returns the text before CurrentColumn."""
  return ToUnicode( vim.current.line[ :CurrentColumn() ] )


def BufferModified( buffer_object ):
  return buffer_object.options[ 'mod' ]


def GetBufferData( buffer_object ):
  return {
    # Add a newline to match what gets saved to disk. See #1455 for details.
    'contents': JoinLinesAsUnicode( buffer_object ) + '\n',
    'filetypes': FiletypesForBuffer( buffer_object )
  }


def GetUnsavedAndSpecifiedBufferData( included_buffer, included_filepath ):
  """Build part of the request containing the contents and filetypes of all
  dirty buffers as well as the buffer |included_buffer| with its filepath
  |included_filepath|."""
  buffers_data = { included_filepath: GetBufferData( included_buffer ) }

  for buffer_object in vim.buffers:
    if not BufferModified( buffer_object ):
      continue

    filepath = GetBufferFilepath( buffer_object )
    if filepath in buffers_data:
      continue

    buffers_data[ filepath ] = GetBufferData( buffer_object )

  return buffers_data


def GetBufferNumberForFilename( filename, create_buffer_if_needed = False ):
  return GetIntValue( u"bufnr('{0}', {1})".format(
      EscapeForVim( os.path.realpath( filename ) ),
      int( create_buffer_if_needed ) ) )


def GetCurrentBufferFilepath():
  return GetBufferFilepath( vim.current.buffer )


def BufferIsVisible( buffer_number ):
  if buffer_number < 0:
    return False
  window_number = GetIntValue( "bufwinnr({0})".format( buffer_number ) )
  return window_number != -1


def GetBufferFilepath( buffer_object ):
  if buffer_object.name:
    return os.path.normpath( ToUnicode( buffer_object.name ) )
  # Buffers that have just been created by a command like :enew don't have any
  # buffer name so we use the buffer number for that.
  return os.path.join( GetCurrentDirectory(), str( buffer_object.number ) )


def GetCurrentBufferNumber():
  return vim.current.buffer.number


def GetBufferChangedTick( bufnr ):
  return GetIntValue( 'getbufvar({0}, "changedtick")'.format( bufnr ) )


def CaptureVimCommand( command ):
  vim.command( 'redir => b:ycm_command' )
  vim.command( 'silent! {}'.format( command ) )
  vim.command( 'redir END' )
  output = ToUnicode( vim.eval( 'b:ycm_command' ) )
  vim.command( 'unlet b:ycm_command' )
  return output


class DiagnosticSign( namedtuple( 'DiagnosticSign',
                                  [ 'id', 'line', 'name', 'buffer_number' ] ) ):
  # We want two signs that have different ids but the same location to compare
  # equal. ID doesn't matter.
  def __eq__( self, other ):
    return ( self.line == other.line and
             self.name == other.name and
             self.buffer_number == other.buffer_number )


def GetSignsInBuffer( buffer_number ):
  sign_output = CaptureVimCommand(
    'sign place buffer={}'.format( buffer_number ) )
  signs = []
  for line in sign_output.split( '\n' ):
    match = SIGN_PLACE_REGEX.search( line )
    if match:
      signs.append( DiagnosticSign( int( match.group( 'id' ) ),
                                    int( match.group( 'line' ) ),
                                    match.group( 'name' ),
                                    buffer_number ) )
  return signs


def CreateSign( line, name, buffer_number ):
  sign_id = SIGN_ID_FOR_BUFFER[ buffer_number ]
  SIGN_ID_FOR_BUFFER[ buffer_number ] += 1
  return DiagnosticSign( sign_id, line, name, buffer_number )


def UnplaceSign( sign ):
  vim.command( 'sign unplace {0} buffer={1}'.format( sign.id,
                                                     sign.buffer_number ) )


def PlaceSign( sign ):
  vim.command( 'sign place {0} name={1} line={2} buffer={3}'.format(
    sign.id, sign.name, sign.line, sign.buffer_number ) )


class DiagnosticMatch( namedtuple( 'DiagnosticMatch',
                                   [ 'id', 'group', 'pattern' ] ) ):
  def __eq__( self, other ):
    return ( self.group == other.group and
             self.pattern == other.pattern )


def GetDiagnosticMatchesInCurrentWindow():
  vim_matches = vim.eval( 'getmatches()' )
  return [ DiagnosticMatch( match[ 'id' ],
                            match[ 'group' ],
                            match[ 'pattern' ] )
           for match in vim_matches if match[ 'group' ].startswith( 'Ycm' ) ]


def AddDiagnosticMatch( match ):
  return GetIntValue( "matchadd('{}', '{}')".format( match.group,
                                                     match.pattern ) )


def RemoveDiagnosticMatch( match ):
  return GetIntValue( "matchdelete({})".format( match.id ) )


def GetDiagnosticMatchPattern( line_num,
                               column_num,
                               line_end_num = None,
                               column_end_num = None ):
  line_num, column_num = LineAndColumnNumbersClamped( line_num, column_num )

  if not line_end_num or not column_end_num:
    return '\\%{}l\\%{}c'.format( line_num, column_num )

  # -1 and then +1 to account for column end not included in the range.
  line_end_num, column_end_num = LineAndColumnNumbersClamped(
      line_end_num, column_end_num - 1 )
  column_end_num += 1
  return '\\%{}l\\%{}c\\_.\\{{-}}\\%{}l\\%{}c'.format( line_num,
                                                       column_num,
                                                       line_end_num,
                                                       column_end_num )


# Clamps the line and column numbers so that they are not past the contents of
# the buffer. Numbers are 1-based byte offsets.
def LineAndColumnNumbersClamped( line_num, column_num ):
  new_line_num = line_num
  new_column_num = column_num

  max_line = len( vim.current.buffer )
  if line_num and line_num > max_line:
    new_line_num = max_line

  # Vim buffers are a list of byte objects on Python 2 but Unicode objects on
  # Python 3.
  max_column = len( ToBytes( vim.current.buffer[ new_line_num - 1 ] ) )
  if column_num and column_num > max_column:
    new_column_num = max_column

  return new_line_num, new_column_num


def SetLocationList( diagnostics ):
  """Set the location list for the current window to the supplied diagnostics"""
  SetLocationListForWindow( 0, diagnostics )


def GetWindowsForBufferNumber( buffer_number ):
  """Return the list of windows containing the buffer with number
  |buffer_number| for the current tab page."""
  return [ window for window in vim.windows
           if window.buffer.number == buffer_number ]


def SetLocationListsForBuffer( buffer_number, diagnostics ):
  """Populate location lists for all windows containing the buffer with number
  |buffer_number|. See SetLocationListForWindow for format of diagnostics."""
  for window in GetWindowsForBufferNumber( buffer_number ):
    SetLocationListForWindow( window.number, diagnostics )


def SetLocationListForWindow( window_number, diagnostics ):
  """Populate the location list with diagnostics. Diagnostics should be in
  qflist format; see ":h setqflist" for details."""
  vim.eval( 'setloclist( {0}, {1} )'.format( window_number,
                                             json.dumps( diagnostics ) ) )


def OpenLocationList( focus = False, autoclose = False ):
  """Open the location list to the bottom of the current window with its
  height automatically set to fit all entries. This behavior can be overridden
  by using the YcmLocationOpened autocommand. When focus is set to True, the
  location list window becomes the active window. When autoclose is set to True,
  the location list window is automatically closed after an entry is
  selected."""
  vim.command( 'lopen' )

  SetFittingHeightForCurrentWindow()

  if autoclose:
    # This autocommand is automatically removed when the location list window is
    # closed.
    vim.command( 'au WinLeave <buffer> q' )

  if VariableExists( '#User#YcmLocationOpened' ):
    vim.command( 'doautocmd User YcmLocationOpened' )

  if not focus:
    JumpToPreviousWindow()


def SetQuickFixList( quickfix_list ):
  """Populate the quickfix list and open it. List should be in qflist format:
  see ":h setqflist" for details."""
  vim.eval( 'setqflist( {0} )'.format( json.dumps( quickfix_list ) ) )


def OpenQuickFixList( focus = False, autoclose = False ):
  """Open the quickfix list to full width at the bottom of the screen with its
  height automatically set to fit all entries. This behavior can be overridden
  by using the YcmQuickFixOpened autocommand.
  See the OpenLocationList function for the focus and autoclose options."""
  vim.command( 'botright copen' )

  SetFittingHeightForCurrentWindow()

  if autoclose:
    # This autocommand is automatically removed when the quickfix window is
    # closed.
    vim.command( 'au WinLeave <buffer> q' )

  if VariableExists( '#User#YcmQuickFixOpened' ):
    vim.command( 'doautocmd User YcmQuickFixOpened' )

  if not focus:
    JumpToPreviousWindow()


def ComputeFittingHeightForCurrentWindow():
  current_window = vim.current.window
  if not current_window.options[ 'wrap' ]:
    return len( vim.current.buffer )

  window_width = current_window.width
  fitting_height = 0
  for line in vim.current.buffer:
    fitting_height += len( line ) // window_width + 1
  return fitting_height


def SetFittingHeightForCurrentWindow():
  vim.command( '{0}wincmd _'.format( ComputeFittingHeightForCurrentWindow() ) )


def ConvertDiagnosticsToQfList( diagnostics ):
  def ConvertDiagnosticToQfFormat( diagnostic ):
    # See :h getqflist for a description of the dictionary fields.
    # Note that, as usual, Vim is completely inconsistent about whether
    # line/column numbers are 1 or 0 based in its various APIs. Here, it wants
    # them to be 1-based. The documentation states quite clearly that it
    # expects a byte offset, by which it means "1-based column number" as
    # described in :h getqflist ("the first column is 1").
    location = diagnostic[ 'location' ]
    line_num = location[ 'line_num' ]

    # libclang can give us diagnostics that point "outside" the file; Vim borks
    # on these.
    if line_num < 1:
      line_num = 1

    text = diagnostic[ 'text' ]
    if diagnostic.get( 'fixit_available', False ):
      text += ' (FixIt available)'

    return {
      'bufnr' : GetBufferNumberForFilename( location[ 'filepath' ],
                                            create_buffer_if_needed = True ),
      'lnum'  : line_num,
      'col'   : location[ 'column_num' ],
      'text'  : text,
      'type'  : diagnostic[ 'kind' ][ 0 ],
      'valid' : 1
    }

  return [ ConvertDiagnosticToQfFormat( x ) for x in diagnostics ]


def GetVimGlobalsKeys():
  return vim.eval( 'keys( g: )' )


def VimExpressionToPythonType( vim_expression ):
  """Returns a Python type from the return value of the supplied Vim expression.
  If the expression returns a list, dict or other non-string type, then it is
  returned unmodified. If the string return can be converted to an
  integer, returns an integer, otherwise returns the result converted to a
  Unicode string."""

  result = vim.eval( vim_expression )
  if not ( isinstance( result, str ) or isinstance( result, bytes ) ):
    return result

  try:
    return int( result )
  except ValueError:
    return ToUnicode( result )


def HiddenEnabled( buffer_object ):
  if buffer_object.options[ 'bh' ] == "hide":
    return True
  return GetBoolValue( '&hidden' )


def BufferIsUsable( buffer_object ):
  return not BufferModified( buffer_object ) or HiddenEnabled( buffer_object )


def EscapeFilepathForVimCommand( filepath ):
  to_eval = "fnameescape('{0}')".format( EscapeForVim( filepath ) )
  return GetVariableValue( to_eval )


# Both |line| and |column| need to be 1-based
def TryJumpLocationInTab( tab, filename, line, column ):
  for win in tab.windows:
    if GetBufferFilepath( win.buffer ) == filename:
      vim.current.tabpage = tab
      vim.current.window = win
      vim.current.window.cursor = ( line, column - 1 )

      # Center the screen on the jumped-to location
      vim.command( 'normal! zz' )
      return True
  # 'filename' is not opened in this tab page
  return False


# Both |line| and |column| need to be 1-based
def TryJumpLocationInTabs( filename, line, column ):
  for tab in vim.tabpages:
    if TryJumpLocationInTab( tab, filename, line, column ):
      return True
  # 'filename' is not opened in any tab pages
  return False


# Maps User command to vim command
def GetVimCommand( user_command, default = 'edit' ):
  vim_command = BUFFER_COMMAND_MAP.get( user_command, default )
  if vim_command == 'edit' and not BufferIsUsable( vim.current.buffer ):
    vim_command = 'split'
  return vim_command


def JumpToFile( filename, command, modifiers ):
  vim_command = GetVimCommand( command )
  try:
    escaped_filename = EscapeFilepathForVimCommand( filename )
    vim.command( 'keepjumps {} {} {}'.format( modifiers,
                                              vim_command,
                                              escaped_filename ) )
  # When the file we are trying to jump to has a swap file
  # Vim opens swap-exists-choices dialog and throws vim.error with E325 error,
  # or KeyboardInterrupt after user selects one of the options.
  except vim.error as e:
    if 'E325' not in str( e ):
      raise
    # Do nothing if the target file is still not opened (user chose (Q)uit).
    if filename != GetCurrentBufferFilepath():
      return False
  # Thrown when user chooses (A)bort in .swp message box.
  except KeyboardInterrupt:
    return False
  return True


# Both |line| and |column| need to be 1-based
def JumpToLocation( filename, line, column, modifiers, command ):
  # Add an entry to the jumplist
  vim.command( "normal! m'" )

  if filename != GetCurrentBufferFilepath():
    # We prefix the command with 'keepjumps' so that opening the file is not
    # recorded in the jumplist. So when we open the file and move the cursor to
    # a location in it, the user can use CTRL-O to jump back to the original
    # location, not to the start of the newly opened file.
    # Sadly this fails on random occasions and the undesired jump remains in the
    # jumplist.
    if command == 'split-or-existing-window':
      if 'tab' in modifiers:
        if TryJumpLocationInTabs( filename, line, column ):
          return
      elif TryJumpLocationInTab( vim.current.tabpage, filename, line, column ):
        return
      command = 'split'

    # This command is kept for backward compatibility. :tab should be used with
    # the 'split-or-existing-window' command instead.
    if command == 'new-or-existing-tab':
      if TryJumpLocationInTabs( filename, line, column ):
        return
      command = 'new-tab'

    if not JumpToFile( filename, command, modifiers ):
      return

  vim.current.window.cursor = ( line, column - 1 )

  # Center the screen on the jumped-to location
  vim.command( 'normal! zz' )


def NumLinesInBuffer( buffer_object ):
  # This is actually less than obvious, that's why it's wrapped in a function
  return len( buffer_object )


# Calling this function from the non-GUI thread will sometimes crash Vim. At
# the time of writing, YCM only uses the GUI thread inside Vim (this used to
# not be the case).
def PostVimMessage( message, warning = True, truncate = False ):
  """Display a message on the Vim status line. By default, the message is
  highlighted and logged to Vim command-line history (see :h history).
  Unset the |warning| parameter to disable this behavior. Set the |truncate|
  parameter to avoid hit-enter prompts (see :h hit-enter) when the message is
  longer than the window width."""
  echo_command = 'echom' if warning else 'echo'

  # Displaying a new message while previous ones are still on the status line
  # might lead to a hit-enter prompt or the message appearing without a
  # newline so we do a redraw first.
  vim.command( 'redraw' )

  if warning:
    vim.command( 'echohl WarningMsg' )

  message = ToUnicode( message )

  if truncate:
    vim_width = GetIntValue( '&columns' )

    message = message.replace( '\n', ' ' )
    if len( message ) >= vim_width:
      message = message[ : vim_width - 4 ] + '...'

    old_ruler = GetIntValue( '&ruler' )
    old_showcmd = GetIntValue( '&showcmd' )
    vim.command( 'set noruler noshowcmd' )

    vim.command( "{0} '{1}'".format( echo_command,
                                     EscapeForVim( message ) ) )

    SetVariableValue( '&ruler', old_ruler )
    SetVariableValue( '&showcmd', old_showcmd )
  else:
    for line in message.split( '\n' ):
      vim.command( "{0} '{1}'".format( echo_command,
                                       EscapeForVim( line ) ) )

  if warning:
    vim.command( 'echohl None' )


def PresentDialog( message, choices, default_choice_index = 0 ):
  """Presents the user with a dialog where a choice can be made.
  This will be a dialog for gvim users or a question in the message buffer
  for vim users or if `set guioptions+=c` was used.

  choices is list of alternatives.
  default_choice_index is the 0-based index of the default element
  that will get choosen if the user hits <CR>. Use -1 for no default.

  PresentDialog will return a 0-based index into the list
  or -1 if the dialog was dismissed by using <Esc>, Ctrl-C, etc.

  If you are presenting a list of options for the user to choose from, such as
  a list of imports, or lines to insert (etc.), SelectFromList is a better
  option.

  See also:
    :help confirm() in vim (Note that vim uses 1-based indexes)

  Example call:
    PresentDialog("Is this a nice example?", ["Yes", "No", "May&be"])
      Is this a nice example?
      [Y]es, (N)o, May(b)e:"""
  to_eval = "confirm('{0}', '{1}', {2})".format(
    EscapeForVim( ToUnicode( message ) ),
    EscapeForVim( ToUnicode( "\n" .join( choices ) ) ),
    default_choice_index + 1 )
  try:
    return GetIntValue( to_eval ) - 1
  except KeyboardInterrupt:
    return -1


def Confirm( message ):
  """Display |message| with Ok/Cancel operations. Returns True if the user
  selects Ok"""
  return bool( PresentDialog( message, [ "Ok", "Cancel" ] ) == 0 )


def SelectFromList( prompt, items ):
  """Ask the user to select an item from the list |items|.

  Presents the user with |prompt| followed by a numbered list of |items|,
  from which they select one. The user is asked to enter the number of an
  item or click it.

  |items| should not contain leading ordinals: they are added automatically.

  Returns the 0-based index in the list |items| that the user selected, or an
  exception if no valid item was selected.

  See also :help inputlist()."""

  vim_items = [ prompt ]
  vim_items.extend( [ "{0}: {1}".format( i + 1, item )
                      for i, item in enumerate( items ) ] )

  # The vim documentation warns not to present lists larger than the number of
  # lines of display. This is sound advice, but there really isn't any sensible
  # thing we can do in that scenario. Testing shows that Vim just pages the
  # message; that behaviour is as good as any, so we don't manipulate the list,
  # or attempt to page it.

  # For an explanation of the purpose of inputsave() / inputrestore(),
  # see :help input(). Briefly, it makes inputlist() work as part of a mapping.
  vim.eval( 'inputsave()' )
  try:
    # Vim returns the number the user entered, or the line number the user
    # clicked. This may be wildly out of range for our list. It might even be
    # negative.
    #
    # The first item is index 0, and this maps to our "prompt", so we subtract 1
    # from the result and return that, assuming it is within the range of the
    # supplied list. If not, we return negative.
    #
    # See :help input() for explanation of the use of inputsave() and inpput
    # restore(). It is done in try/finally in case vim.eval ever throws an
    # exception (such as KeyboardInterrupt)
    selected = GetIntValue( "inputlist( " + json.dumps( vim_items ) + " )" ) - 1
  except KeyboardInterrupt:
    selected = -1
  finally:
    vim.eval( 'inputrestore()' )

  if selected < 0 or selected >= len( items ):
    # User selected something outside of the range
    raise RuntimeError( NO_SELECTION_MADE_MSG )

  return selected


def EscapeForVim( text ):
  return ToUnicode( text.replace( "'", "''" ) )


def CurrentFiletypes():
  return ToUnicode( vim.eval( "&filetype" ) ).split( '.' )


def CurrentFiletypesEnabled( disabled_filetypes ):
  """Return False if one of the current filetypes is disabled, True otherwise.
  |disabled_filetypes| must be a dictionary where keys are the disabled
  filetypes and values are unimportant. The special key '*' matches all
  filetypes."""
  return ( '*' not in disabled_filetypes and
           not any( x in disabled_filetypes for x in CurrentFiletypes() ) )


def GetBufferFiletypes( bufnr ):
  command = 'getbufvar({0}, "&ft")'.format( bufnr )
  return ToUnicode( vim.eval( command ) ).split( '.' )


def FiletypesForBuffer( buffer_object ):
  # NOTE: Getting &ft for other buffers only works when the buffer has been
  # visited by the user at least once, which is true for modified buffers

  # We don't use
  #
  #   buffer_object.options[ 'ft' ]
  #
  # to get the filetypes because this causes annoying flickering when the buffer
  # is hidden.
  return GetBufferFiletypes( buffer_object.number )


def VariableExists( variable ):
  return GetBoolValue( "exists( '{0}' )".format( EscapeForVim( variable ) ) )


def SetVariableValue( variable, value ):
  vim.command( "let {0} = {1}".format( variable, json.dumps( value ) ) )


def GetVariableValue( variable ):
  return vim.eval( variable )


def GetBoolValue( variable ):
  return bool( int( vim.eval( variable ) ) )


def GetIntValue( variable ):
  return int( vim.eval( variable ) )


def _SortChunksByFile( chunks ):
  """Sort the members of the list |chunks| (which must be a list of dictionaries
  conforming to ycmd.responses.FixItChunk) by their filepath. Returns a new
  list in arbitrary order."""

  chunks_by_file = defaultdict( list )

  for chunk in chunks:
    filepath = chunk[ 'range' ][ 'start' ][ 'filepath' ]
    chunks_by_file[ filepath ].append( chunk )

  return chunks_by_file


def _GetNumNonVisibleFiles( file_list ):
  """Returns the number of file in the iterable list of files |file_list| which
  are not curerntly open in visible windows"""
  return len(
      [ f for f in file_list
        if not BufferIsVisible( GetBufferNumberForFilename( f ) ) ] )


def _OpenFileInSplitIfNeeded( filepath ):
  """Ensure that the supplied filepath is open in a visible window, opening a
  new split if required. Returns the buffer number of the file and an indication
  of whether or not a new split was opened.

  If the supplied filename is already open in a visible window, return just
  return its buffer number. If the supplied file is not visible in a window
  in the current tab, opens it in a new vertical split.

  Returns a tuple of ( buffer_num, split_was_opened ) indicating the buffer
  number and whether or not this method created a new split. If the user opts
  not to open a file, or if opening fails, this method raises RuntimeError,
  otherwise, guarantees to return a visible buffer number in buffer_num."""

  buffer_num = GetBufferNumberForFilename( filepath )

  # We only apply changes in the current tab page (i.e. "visible" windows).
  # Applying changes in tabs does not lead to a better user experience, as the
  # quickfix list no longer works as you might expect (doesn't jump into other
  # tabs), and the complexity of choosing where to apply edits is significant.
  if BufferIsVisible( buffer_num ):
    # file is already open and visible, just return that buffer number (and an
    # idicator that we *didn't* open a split)
    return ( buffer_num, False )

  # The file is not open in a visible window, so we open it in a split.
  # We open the file with a small, fixed height. This means that we don't
  # make the current buffer the smallest after a series of splits.
  OpenFilename( filepath, {
    'focus': True,
    'fix': True,
    'size': GetIntValue( '&previewheight' ),
  } )

  # OpenFilename returns us to the original cursor location. This is what we
  # want, because we don't want to disorientate the user, but we do need to
  # know the (now open) buffer number for the filename
  buffer_num = GetBufferNumberForFilename( filepath )
  if not BufferIsVisible( buffer_num ):
    # This happens, for example, if there is a swap file and the user
    # selects the "Quit" or "Abort" options. We just raise an exception to
    # make it clear to the user that the abort has left potentially
    # partially-applied changes.
    raise RuntimeError(
        'Unable to open file: {0}\nFixIt/Refactor operation '
        'aborted prior to completion. Your files have not been '
        'fully updated. Please use undo commands to revert the '
        'applied changes.'.format( filepath ) )

  # We opened this file in a split
  return ( buffer_num, True )


def ReplaceChunks( chunks, silent=False ):
  """Apply the source file deltas supplied in |chunks| to arbitrary files.
  |chunks| is a list of changes defined by ycmd.responses.FixItChunk,
  which may apply arbitrary modifications to arbitrary files.

  If a file specified in a particular chunk is not currently open in a visible
  buffer (i.e., one in a window visible in the current tab), we:
    - issue a warning to the user that we're going to open new files (and offer
      her the option to abort cleanly)
    - open the file in a new split, make the changes, then hide the buffer.

  If for some reason a file could not be opened or changed, raises RuntimeError.
  Otherwise, returns no meaningful value."""

  # We apply the edits file-wise for efficiency.
  chunks_by_file = _SortChunksByFile( chunks )

  # We sort the file list simply to enable repeatable testing.
  sorted_file_list = sorted( iterkeys( chunks_by_file ) )

  if not silent:
    # Make sure the user is prepared to have her screen mutilated by the new
    # buffers.
    num_files_to_open = _GetNumNonVisibleFiles( sorted_file_list )

    if num_files_to_open > 0:
      if not Confirm(
            FIXIT_OPENING_BUFFERS_MESSAGE_FORMAT.format( num_files_to_open ) ):
        return

  # Store the list of locations where we applied changes. We use this to display
  # the quickfix window showing the user where we applied changes.
  locations = []

  for filepath in sorted_file_list:
    buffer_num, close_window = _OpenFileInSplitIfNeeded( filepath )

    locations.extend( ReplaceChunksInBuffer( chunks_by_file[ filepath ],
                                             vim.buffers[ buffer_num ] ) )

    # When opening tons of files, we don't want to have a split for each new
    # file, as this simply does not scale, so we open the window, make the
    # edits, then hide the window.
    if close_window:
      # Some plugins (I'm looking at you, syntastic) might open a location list
      # for the window we just opened. We don't want that location list hanging
      # around, so we close it. lclose is a no-op if there is no location list.
      vim.command( 'lclose' )

      # Note that this doesn't lose our changes. It simply "hides" the buffer,
      # which can later be re-accessed via the quickfix list or `:ls`
      vim.command( 'hide' )

  # Open the quickfix list, populated with entries for each location we changed.
  if not silent:
    if locations:
      SetQuickFixList( locations )

    PostVimMessage( 'Applied {0} changes'.format( len( chunks ) ),
                    warning = False )


def ReplaceChunksInBuffer( chunks, vim_buffer ):
  """Apply changes in |chunks| to the buffer-like object |buffer| and return the
  locations for that buffer."""

  # We apply the chunks from the bottom to the top of the buffer so that we
  # don't need to adjust the position of the remaining chunks due to text
  # changes. This assumes that chunks are not overlapping. However, we still
  # allow multiple chunks to share the same starting position (because of the
  # language server protocol specs). These chunks must be applied in their order
  # of appareance. Since Python sorting is stable, if we sort the whole list in
  # reverse order of location, these chunks will be reversed. Therefore, we
  # need to fully reverse the list then sort it on the starting position in
  # reverse order.
  chunks.reverse()
  chunks.sort( key = lambda chunk: (
    chunk[ 'range' ][ 'start' ][ 'line_num' ],
    chunk[ 'range' ][ 'start' ][ 'column_num' ]
  ), reverse = True )

  # However, we still want to display the locations from the top of the buffer
  # to its bottom.
  return reversed( [ ReplaceChunk( chunk[ 'range' ][ 'start' ],
                                   chunk[ 'range' ][ 'end' ],
                                   chunk[ 'replacement_text' ],
                                   vim_buffer )
                     for chunk in chunks ] )


def SplitLines( contents ):
  """Return a list of each of the lines in the byte string |contents|.
  Behavior is equivalent to str.splitlines with the following exceptions:
   - empty strings are returned as [ '' ];
   - a trailing newline is not ignored (i.e. SplitLines( '\n' )
     returns [ '', '' ], not [ '' ] )."""
  if contents == b'':
    return [ b'' ]

  lines = contents.splitlines()

  if contents.endswith( b'\r' ) or contents.endswith( b'\n' ):
    lines.append( b'' )

  return lines


# Replace the chunk of text specified by a contiguous range with the supplied
# text and return the location.
# * start and end are objects with line_num and column_num properties
# * the range is inclusive
# * indices are all 1-based
#
# NOTE: Works exclusively with bytes() instances and byte offsets as returned
# by ycmd and used within the Vim buffers
def ReplaceChunk( start, end, replacement_text, vim_buffer ):
  # ycmd's results are all 1-based, but vim's/python's are all 0-based
  # (so we do -1 on all of the values)
  start_line = start[ 'line_num' ] - 1
  end_line = end[ 'line_num' ] - 1

  start_column = start[ 'column_num' ] - 1
  end_column = end[ 'column_num' ] - 1

  # When sending a request to the server, a newline is added to the buffer
  # contents to match what gets saved to disk. If the server generates a chunk
  # containing that newline, this chunk goes past the Vim buffer contents since
  # there is actually no new line. When this happens, recompute the end position
  # of where the chunk is applied and remove all trailing characters in the
  # chunk.
  if end_line >= len( vim_buffer ):
    end_column = len( ToBytes( vim_buffer[ -1 ] ) )
    end_line = len( vim_buffer ) - 1
    replacement_text = replacement_text.rstrip()

  # NOTE: replacement_text is unicode, but all our offsets are byte offsets,
  # so we convert to bytes
  replacement_lines = SplitLines( ToBytes( replacement_text ) )

  # NOTE: Vim buffers are a list of byte objects on Python 2 but unicode
  # objects on Python 3.
  start_existing_text = ToBytes( vim_buffer[ start_line ] )[ : start_column ]
  end_line_text = ToBytes( vim_buffer[ end_line ] )
  end_existing_text = end_line_text[ end_column : ]

  replacement_lines[ 0 ] = start_existing_text + replacement_lines[ 0 ]
  replacement_lines[ -1 ] = replacement_lines[ -1 ] + end_existing_text

  cursor_line, cursor_column = CurrentLineAndColumn()

  vim_buffer[ start_line : end_line + 1 ] = replacement_lines[ : ]

  # When the cursor position is on the last line in the replaced area, and ends
  # up somewhere after the end of the new text, we need to reset the cursor
  # position. This is because Vim doesn't know where to put it, and guesses
  # badly. We put it at the end of the new text.
  if cursor_line == end_line and cursor_column >= end_column:
    cursor_line = start_line + len( replacement_lines ) - 1
    cursor_column += len( replacement_lines[ - 1 ] ) - len( end_line_text )
    SetCurrentLineAndColumn( cursor_line, cursor_column )

  return {
    'bufnr': vim_buffer.number,
    'filename': vim_buffer.name,
    # line and column numbers are 1-based in qflist
    'lnum': start_line + 1,
    'col': start_column + 1,
    'text': replacement_text,
    'type': 'F',
  }


def InsertNamespace( namespace ):
  if VariableExists( 'g:ycm_csharp_insert_namespace_expr' ):
    expr = GetVariableValue( 'g:ycm_csharp_insert_namespace_expr' )
    if expr:
      SetVariableValue( "g:ycm_namespace_to_insert", namespace )
      vim.eval( expr )
      return

  pattern = r'^\s*using\(\s\+[a-zA-Z0-9]\+\s\+=\)\?\s\+[a-zA-Z0-9.]\+\s*;\s*'
  existing_indent = ''
  line = SearchInCurrentBuffer( pattern )
  if line:
    existing_line = LineTextInCurrentBuffer( line )
    existing_indent = re.sub( r'\S.*', '', existing_line )
  new_line = '{0}using {1};\n'.format( existing_indent, namespace )
  replace_pos = { 'line_num': line + 1, 'column_num': 1 }
  ReplaceChunk( replace_pos, replace_pos, new_line, vim.current.buffer )
  PostVimMessage( 'Add namespace: {0}'.format( namespace ), warning = False )


def SearchInCurrentBuffer( pattern ):
  """ Returns the 1-indexed line on which the pattern matches
  (going UP from the current position) or 0 if not found """
  return GetIntValue(
    "search('{0}', 'Wcnb')".format( EscapeForVim( pattern ) ) )


def LineTextInCurrentBuffer( line_number ):
  """ Returns the text on the 1-indexed line (NOT 0-indexed) """
  return vim.current.buffer[ line_number - 1 ]


def ClosePreviewWindow():
  """ Close the preview window if it is present, otherwise do nothing """
  vim.command( 'silent! pclose!' )


def JumpToPreviewWindow():
  """ Jump the vim cursor to the preview window, which must be active. Returns
  boolean indicating if the cursor ended up in the preview window """
  vim.command( 'silent! wincmd P' )
  return vim.current.window.options[ 'previewwindow' ]


def JumpToPreviousWindow():
  """ Jump the vim cursor to its previous window position """
  vim.command( 'silent! wincmd p' )


def JumpToTab( tab_number ):
  """Jump to Vim tab with corresponding number """
  vim.command( 'silent! tabn {0}'.format( tab_number ) )


def OpenFileInPreviewWindow( filename ):
  """ Open the supplied filename in the preview window """
  vim.command( 'silent! pedit! ' + filename )


def WriteToPreviewWindow( message ):
  """ Display the supplied message in the preview window """

  # This isn't something that comes naturally to Vim. Vim only wants to show
  # tags and/or actual files in the preview window, so we have to hack it a
  # little bit. We generate a temporary file name and "open" that, then write
  # the data to it. We make sure the buffer can't be edited or saved. Other
  # approaches include simply opening a split, but we want to take advantage of
  # the existing Vim options for preview window height, etc.

  ClosePreviewWindow()

  OpenFileInPreviewWindow( vim.eval( 'tempname()' ) )

  if JumpToPreviewWindow():
    # We actually got to the preview window. By default the preview window can't
    # be changed, so we make it writable, write to it, then make it read only
    # again.
    vim.current.buffer.options[ 'modifiable' ] = True
    vim.current.buffer.options[ 'readonly' ]   = False

    vim.current.buffer[ : ] = message.splitlines()

    vim.current.buffer.options[ 'buftype' ]    = 'nofile'
    vim.current.buffer.options[ 'bufhidden' ]  = 'wipe'
    vim.current.buffer.options[ 'buflisted' ]  = False
    vim.current.buffer.options[ 'swapfile' ]   = False
    vim.current.buffer.options[ 'modifiable' ] = False
    vim.current.buffer.options[ 'readonly' ]   = True

    # We need to prevent closing the window causing a warning about unsaved
    # file, so we pretend to Vim that the buffer has not been changed.
    vim.current.buffer.options[ 'modified' ]   = False

    JumpToPreviousWindow()
  else:
    # We couldn't get to the preview window, but we still want to give the user
    # the information we have. The only remaining option is to echo to the
    # status area.
    PostVimMessage( message, warning = False )


def BufferIsVisibleForFilename( filename ):
  """Check if a buffer exists for a specific file."""
  buffer_number = GetBufferNumberForFilename( filename )
  return BufferIsVisible( buffer_number )


def CloseBuffersForFilename( filename ):
  """Close all buffers for a specific file."""
  buffer_number = GetBufferNumberForFilename( filename )
  while buffer_number != -1:
    vim.command( 'silent! bwipeout! {0}'.format( buffer_number ) )
    new_buffer_number = GetBufferNumberForFilename( filename )
    if buffer_number == new_buffer_number:
      raise RuntimeError( "Buffer {0} for filename '{1}' should already be "
                          "wiped out.".format( buffer_number, filename ) )
    buffer_number = new_buffer_number


def OpenFilename( filename, options = {} ):
  """Open a file in Vim. Following options are available:
  - command: specify which Vim command is used to open the file. Choices
  are same-buffer, horizontal-split, vertical-split, and new-tab (default:
  horizontal-split);
  - size: set the height of the window for a horizontal split or the width for
  a vertical one (default: '');
  - fix: set the winfixheight option for a horizontal split or winfixwidth for
  a vertical one (default: False). See :h winfix for details;
  - focus: focus the opened file (default: False);
  - watch: automatically watch for changes (default: False). This is useful
  for logs;
  - position: set the position where the file is opened (default: start).
  Choices are start and end."""

  # Set the options.
  command = GetVimCommand( options.get( 'command', 'horizontal-split' ),
                           'horizontal-split' )
  size = ( options.get( 'size', '' ) if command in [ 'split', 'vsplit' ] else
           '' )
  focus = options.get( 'focus', False )

  # There is no command in Vim to return to the previous tab so we need to
  # remember the current tab if needed.
  if not focus and command == 'tabedit':
    previous_tab = GetIntValue( 'tabpagenr()' )
  else:
    previous_tab = None

  # Open the file.
  try:
    vim.command( '{0}{1} {2}'.format( size, command, filename ) )
  # When the file we are trying to jump to has a swap file,
  # Vim opens swap-exists-choices dialog and throws vim.error with E325 error,
  # or KeyboardInterrupt after user selects one of the options which actually
  # opens the file (Open read-only/Edit anyway).
  except vim.error as e:
    if 'E325' not in str( e ):
      raise

    # Otherwise, the user might have chosen Quit. This is detectable by the
    # current file not being the target file
    if filename != GetCurrentBufferFilepath():
      return
  except KeyboardInterrupt:
    # Raised when the user selects "Abort" after swap-exists-choices
    return

  _SetUpLoadedBuffer( command,
                      filename,
                      options.get( 'fix', False ),
                      options.get( 'position', 'start' ),
                      options.get( 'watch', False ) )

  # Vim automatically set the focus to the opened file so we need to get the
  # focus back (if the focus option is disabled) when opening a new tab or
  # window.
  if not focus:
    if command == 'tabedit':
      JumpToTab( previous_tab )
    if command in [ 'split', 'vsplit' ]:
      JumpToPreviousWindow()


def _SetUpLoadedBuffer( command, filename, fix, position, watch ):
  """After opening a buffer, configure it according to the supplied options,
  which are as defined by the OpenFilename method."""

  if command == 'split':
    vim.current.window.options[ 'winfixheight' ] = fix
  if command == 'vsplit':
    vim.current.window.options[ 'winfixwidth' ] = fix

  if watch:
    vim.current.buffer.options[ 'autoread' ] = True
    vim.command( "exec 'au BufEnter <buffer> :silent! checktime {0}'"
                 .format( filename ) )

  if position == 'end':
    vim.command( 'silent! normal! Gzz' )


def BuildRange( start_line, end_line ):
  # Vim only returns the starting and ending lines of the range of a command.
  # Check if those lines correspond to a previous visual selection and if they
  # do, use the columns of that selection to build the range.
  start = vim.current.buffer.mark( '<' )
  end = vim.current.buffer.mark( '>' )
  if not start or not end or start_line != start[ 0 ] or end_line != end[ 0 ]:
    start = [ start_line, 0 ]
    end = [ end_line, len( vim.current.buffer[ end_line - 1 ] ) ]
  # Vim Python API returns 1-based lines and 0-based columns while ycmd expects
  # 1-based lines and columns.
  return {
    'range': {
      'start': {
        'line_num': start[ 0 ],
        'column_num': start[ 1 ] + 1
      },
      'end': {
        'line_num': end[ 0 ],
        # Vim returns the maximum 32-bit integer value when a whole line is
        # selected. Use the end of line instead.
        'column_num': min( end[ 1 ],
                           len( vim.current.buffer[ end[ 0 ] - 1 ] ) ) + 1
      }
    }
  }


# Expects version_string in 'MAJOR.MINOR.PATCH' format, e.g. '8.1.278'
def VimVersionAtLeast( version_string ):
  major, minor, patch = ( int( x ) for x in version_string.split( '.' ) )

  # For Vim 8.1.278, v:version is '801'
  actual_major_and_minor = GetIntValue( 'v:version' )
  matching_major_and_minor = major * 100 + minor
  if actual_major_and_minor != matching_major_and_minor:
    return actual_major_and_minor > matching_major_and_minor

  return GetBoolValue( "has( 'patch{0}' )".format( patch ) )
<EOF>
<BOF>
# Copyright (C) 2011-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from future.utils import iteritems
import base64
import json
import logging
import os
import signal
import vim
from subprocess import PIPE
from tempfile import NamedTemporaryFile
from ycm import base, paths, vimsupport
from ycm.buffer import ( BufferDict,
                         DIAGNOSTIC_UI_FILETYPES,
                         DIAGNOSTIC_UI_ASYNC_FILETYPES )
from ycmd import server_utils, utils
from ycmd.request_wrap import RequestWrap
from ycm.omni_completer import OmniCompleter
from ycm import syntax_parse
from ycm.client.ycmd_keepalive import YcmdKeepalive
from ycm.client.base_request import BaseRequest, BuildRequestData
from ycm.client.completer_available_request import SendCompleterAvailableRequest
from ycm.client.command_request import SendCommandRequest
from ycm.client.completion_request import CompletionRequest
from ycm.client.debug_info_request import ( SendDebugInfoRequest,
                                            FormatDebugInfoResponse )
from ycm.client.omni_completion_request import OmniCompletionRequest
from ycm.client.event_notification import SendEventNotificationAsync
from ycm.client.shutdown_request import SendShutdownRequest
from ycm.client.messages_request import MessagesPoll


def PatchNoProxy():
  current_value = os.environ.get( 'no_proxy', '' )
  additions = '127.0.0.1,localhost'
  os.environ[ 'no_proxy' ] = ( additions if not current_value
                               else current_value + ',' + additions )


# We need this so that Requests doesn't end up using the local HTTP proxy when
# talking to ycmd. Users should actually be setting this themselves when
# configuring a proxy server on their machine, but most don't know they need to
# or how to do it, so we do it for them.
# Relevant issues:
#  https://github.com/Valloric/YouCompleteMe/issues/641
#  https://github.com/kennethreitz/requests/issues/879
PatchNoProxy()

# Force the Python interpreter embedded in Vim (in which we are running) to
# ignore the SIGINT signal. This helps reduce the fallout of a user pressing
# Ctrl-C in Vim.
signal.signal( signal.SIGINT, signal.SIG_IGN )

HMAC_SECRET_LENGTH = 16
SERVER_SHUTDOWN_MESSAGE = (
  "The ycmd server SHUT DOWN (restart with ':YcmRestartServer')." )
EXIT_CODE_UNEXPECTED_MESSAGE = (
  "Unexpected exit code {code}. "
  "Type ':YcmToggleLogs {logfile}' to check the logs." )
CORE_UNEXPECTED_MESSAGE = (
  "Unexpected error while loading the YCM core library. "
  "Type ':YcmToggleLogs {logfile}' to check the logs." )
CORE_MISSING_MESSAGE = (
  'YCM core library not detected; you need to compile YCM before using it. '
  'Follow the instructions in the documentation.' )
CORE_PYTHON2_MESSAGE = (
  "YCM core library compiled for Python 2 but loaded in Python 3. "
  "Set the 'g:ycm_server_python_interpreter' option to a Python 2 "
  "interpreter path." )
CORE_PYTHON3_MESSAGE = (
  "YCM core library compiled for Python 3 but loaded in Python 2. "
  "Set the 'g:ycm_server_python_interpreter' option to a Python 3 "
  "interpreter path." )
CORE_OUTDATED_MESSAGE = (
  'YCM core library too old; PLEASE RECOMPILE by running the install.py '
  'script. See the documentation for more details.' )
SERVER_IDLE_SUICIDE_SECONDS = 1800  # 30 minutes
CLIENT_LOGFILE_FORMAT = 'ycm_'
SERVER_LOGFILE_FORMAT = 'ycmd_{port}_{std}_'

# Flag to set a file handle inheritable by child processes on Windows. See
# https://msdn.microsoft.com/en-us/library/ms724935.aspx
HANDLE_FLAG_INHERIT = 0x00000001


class YouCompleteMe( object ):
  def __init__( self ):
    self._available_completers = {}
    self._user_options = None
    self._user_notified_about_crash = False
    self._omnicomp = None
    self._buffers = None
    self._latest_completion_request = None
    self._logger = logging.getLogger( 'ycm' )
    self._client_logfile = None
    self._server_stdout = None
    self._server_stderr = None
    self._server_popen = None
    self._filetypes_with_keywords_loaded = set()
    self._ycmd_keepalive = YcmdKeepalive()
    self._server_is_ready_with_cache = False
    self._SetUpLogging()
    self._SetUpServer()
    self._ycmd_keepalive.Start()


  def _SetUpServer( self ):
    self._available_completers = {}
    self._user_notified_about_crash = False
    self._filetypes_with_keywords_loaded = set()
    self._server_is_ready_with_cache = False
    self._message_poll_request = None

    self._user_options = base.GetUserOptions()
    self._omnicomp = OmniCompleter( self._user_options )
    self._buffers = BufferDict( self._user_options )

    self._SetLogLevel()

    hmac_secret = os.urandom( HMAC_SECRET_LENGTH )
    options_dict = dict( self._user_options )
    options_dict[ 'hmac_secret' ] = utils.ToUnicode(
      base64.b64encode( hmac_secret ) )
    options_dict[ 'server_keep_logfiles' ] = self._user_options[
      'keep_logfiles' ]

    # The temp options file is deleted by ycmd during startup.
    with NamedTemporaryFile( delete = False, mode = 'w+' ) as options_file:
      json.dump( options_dict, options_file )

    server_port = utils.GetUnusedLocalhostPort()

    BaseRequest.server_location = 'http://127.0.0.1:' + str( server_port )
    BaseRequest.hmac_secret = hmac_secret

    try:
      python_interpreter = paths.PathToPythonInterpreter()
    except RuntimeError as error:
      error_message = (
        "Unable to start the ycmd server. {0}. "
        "Correct the error then restart the server "
        "with ':YcmRestartServer'.".format( str( error ).rstrip( '.' ) ) )
      self._logger.exception( error_message )
      vimsupport.PostVimMessage( error_message )
      return

    args = [ python_interpreter,
             paths.PathToServerScript(),
             '--port={0}'.format( server_port ),
             '--options_file={0}'.format( options_file.name ),
             '--log={0}'.format( self._user_options[ 'log_level' ] ),
             '--idle_suicide_seconds={0}'.format(
                SERVER_IDLE_SUICIDE_SECONDS ) ]

    self._server_stdout = utils.CreateLogfile(
        SERVER_LOGFILE_FORMAT.format( port = server_port, std = 'stdout' ) )
    self._server_stderr = utils.CreateLogfile(
        SERVER_LOGFILE_FORMAT.format( port = server_port, std = 'stderr' ) )
    args.append( '--stdout={0}'.format( self._server_stdout ) )
    args.append( '--stderr={0}'.format( self._server_stderr ) )

    if self._user_options[ 'keep_logfiles' ]:
      args.append( '--keep_logfiles' )

    self._server_popen = utils.SafePopen( args, stdin_windows = PIPE,
                                          stdout = PIPE, stderr = PIPE )


  def _SetUpLogging( self ):
    def FreeFileFromOtherProcesses( file_object ):
      if utils.OnWindows():
        from ctypes import windll
        import msvcrt

        file_handle = msvcrt.get_osfhandle( file_object.fileno() )
        windll.kernel32.SetHandleInformation( file_handle,
                                              HANDLE_FLAG_INHERIT,
                                              0 )

    self._client_logfile = utils.CreateLogfile( CLIENT_LOGFILE_FORMAT )

    handler = logging.FileHandler( self._client_logfile )

    # On Windows and Python prior to 3.4, file handles are inherited by child
    # processes started with at least one replaced standard stream, which is the
    # case when we start the ycmd server (we are redirecting all standard
    # outputs into a pipe). These files cannot be removed while the child
    # processes are still up. This is not desirable for a logfile because we
    # want to remove it at Vim exit without having to wait for the ycmd server
    # to be completely shut down. We need to make the logfile handle
    # non-inheritable. See https://www.python.org/dev/peps/pep-0446 for more
    # details.
    FreeFileFromOtherProcesses( handler.stream )

    formatter = logging.Formatter( '%(asctime)s - %(levelname)s - %(message)s' )
    handler.setFormatter( formatter )

    self._logger.addHandler( handler )


  def _SetLogLevel( self ):
    log_level = self._user_options[ 'log_level' ]
    numeric_level = getattr( logging, log_level.upper(), None )
    if not isinstance( numeric_level, int ):
      raise ValueError( 'Invalid log level: {0}'.format( log_level ) )
    self._logger.setLevel( numeric_level )


  def IsServerAlive( self ):
    # When the process hasn't finished yet, poll() returns None.
    return bool( self._server_popen ) and self._server_popen.poll() is None


  def CheckIfServerIsReady( self ):
    if not self._server_is_ready_with_cache and self.IsServerAlive():
      self._server_is_ready_with_cache = BaseRequest().GetDataFromHandler(
          'ready', display_message = False )
    return self._server_is_ready_with_cache


  def IsServerReady( self ):
    return self._server_is_ready_with_cache


  def NotifyUserIfServerCrashed( self ):
    if ( not self._server_popen or self._user_notified_about_crash or
         self.IsServerAlive() ):
      return
    self._user_notified_about_crash = True

    return_code = self._server_popen.poll()
    logfile = os.path.basename( self._server_stderr )
    if return_code == server_utils.CORE_UNEXPECTED_STATUS:
      error_message = CORE_UNEXPECTED_MESSAGE.format(
          logfile = logfile )
    elif return_code == server_utils.CORE_MISSING_STATUS:
      error_message = CORE_MISSING_MESSAGE
    elif return_code == server_utils.CORE_PYTHON2_STATUS:
      error_message = CORE_PYTHON2_MESSAGE
    elif return_code == server_utils.CORE_PYTHON3_STATUS:
      error_message = CORE_PYTHON3_MESSAGE
    elif return_code == server_utils.CORE_OUTDATED_STATUS:
      error_message = CORE_OUTDATED_MESSAGE
    else:
      error_message = EXIT_CODE_UNEXPECTED_MESSAGE.format(
          code = return_code,
          logfile = logfile )

    error_message = SERVER_SHUTDOWN_MESSAGE + ' ' + error_message
    self._logger.error( error_message )
    vimsupport.PostVimMessage( error_message )


  def ServerPid( self ):
    if not self._server_popen:
      return -1
    return self._server_popen.pid


  def _ShutdownServer( self ):
    SendShutdownRequest()


  def RestartServer( self ):
    vimsupport.PostVimMessage( 'Restarting ycmd server...' )
    self._ShutdownServer()
    self._SetUpServer()


  def SendCompletionRequest( self, force_semantic = False ):
    request_data = BuildRequestData()
    request_data[ 'force_semantic' ] = force_semantic
    if not self.NativeFiletypeCompletionUsable():
      wrapped_request_data = RequestWrap( request_data )
      if self._omnicomp.ShouldUseNow( wrapped_request_data ):
        self._latest_completion_request = OmniCompletionRequest(
            self._omnicomp, wrapped_request_data )
        self._latest_completion_request.Start()
        return

    self._AddExtraConfDataIfNeeded( request_data )
    self._latest_completion_request = CompletionRequest( request_data )
    self._latest_completion_request.Start()


  def CompletionRequestReady( self ):
    return bool( self._latest_completion_request and
                 self._latest_completion_request.Done() )


  def GetCompletionResponse( self ):
    response = self._latest_completion_request.Response()
    response[ 'completions' ] = base.AdjustCandidateInsertionText(
        response[ 'completions' ] )
    return response


  def SendCommandRequest( self,
                          arguments,
                          modifiers,
                          has_range,
                          start_line,
                          end_line ):
    final_arguments = []
    for argument in arguments:
      # The ft= option which specifies the completer when running a command is
      # ignored because it has not been working for a long time. The option is
      # still parsed to not break users that rely on it.
      if argument.startswith( 'ft=' ):
        continue
      final_arguments.append( argument )

    extra_data = {
      'options': {
        'tab_size': vimsupport.GetIntValue( 'shiftwidth()' ),
        'insert_spaces': vimsupport.GetBoolValue( '&expandtab' )
      }
    }
    if has_range:
      extra_data.update( vimsupport.BuildRange( start_line, end_line ) )
    self._AddExtraConfDataIfNeeded( extra_data )

    return SendCommandRequest( final_arguments,
                               modifiers,
                               self._user_options[ 'goto_buffer_command' ],
                               extra_data )


  def GetDefinedSubcommands( self ):
    subcommands = BaseRequest().PostDataToHandler( BuildRequestData(),
                                                   'defined_subcommands' )
    return subcommands if subcommands else []


  def GetCurrentCompletionRequest( self ):
    return self._latest_completion_request


  def GetOmniCompleter( self ):
    return self._omnicomp


  def FiletypeCompleterExistsForFiletype( self, filetype ):
    try:
      return self._available_completers[ filetype ]
    except KeyError:
      pass

    exists_completer = SendCompleterAvailableRequest( filetype )
    if exists_completer is None:
      return False

    self._available_completers[ filetype ] = exists_completer
    return exists_completer


  def NativeFiletypeCompletionAvailable( self ):
    return any( self.FiletypeCompleterExistsForFiletype( x ) for x in
                vimsupport.CurrentFiletypes() )


  def NativeFiletypeCompletionUsable( self ):
    disabled_filetypes = self._user_options[
      'filetype_specific_completion_to_disable' ]
    return ( vimsupport.CurrentFiletypesEnabled( disabled_filetypes ) and
             self.NativeFiletypeCompletionAvailable() )


  def NeedsReparse( self ):
    return self.CurrentBuffer().NeedsReparse()


  def UpdateWithNewDiagnosticsForFile( self, filepath, diagnostics ):
    bufnr = vimsupport.GetBufferNumberForFilename( filepath )
    if bufnr in self._buffers and vimsupport.BufferIsVisible( bufnr ):
      # Note: We only update location lists, etc. for visible buffers, because
      # otherwise we default to using the current location list and the results
      # are that non-visible buffer errors clobber visible ones.
      self._buffers[ bufnr ].UpdateWithNewDiagnostics( diagnostics )
    else:
      # The project contains errors in file "filepath", but that file is not
      # open in any buffer. This happens for Language Server Protocol-based
      # completers, as they return diagnostics for the entire "project"
      # asynchronously (rather than per-file in the response to the parse
      # request).
      #
      # There are a number of possible approaches for
      # this, but for now we simply ignore them. Other options include:
      # - Use the QuickFix list to report project errors?
      # - Use a special buffer for project errors
      # - Put them in the location list of whatever the "current" buffer is
      # - Store them in case the buffer is opened later
      # - add a :YcmProjectDiags command
      # - Add them to errror/warning _counts_ but not any actual location list
      #   or other
      # - etc.
      #
      # However, none of those options are great, and lead to their own
      # complexities. So for now, we just ignore these diagnostics for files not
      # open in any buffer.
      pass


  def OnPeriodicTick( self ):
    if not self.IsServerAlive():
      # Server has died. We'll reset when the server is started again.
      return False
    elif not self.IsServerReady():
      # Try again in a jiffy
      return True

    if not self._message_poll_request:
      self._message_poll_request = MessagesPoll()

    if not self._message_poll_request.Poll( self ):
      # Don't poll again until some event which might change the server's mind
      # about whether to provide messages for the current buffer (e.g. buffer
      # visit, file ready to parse, etc.)
      self._message_poll_request = None
      return False

    # Poll again in a jiffy
    return True


  def OnFileReadyToParse( self ):
    if not self.IsServerAlive():
      self.NotifyUserIfServerCrashed()
      return

    if not self.IsServerReady():
      return

    extra_data = {}
    self._AddTagsFilesIfNeeded( extra_data )
    self._AddSyntaxDataIfNeeded( extra_data )
    self._AddExtraConfDataIfNeeded( extra_data )

    self.CurrentBuffer().SendParseRequest( extra_data )


  def OnBufferUnload( self, deleted_buffer_number ):
    SendEventNotificationAsync( 'BufferUnload', deleted_buffer_number )


  def UpdateMatches( self ):
    self.CurrentBuffer().UpdateMatches()


  def OnBufferVisit( self ):
    extra_data = {}
    self._AddUltiSnipsDataIfNeeded( extra_data )
    SendEventNotificationAsync( 'BufferVisit', extra_data = extra_data )


  def CurrentBuffer( self ):
    return self._buffers[ vimsupport.GetCurrentBufferNumber() ]


  def OnInsertLeave( self ):
    SendEventNotificationAsync( 'InsertLeave' )


  def OnCursorMoved( self ):
    self.CurrentBuffer().OnCursorMoved()


  def _CleanLogfile( self ):
    logging.shutdown()
    if not self._user_options[ 'keep_logfiles' ]:
      if self._client_logfile:
        utils.RemoveIfExists( self._client_logfile )


  def OnVimLeave( self ):
    self._ShutdownServer()
    self._CleanLogfile()


  def OnCurrentIdentifierFinished( self ):
    SendEventNotificationAsync( 'CurrentIdentifierFinished' )


  def OnCompleteDone( self ):
    completion_request = self.GetCurrentCompletionRequest()
    if completion_request:
      completion_request.OnCompleteDone()


  def GetErrorCount( self ):
    return self.CurrentBuffer().GetErrorCount()


  def GetWarningCount( self ):
    return self.CurrentBuffer().GetWarningCount()


  def DiagnosticUiSupportedForCurrentFiletype( self ):
    return any( x in DIAGNOSTIC_UI_FILETYPES or
                x in DIAGNOSTIC_UI_ASYNC_FILETYPES
                for x in vimsupport.CurrentFiletypes() )


  def ShouldDisplayDiagnostics( self ):
    return bool( self._user_options[ 'show_diagnostics_ui' ] and
                 self.DiagnosticUiSupportedForCurrentFiletype() )


  def _PopulateLocationListWithLatestDiagnostics( self ):
    return self.CurrentBuffer().PopulateLocationList()


  def FileParseRequestReady( self ):
    # Return True if server is not ready yet, to stop repeating check timer.
    return ( not self.IsServerReady() or
             self.CurrentBuffer().FileParseRequestReady() )


  def HandleFileParseRequest( self, block = False ):
    if not self.IsServerReady():
      return

    current_buffer = self.CurrentBuffer()
    # Order is important here:
    # FileParseRequestReady has a low cost, while
    # NativeFiletypeCompletionUsable is a blocking server request
    if ( not current_buffer.IsResponseHandled() and
         current_buffer.FileParseRequestReady( block ) and
         self.NativeFiletypeCompletionUsable() ):

      if self.ShouldDisplayDiagnostics():
        # Forcefuly update the location list, etc. from the parse request when
        # doing something like :YcmDiags
        current_buffer.UpdateDiagnostics( block is True )
      else:
        # YCM client has a hard-coded list of filetypes which are known
        # to support diagnostics, self.DiagnosticUiSupportedForCurrentFiletype()
        #
        # For filetypes which don't support diagnostics, we just want to check
        # the _latest_file_parse_request for any exception or UnknownExtraConf
        # response, to allow the server to raise configuration warnings, etc.
        # to the user. We ignore any other supplied data.
        current_buffer.GetResponse()

      # We set the file parse request as handled because we want to prevent
      # repeated issuing of the same warnings/errors/prompts. Setting this
      # makes IsRequestHandled return True until the next request is created.
      #
      # Note: it is the server's responsibility to determine the frequency of
      # error/warning/prompts when receiving a FileReadyToParse event, but
      # it is our responsibility to ensure that we only apply the
      # warning/error/prompt received once (for each event).
      current_buffer.MarkResponseHandled()


  def ShouldResendFileParseRequest( self ):
    return self.CurrentBuffer().ShouldResendParseRequest()


  def DebugInfo( self ):
    debug_info = ''
    if self._client_logfile:
      debug_info += 'Client logfile: {0}\n'.format( self._client_logfile )
    extra_data = {}
    self._AddExtraConfDataIfNeeded( extra_data )
    debug_info += FormatDebugInfoResponse( SendDebugInfoRequest( extra_data ) )
    debug_info += 'Server running at: {0}\n'.format(
      BaseRequest.server_location )
    if self._server_popen:
      debug_info += 'Server process ID: {0}\n'.format( self._server_popen.pid )
    if self._server_stdout and self._server_stderr:
      debug_info += ( 'Server logfiles:\n'
                      '  {0}\n'
                      '  {1}'.format( self._server_stdout,
                                      self._server_stderr ) )
    return debug_info


  def GetLogfiles( self ):
    logfiles_list = [ self._client_logfile,
                      self._server_stdout,
                      self._server_stderr ]

    extra_data = {}
    self._AddExtraConfDataIfNeeded( extra_data )
    debug_info = SendDebugInfoRequest( extra_data )
    if debug_info:
      completer = debug_info[ 'completer' ]
      if completer:
        for server in completer[ 'servers' ]:
          logfiles_list.extend( server[ 'logfiles' ] )

    logfiles = {}
    for logfile in logfiles_list:
      logfiles[ os.path.basename( logfile ) ] = logfile
    return logfiles


  def _OpenLogfile( self, logfile ):
    # Open log files in a horizontal window with the same behavior as the
    # preview window (same height and winfixheight enabled). Automatically
    # watch for changes. Set the cursor position at the end of the file.
    options = {
      'size': vimsupport.GetIntValue( '&previewheight' ),
      'fix': True,
      'focus': False,
      'watch': True,
      'position': 'end'
    }

    vimsupport.OpenFilename( logfile, options )


  def _CloseLogfile( self, logfile ):
    vimsupport.CloseBuffersForFilename( logfile )


  def ToggleLogs( self, *filenames ):
    logfiles = self.GetLogfiles()
    if not filenames:
      sorted_logfiles = sorted( list( logfiles ) )
      try:
        logfile_index = vimsupport.SelectFromList(
          'Which logfile do you wish to open (or close if already open)?',
          sorted_logfiles )
      except RuntimeError as e:
        vimsupport.PostVimMessage( str( e ) )
        return

      logfile = logfiles[ sorted_logfiles[ logfile_index ] ]
      if not vimsupport.BufferIsVisibleForFilename( logfile ):
        self._OpenLogfile( logfile )
      else:
        self._CloseLogfile( logfile )
      return

    for filename in set( filenames ):
      if filename not in logfiles:
        continue

      logfile = logfiles[ filename ]

      if not vimsupport.BufferIsVisibleForFilename( logfile ):
        self._OpenLogfile( logfile )
        continue

      self._CloseLogfile( logfile )


  def ShowDetailedDiagnostic( self ):
    detailed_diagnostic = BaseRequest().PostDataToHandler(
        BuildRequestData(), 'detailed_diagnostic' )

    if detailed_diagnostic and 'message' in detailed_diagnostic:
      vimsupport.PostVimMessage( detailed_diagnostic[ 'message' ],
                                 warning = False )


  def ForceCompileAndDiagnostics( self ):
    if not self.NativeFiletypeCompletionUsable():
      vimsupport.PostVimMessage(
          'Native filetype completion not supported for current file, '
          'cannot force recompilation.', warning = False )
      return False
    vimsupport.PostVimMessage(
        'Forcing compilation, this will block Vim until done.',
        warning = False )
    self.OnFileReadyToParse()
    self.HandleFileParseRequest( block = True )
    vimsupport.PostVimMessage( 'Diagnostics refreshed', warning = False )
    return True


  def ShowDiagnostics( self ):
    if not self.ForceCompileAndDiagnostics():
      return

    if not self._PopulateLocationListWithLatestDiagnostics():
      vimsupport.PostVimMessage( 'No warnings or errors detected.',
                                 warning = False )
      return

    if self._user_options[ 'open_loclist_on_ycm_diags' ]:
      vimsupport.OpenLocationList( focus = True )


  def _AddSyntaxDataIfNeeded( self, extra_data ):
    if not self._user_options[ 'seed_identifiers_with_syntax' ]:
      return
    filetype = vimsupport.CurrentFiletypes()[ 0 ]
    if filetype in self._filetypes_with_keywords_loaded:
      return

    if self.IsServerReady():
      self._filetypes_with_keywords_loaded.add( filetype )
    extra_data[ 'syntax_keywords' ] = list(
       syntax_parse.SyntaxKeywordsForCurrentBuffer() )


  def _AddTagsFilesIfNeeded( self, extra_data ):
    def GetTagFiles():
      tag_files = vim.eval( 'tagfiles()' )
      return [ os.path.join( utils.GetCurrentDirectory(), tag_file )
               for tag_file in tag_files ]

    if not self._user_options[ 'collect_identifiers_from_tags_files' ]:
      return
    extra_data[ 'tag_files' ] = GetTagFiles()


  def _AddExtraConfDataIfNeeded( self, extra_data ):
    def BuildExtraConfData( extra_conf_vim_data ):
      extra_conf_data = {}
      for expr in extra_conf_vim_data:
        try:
          extra_conf_data[ expr ] = vimsupport.VimExpressionToPythonType( expr )
        except vim.error:
          message = (
            "Error evaluating '{expr}' in the 'g:ycm_extra_conf_vim_data' "
            "option.".format( expr = expr ) )
          vimsupport.PostVimMessage( message, truncate = True )
          self._logger.exception( message )
      return extra_conf_data

    extra_conf_vim_data = self._user_options[ 'extra_conf_vim_data' ]
    if extra_conf_vim_data:
      extra_data[ 'extra_conf_data' ] = BuildExtraConfData(
        extra_conf_vim_data )


  def _AddUltiSnipsDataIfNeeded( self, extra_data ):
    # See :h UltiSnips#SnippetsInCurrentScope.
    try:
      vim.eval( 'UltiSnips#SnippetsInCurrentScope( 1 )' )
    except vim.error:
      return

    snippets = vimsupport.GetVariableValue( 'g:current_ulti_dict_info' )
    extra_data[ 'ultisnips_snippets' ] = [
      { 'trigger': trigger,
        'description': snippet[ 'description' ] }
      for trigger, snippet in iteritems( snippets )
    ]
<EOF>
<BOF>
# Copyright (C) 2016  YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from future.utils import iterkeys, iteritems
from ycm import vimsupport
import re


class DiagnosticFilter( object ):
  def __init__( self, config_or_filters ):
    if isinstance( config_or_filters, list ):
      self._filters = config_or_filters

    else:
      self._filters = _CompileFilters( config_or_filters )


  def IsAllowed( self, diagnostic ):
    # NOTE: a diagnostic IsAllowed() ONLY if NO filters match it
    for filterMatches in self._filters:
      if filterMatches( diagnostic ):
        return False

    return True


  def SubsetForTypes( self, filetypes ):
    """Return a sub-filter limited to the given filetypes"""
    # NOTE: actually, this class is already filtered
    return self


  @staticmethod
  def CreateFromOptions( user_options ):
    all_filters = user_options[ 'filter_diagnostics' ]
    compiled_by_type = {}
    for type_spec, filter_value in iteritems( all_filters ):
      filetypes = [ type_spec ]
      if type_spec.find( ',' ) != -1:
        filetypes = type_spec.split( ',' )
      for filetype in filetypes:
        compiled_by_type[ filetype ] = _CompileFilters( filter_value )

    return _MasterDiagnosticFilter( compiled_by_type )


class _MasterDiagnosticFilter( object ):

  def __init__( self, all_filters ):
    self._all_filters = all_filters
    self._cache = {}


  def IsAllowed( self, diagnostic ):
    # NOTE: in this class's implementation, we ask vimsupport for
    #  the current filetypes and delegate automatically; it is probably,
    #  more efficient, however, to call SubsetForTypes() and reuse
    #  the returned DiagnosticFilter if it will be checked repeatedly.
    filetypes = vimsupport.CurrentFiletypes()
    return self.SubsetForTypes( filetypes ).IsAllowed( diagnostic )


  def SubsetForTypes( self, filetypes ):
    # check cache
    cache_key = ','.join( filetypes )
    cached = self._cache.get( cache_key )
    if cached is not None:
      return cached

    # build a new DiagnosticFilter merging all filters
    #  for the provided filetypes
    spec = []
    for filetype in filetypes:
      type_specific = self._all_filters.get( filetype, [] )
      spec.extend( type_specific )

    new_filter = DiagnosticFilter( spec )
    self._cache[ cache_key ] = new_filter
    return new_filter


def _ListOf( config_entry ):
  if isinstance( config_entry, list ):
    return config_entry

  if config_entry is None:
    return []

  return [ config_entry ]


def CompileRegex( raw_regex ):
  pattern = re.compile( raw_regex, re.IGNORECASE )

  def FilterRegex( diagnostic ):
    return pattern.search( diagnostic[ 'text' ] ) is not None

  return FilterRegex


def CompileLevel( level ):
  # valid kinds are WARNING and ERROR;
  #  expected input levels are `warning` and `error`
  # NOTE: we don't validate the input...
  expected_kind = level.upper()

  def FilterLevel( diagnostic ):
    return diagnostic[ 'kind' ] == expected_kind

  return FilterLevel


FILTER_COMPILERS = { 'regex' : CompileRegex,
                     'level' : CompileLevel }


def _CompileFilters( config ):
  """Given a filter config dictionary, return a list of compiled filters"""
  filters = []

  for filter_type in iterkeys( config ):
    compiler = FILTER_COMPILERS.get( filter_type )

    if compiler is not None:
      for filter_config in _ListOf( config[ filter_type ] ):
        compiledFilter = compiler( filter_config )
        filters.append( compiledFilter )

  return filters
<EOF>
<BOF>
# Copyright (C) 2016, Davit Samvelyan
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm import vimsupport
from ycm.client.event_notification import EventNotification
from ycm.diagnostic_interface import DiagnosticInterface


DIAGNOSTIC_UI_FILETYPES = { 'cpp', 'cs', 'c', 'objc', 'objcpp', 'cuda',
                            'javascript', 'typescript' }
DIAGNOSTIC_UI_ASYNC_FILETYPES = { 'java' }


# Emulates Vim buffer
# Used to store buffer related information like diagnostics, latest parse
# request. Stores buffer change tick at the parse request moment, allowing
# to effectively determine whether reparse is needed for the buffer.
class Buffer( object ):

  def __init__( self, bufnr, user_options, async_diags ):
    self.number = bufnr
    self._parse_tick = 0
    self._handled_tick = 0
    self._parse_request = None
    self._async_diags = async_diags
    self._diag_interface = DiagnosticInterface( bufnr, user_options )


  def FileParseRequestReady( self, block = False ):
    return bool( self._parse_request and
                 ( block or self._parse_request.Done() ) )


  def SendParseRequest( self, extra_data ):
    self._parse_request = EventNotification( 'FileReadyToParse',
                                             extra_data = extra_data )
    self._parse_request.Start()
    # Decrement handled tick to ensure correct handling when we are forcing
    # reparse on buffer visit and changed tick remains the same.
    self._handled_tick -= 1
    self._parse_tick = self._ChangedTick()


  def NeedsReparse( self ):
    return self._parse_tick != self._ChangedTick()


  def ShouldResendParseRequest( self ):
    return bool( self._parse_request and self._parse_request.ShouldResend() )


  def UpdateDiagnostics( self, force=False ):
    if force or not self._async_diags:
      self.UpdateWithNewDiagnostics( self._parse_request.Response() )
    else:
      # We need to call the response method, because it might throw an exception
      # or require extra config confirmation, even if we don't actually use the
      # diagnostics.
      self._parse_request.Response()


  def UpdateWithNewDiagnostics( self, diagnostics ):
    self._diag_interface.UpdateWithNewDiagnostics( diagnostics )


  def UpdateMatches( self ):
    self._diag_interface.UpdateMatches()


  def PopulateLocationList( self ):
    return self._diag_interface.PopulateLocationList()


  def GetResponse( self ):
    return self._parse_request.Response()


  def IsResponseHandled( self ):
    return self._handled_tick == self._parse_tick


  def MarkResponseHandled( self ):
    self._handled_tick = self._parse_tick


  def OnCursorMoved( self ):
    self._diag_interface.OnCursorMoved()


  def GetErrorCount( self ):
    return self._diag_interface.GetErrorCount()


  def GetWarningCount( self ):
    return self._diag_interface.GetWarningCount()


  def _ChangedTick( self ):
    return vimsupport.GetBufferChangedTick( self.number )


class BufferDict( dict ):

  def __init__( self, user_options ):
    self._user_options = user_options


  def __missing__( self, key ):
    # Python does not allow to return assignment operation result directly
    new_value = self[ key ] = Buffer(
      key,
      self._user_options,
      any( x in DIAGNOSTIC_UI_ASYNC_FILETYPES
           for x in vimsupport.GetBufferFiletypes( key ) ) )

    return new_value
<EOF>
<BOF>
# Copyright (C) 2011, 2012  Google Inc.
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm import vimsupport
from ycmd import identifier_utils

YCM_VAR_PREFIX = 'ycm_'


def GetUserOptions():
  """Builds a dictionary mapping YCM Vim user options to values. Option names
  don't have the 'ycm_' prefix."""
  # We only evaluate the keys of the vim globals and not the whole dictionary
  # to avoid unicode issues.
  # See https://github.com/Valloric/YouCompleteMe/pull/2151 for details.
  keys = vimsupport.GetVimGlobalsKeys()
  user_options = {}
  for key in keys:
    if not key.startswith( YCM_VAR_PREFIX ):
      continue
    new_key = key[ len( YCM_VAR_PREFIX ): ]
    new_value = vimsupport.VimExpressionToPythonType( 'g:' + key )
    user_options[ new_key ] = new_value

  return user_options


def CurrentIdentifierFinished():
  line, current_column = vimsupport.CurrentLineContentsAndCodepointColumn()
  previous_char_index = current_column - 1
  if previous_char_index < 0:
    return True
  filetype = vimsupport.CurrentFiletypes()[ 0 ]
  regex = identifier_utils.IdentifierRegexForFiletype( filetype )

  for match in regex.finditer( line ):
    if match.end() == previous_char_index:
      return True
  # If the whole line is whitespace, that means the user probably finished an
  # identifier on the previous line.
  return line[ : current_column ].isspace()


def LastEnteredCharIsIdentifierChar():
  line, current_column = vimsupport.CurrentLineContentsAndCodepointColumn()
  if current_column - 1 < 0:
    return False
  filetype = vimsupport.CurrentFiletypes()[ 0 ]
  return (
    identifier_utils.StartOfLongestIdentifierEndingAtIndex(
        line, current_column, filetype ) != current_column )


def AdjustCandidateInsertionText( candidates ):
  """This function adjusts the candidate insertion text to take into account the
  text that's currently in front of the cursor.

  For instance ('|' represents the cursor):
    1. Buffer state: 'foo.|bar'
    2. A completion candidate of 'zoobar' is shown and the user selects it.
    3. Buffer state: 'foo.zoobar|bar' instead of 'foo.zoo|bar' which is what the
    user wanted.

  This function changes candidates to resolve that issue.

  It could be argued that the user actually wants the final buffer state to be
  'foo.zoobar|' (the cursor at the end), but that would be much more difficult
  to implement and is probably not worth doing.
  """

  def NewCandidateInsertionText( to_insert, text_after_cursor ):
    overlap_len = OverlapLength( to_insert, text_after_cursor )
    if overlap_len:
      return to_insert[ :-overlap_len ]
    return to_insert

  text_after_cursor = vimsupport.TextAfterCursor()
  if not text_after_cursor:
    return candidates

  new_candidates = []
  for candidate in candidates:
    new_candidate = candidate.copy()

    if 'abbr' not in new_candidate:
      new_candidate[ 'abbr' ] = new_candidate[ 'word' ]

    new_candidate[ 'word' ] = NewCandidateInsertionText(
      new_candidate[ 'word' ],
      text_after_cursor )

    new_candidates.append( new_candidate )
  return new_candidates


def OverlapLength( left_string, right_string ):
  """Returns the length of the overlap between two strings.
  Example: "foo baro" and "baro zoo" -> 4
  """
  left_string_length = len( left_string )
  right_string_length = len( right_string )

  if not left_string_length or not right_string_length:
    return 0

  # Truncate the longer string.
  if left_string_length > right_string_length:
    left_string = left_string[ -right_string_length: ]
  elif left_string_length < right_string_length:
    right_string = right_string[ :left_string_length ]

  if left_string == right_string:
    return min( left_string_length, right_string_length )

  # Start by looking for a single character match
  # and increase length until no match is found.
  best = 0
  length = 1
  while True:
    pattern = left_string[ -length: ]
    found = right_string.find( pattern )
    if found < 0:
      return best
    length += found
    if left_string[ -length: ] == right_string[ :length ]:
      best = length
      length += 1
<EOF>
<BOF>
# Copyright (C) 2013-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from future.utils import itervalues, iteritems
from collections import defaultdict
from ycm import vimsupport
from ycm.diagnostic_filter import DiagnosticFilter, CompileLevel


class DiagnosticInterface( object ):
  def __init__( self, bufnr, user_options ):
    self._bufnr = bufnr
    self._user_options = user_options
    self._diagnostics = []
    self._diag_filter = DiagnosticFilter.CreateFromOptions( user_options )
    # Line and column numbers are 1-based
    self._line_to_diags = defaultdict( list )
    self._previous_diag_line_number = -1
    self._diag_message_needs_clearing = False


  def OnCursorMoved( self ):
    if self._user_options[ 'echo_current_diagnostic' ]:
      line, _ = vimsupport.CurrentLineAndColumn()
      line += 1  # Convert to 1-based
      if line != self._previous_diag_line_number:
        self._EchoDiagnosticForLine( line )


  def GetErrorCount( self ):
    return self._DiagnosticsCount( _DiagnosticIsError )


  def GetWarningCount( self ):
    return self._DiagnosticsCount( _DiagnosticIsWarning )


  def PopulateLocationList( self ):
    # Do nothing if loc list is already populated by diag_interface
    if not self._user_options[ 'always_populate_location_list' ]:
      self._UpdateLocationLists()
    return bool( self._diagnostics )


  def UpdateWithNewDiagnostics( self, diags ):
    self._diagnostics = [ _NormalizeDiagnostic( x ) for x in
                            self._ApplyDiagnosticFilter( diags ) ]
    self._ConvertDiagListToDict()

    if self._user_options[ 'echo_current_diagnostic' ]:
      self._EchoDiagnostic()

    if self._user_options[ 'enable_diagnostic_signs' ]:
      self._UpdateSigns()

    self.UpdateMatches()

    if self._user_options[ 'always_populate_location_list' ]:
      self._UpdateLocationLists()


  def _ApplyDiagnosticFilter( self, diags ):
    filetypes = vimsupport.GetBufferFiletypes( self._bufnr )
    diag_filter = self._diag_filter.SubsetForTypes( filetypes )
    return filter( diag_filter.IsAllowed, diags )


  def _EchoDiagnostic( self ):
    line, _ = vimsupport.CurrentLineAndColumn()
    line += 1  # Convert to 1-based
    self._EchoDiagnosticForLine( line )


  def _EchoDiagnosticForLine( self, line_num ):
    self._previous_diag_line_number = line_num

    diags = self._line_to_diags[ line_num ]
    if not diags:
      if self._diag_message_needs_clearing:
        # Clear any previous diag echo
        vimsupport.PostVimMessage( '', warning = False )
        self._diag_message_needs_clearing = False
      return

    first_diag = diags[ 0 ]
    text = first_diag[ 'text' ]
    if first_diag.get( 'fixit_available', False ):
      text += ' (FixIt)'

    vimsupport.PostVimMessage( text, warning = False, truncate = True )
    self._diag_message_needs_clearing = True


  def _DiagnosticsCount( self, predicate ):
    count = 0
    for diags in itervalues( self._line_to_diags ):
      count += sum( 1 for d in diags if predicate( d ) )
    return count


  def _UpdateLocationLists( self ):
    vimsupport.SetLocationListsForBuffer(
      self._bufnr,
      vimsupport.ConvertDiagnosticsToQfList( self._diagnostics ) )


  def UpdateMatches( self ):
    if not self._user_options[ 'enable_diagnostic_highlighting' ]:
      return

    # Vim doesn't provide a way to update the matches for a different window
    # than the current one (which is a view of the current buffer).
    if vimsupport.GetCurrentBufferNumber() != self._bufnr:
      return

    matches_to_remove = vimsupport.GetDiagnosticMatchesInCurrentWindow()

    for diags in itervalues( self._line_to_diags ):
      # Insert squiggles in reverse order so that errors overlap warnings.
      for diag in reversed( diags ):
        group = ( 'YcmErrorSection' if _DiagnosticIsError( diag ) else
                  'YcmWarningSection' )

        for pattern in _ConvertDiagnosticToMatchPatterns( diag ):
          # The id doesn't matter for matches that we may add.
          match = vimsupport.DiagnosticMatch( 0, group, pattern )
          try:
            matches_to_remove.remove( match )
          except ValueError:
            vimsupport.AddDiagnosticMatch( match )

    for match in matches_to_remove:
      vimsupport.RemoveDiagnosticMatch( match )


  def _UpdateSigns( self ):
    signs_to_unplace = vimsupport.GetSignsInBuffer( self._bufnr )

    for line, diags in iteritems( self._line_to_diags ):
      if not diags:
        continue

      # We always go for the first diagnostic on the line because diagnostics
      # are sorted by errors in priority and Vim can only display one sign by
      # line.
      name = 'YcmError' if _DiagnosticIsError( diags[ 0 ] ) else 'YcmWarning'
      sign = vimsupport.CreateSign( line, name, self._bufnr )

      try:
        signs_to_unplace.remove( sign )
      except ValueError:
        vimsupport.PlaceSign( sign )

    for sign in signs_to_unplace:
      vimsupport.UnplaceSign( sign )


  def _ConvertDiagListToDict( self ):
    self._line_to_diags = defaultdict( list )
    for diag in self._diagnostics:
      location = diag[ 'location' ]
      bufnr = vimsupport.GetBufferNumberForFilename( location[ 'filepath' ] )
      if bufnr == self._bufnr:
        line_number = location[ 'line_num' ]
        self._line_to_diags[ line_number ].append( diag )

    for diags in itervalues( self._line_to_diags ):
      # We also want errors to be listed before warnings so that errors aren't
      # hidden by the warnings; Vim won't place a sign over an existing one.
      diags.sort( key = lambda diag: ( diag[ 'kind' ],
                                       diag[ 'location' ][ 'column_num' ] ) )


_DiagnosticIsError = CompileLevel( 'error' )
_DiagnosticIsWarning = CompileLevel( 'warning' )


def _NormalizeDiagnostic( diag ):
  def ClampToOne( value ):
    return value if value > 0 else 1

  location = diag[ 'location' ]
  location[ 'column_num' ] = ClampToOne( location[ 'column_num' ] )
  location[ 'line_num' ] = ClampToOne( location[ 'line_num' ] )
  return diag


def _ConvertDiagnosticToMatchPatterns( diagnostic ):
  patterns = []

  location_extent = diagnostic[ 'location_extent' ]
  if location_extent[ 'start' ][ 'line_num' ] <= 0:
    location = diagnostic[ 'location' ]
    patterns.append( vimsupport.GetDiagnosticMatchPattern(
      location[ 'line_num' ],
      location[ 'column_num' ] ) )
  else:
    patterns.append( vimsupport.GetDiagnosticMatchPattern(
      location_extent[ 'start' ][ 'line_num' ],
      location_extent[ 'start' ][ 'column_num' ],
      location_extent[ 'end' ][ 'line_num' ],
      location_extent[ 'end' ][ 'column_num' ] ) )

  for diagnostic_range in diagnostic[ 'ranges' ]:
    patterns.append( vimsupport.GetDiagnosticMatchPattern(
      diagnostic_range[ 'start' ][ 'line_num' ],
      diagnostic_range[ 'start' ][ 'column_num' ],
      diagnostic_range[ 'end' ][ 'line_num' ],
      diagnostic_range[ 'end' ][ 'column_num' ] ) )

  return patterns
<EOF>
<BOF>
# Copyright (C) 2013  Google Inc.
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from future.utils import itervalues
import re
from ycm import vimsupport

SYNTAX_GROUP_REGEX = re.compile(
  r"""^
      (?P<group_name>\w+)
      \s+
      xxx
      \s+
      (?P<content>.+?)
      $""",
  re.VERBOSE )

KEYWORD_REGEX = re.compile( r'^(\w+),?$' )

SYNTAX_ARGUMENT_REGEX = re.compile(
  r"^\w+=.*$" )

SYNTAX_REGION_ARGUMENT_REGEX = re.compile(
  r"^(?:matchgroup|start)=.*$" )

# See ":h syn-nextgroup".
SYNTAX_NEXTGROUP_ARGUMENTS = {
  'skipwhite',
  'skipnl',
  'skipempty'
}

# These are the parent groups from which we want to extract keywords.
ROOT_GROUPS = {
  'Boolean',
  'Identifier',
  'Statement',
  'PreProc',
  'Type'
}


class SyntaxGroup( object ):
  def __init__( self, name, lines = None ):
    self.name     = name
    self.lines    = lines if lines else []
    self.children = []


def SyntaxKeywordsForCurrentBuffer():
  syntax_output = vimsupport.CaptureVimCommand( 'syntax list' )
  return _KeywordsFromSyntaxListOutput( syntax_output )


def _KeywordsFromSyntaxListOutput( syntax_output ):
  group_name_to_group = _SyntaxGroupsFromOutput( syntax_output )
  _ConnectGroupChildren( group_name_to_group )

  groups_with_keywords = []
  for root_group in ROOT_GROUPS:
    groups_with_keywords.extend(
      _GetAllDescendentats( group_name_to_group[ root_group ] ) )

  keywords = []
  for group in groups_with_keywords:
    keywords.extend( _ExtractKeywordsFromGroup( group ) )
  return set( keywords )


def _SyntaxGroupsFromOutput( syntax_output ):
  group_name_to_group = _CreateInitialGroupMap()
  lines               = syntax_output.split( '\n' )
  looking_for_group   = True

  current_group = None
  for line in lines:
    if not line:
      continue

    match = SYNTAX_GROUP_REGEX.search( line )
    if match:
      if looking_for_group:
        looking_for_group = False
      else:
        group_name_to_group[ current_group.name ] = current_group

      current_group = SyntaxGroup( match.group( 'group_name' ),
                                   [ match.group( 'content' ).strip() ] )
    else:
      if looking_for_group:
        continue

      if line[ 0 ] == ' ' or line[ 0 ] == '\t':
        current_group.lines.append( line.strip() )

  if current_group:
    group_name_to_group[ current_group.name ] = current_group
  return group_name_to_group


def _CreateInitialGroupMap():
  def AddToGroupMap( name, parent ):
    new_group = SyntaxGroup( name )
    group_name_to_group[ name ] = new_group
    parent.children.append( new_group )

  identifier_group = SyntaxGroup( 'Identifier' )
  statement_group  = SyntaxGroup( 'Statement' )
  type_group       = SyntaxGroup( 'Type' )
  preproc_group    = SyntaxGroup( 'PreProc' )

  # See ":h group-name" for details on how the initial group hierarchy is built.
  group_name_to_group = {
    'Boolean': SyntaxGroup( 'Boolean' ),
    'Identifier': identifier_group,
    'Statement': statement_group,
    'PreProc': preproc_group,
    'Type': type_group
  }

  AddToGroupMap( 'Function', identifier_group )

  AddToGroupMap( 'Conditional', statement_group )
  AddToGroupMap( 'Repeat'     , statement_group )
  AddToGroupMap( 'Label'      , statement_group )
  AddToGroupMap( 'Operator'   , statement_group )
  AddToGroupMap( 'Keyword'    , statement_group )
  AddToGroupMap( 'Exception'  , statement_group )

  AddToGroupMap( 'StorageClass', type_group )
  AddToGroupMap( 'Structure'   , type_group )
  AddToGroupMap( 'Typedef'     , type_group )

  AddToGroupMap( 'Include'  , preproc_group )
  AddToGroupMap( 'Define'   , preproc_group )
  AddToGroupMap( 'Macro'    , preproc_group )
  AddToGroupMap( 'PreCondit', preproc_group )

  return group_name_to_group


def _ConnectGroupChildren( group_name_to_group ):
  def GetParentNames( group ):
    links_to     = 'links to '
    parent_names = []
    for line in group.lines:
      if line.startswith( links_to ):
        parent_names.append( line[ len( links_to ): ] )
    return parent_names

  for group in itervalues( group_name_to_group ):
    parent_names = GetParentNames( group )

    for parent_name in parent_names:
      try:
        parent_group = group_name_to_group[ parent_name ]
      except KeyError:
        continue
      parent_group.children.append( group )


def _GetAllDescendentats( root_group ):
  descendants = []
  for child in root_group.children:
    descendants.append( child )
    descendants.extend( _GetAllDescendentats( child ) )
  return descendants


def _ExtractKeywordsFromLine( line ):
  if line.startswith( 'links to ' ):
    return []

  # Ignore "syntax match" lines (see ":h syn-match").
  if line.startswith( 'match ' ):
    return []

  words = line.split()
  if not words:
    return []

  # Ignore "syntax region" lines (see ":h syn-region"). They always start
  # with matchgroup= or start= in the syntax list.
  if SYNTAX_REGION_ARGUMENT_REGEX.match( words[ 0 ] ):
    return []

  # Ignore "nextgroup=" argument in first position and the arguments
  # "skipwhite", "skipnl", and "skipempty" that immediately come after.
  nextgroup_at_start = False
  if words[ 0 ].startswith( 'nextgroup=' ):
    nextgroup_at_start = True
    words = words[ 1: ]

  # Ignore "contained" argument in first position.
  if words[ 0 ] == 'contained':
    words = words[ 1: ]

  keywords = []
  for word in words:
    if nextgroup_at_start and word in SYNTAX_NEXTGROUP_ARGUMENTS:
      continue

    nextgroup_at_start = False

    keyword_matched = KEYWORD_REGEX.match( word )
    if keyword_matched:
      keywords.append( keyword_matched.group( 1 ) )
  return keywords


def _ExtractKeywordsFromGroup( group ):
  keywords = []
  for line in group.lines:
    keywords.extend( _ExtractKeywordsFromLine( line ) )
  return keywords
<EOF>
<BOF>
# Copyright 2009 Brian Quinlan. All Rights Reserved.
#   Licensed to PSF under a Contributor Agreement.
#
# Copyright (C) 2013  Google Inc.
#   Changes to this file are licensed under the same terms as the original file
#   (the Python Software Foundation License).


from __future__ import with_statement
import threading
import weakref
import sys

from concurrent.futures import _base

try:
  import queue
except ImportError:
  import Queue as queue


# This file provides an UnsafeThreadPoolExecutor, which operates exactly like
# the upstream Python version of ThreadPoolExecutor with one exception: it
# doesn't wait for worker threads to finish before shutting down the Python
# interpreter.
#
# This is dangerous for many workloads, but fine for some (like when threads
# only send network requests). The YCM workload is one of those workloads where
# it's safe (the aforementioned network requests case).

class _WorkItem( object ):
  def __init__( self, future, fn, args, kwargs ):
    self.future = future
    self.fn = fn
    self.args = args
    self.kwargs = kwargs

  def run( self ):
    if not self.future.set_running_or_notify_cancel():
      return

    try:
      result = self.fn( *self.args, **self.kwargs )
    except BaseException:
      e = sys.exc_info()[ 1 ]
      self.future.set_exception( e )
    else:
      self.future.set_result( result )


def _worker( executor_reference, work_queue ):
  try:
    while True:
      work_item = work_queue.get( block=True )
      if work_item is not None:
        work_item.run()
        continue
      executor = executor_reference()
      # Exit if:
      #   - The executor that owns the worker has been collected OR
      #   - The executor that owns the worker has been shutdown.
      if executor is None or executor._shutdown:
        # Notice other workers
        work_queue.put( None )
        return
      del executor
  except BaseException:
    _base.LOGGER.critical( 'Exception in worker', exc_info=True )


class UnsafeThreadPoolExecutor( _base.Executor ):
  def __init__( self, max_workers ):
    """Initializes a new ThreadPoolExecutor instance.

    Args:
        max_workers: The maximum number of threads that can be used to
            execute the given calls.
    """
    self._max_workers = max_workers
    self._work_queue = queue.Queue()
    self._threads = set()
    self._shutdown = False
    self._shutdown_lock = threading.Lock()

  def submit( self, fn, *args, **kwargs ):
    with self._shutdown_lock:
      if self._shutdown:
        raise RuntimeError( 'cannot schedule new futures after shutdown' )

      f = _base.Future()
      w = _WorkItem( f, fn, args, kwargs )

      self._work_queue.put( w )
      self._adjust_thread_count()
      return f
  submit.__doc__ = _base.Executor.submit.__doc__

  def _adjust_thread_count( self ):
    # When the executor gets lost, the weakref callback will wake up
    # the worker threads.
    def weakref_cb( _, q=self._work_queue ):
      q.put( None )
    # TODO(bquinlan): Should avoid creating new threads if there are more
    # idle threads than items in the work queue.
    if len( self._threads ) < self._max_workers:
      t = threading.Thread( target=_worker,
                            args=( weakref.ref( self, weakref_cb ),
                                   self._work_queue ) )
      t.daemon = True
      t.start()
      self._threads.add( t )

  def shutdown( self, wait=True ):
    with self._shutdown_lock:
      self._shutdown = True
      self._work_queue.put( None )
    if wait:
      for t in self._threads:
        t.join()
  shutdown.__doc__ = _base.Executor.shutdown.__doc__
<EOF>
<BOF>
# Copyright (C) 2015-2017 YouCompleteMe contributors.
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

import os
import sys
import vim
import re

# Can't import these from setup.py because it makes nosetests go crazy.
DIR_OF_CURRENT_SCRIPT = os.path.dirname( os.path.abspath( __file__ ) )
DIR_OF_YCMD = os.path.join( DIR_OF_CURRENT_SCRIPT, '..', '..', 'third_party',
                            'ycmd' )
WIN_PYTHON_PATH = os.path.join( sys.exec_prefix, 'python.exe' )
PYTHON_BINARY_REGEX = re.compile(
  r'python((2(\.[67])?)|(3(\.[3-9])?))?(.exe)?$', re.IGNORECASE )


# Not caching the result of this function; users shouldn't have to restart Vim
# after running the install script or setting the
# `g:ycm_server_python_interpreter` option.
def PathToPythonInterpreter():
  # Not calling the Python interpreter to check its version as it significantly
  # impacts startup time.
  from ycmd import utils

  python_interpreter = vim.eval( 'g:ycm_server_python_interpreter' )
  if python_interpreter:
    python_interpreter = utils.FindExecutable( python_interpreter )
    if python_interpreter:
      return python_interpreter

    raise RuntimeError( "Path in 'g:ycm_server_python_interpreter' option "
                        "does not point to a valid Python 2.7 or 3.4+." )

  python_interpreter = _PathToPythonUsedDuringBuild()
  if python_interpreter and utils.GetExecutable( python_interpreter ):
    return python_interpreter

  # On UNIX platforms, we use sys.executable as the Python interpreter path.
  # We cannot use sys.executable on Windows because for unknown reasons, it
  # returns the Vim executable. Instead, we use sys.exec_prefix to deduce the
  # interpreter path.
  python_interpreter = ( WIN_PYTHON_PATH if utils.OnWindows() else
                         sys.executable )
  if _EndsWithPython( python_interpreter ):
    return python_interpreter

  # As a last resort, we search python in the PATH. We prefer Python 2 over 3
  # for the sake of backwards compatibility with ycm_extra_conf.py files out
  # there; few people wrote theirs to work on py3.
  # So we check 'python2' before 'python' because on some distributions (Arch
  # Linux for example), python refers to python3.
  python_interpreter = utils.PathToFirstExistingExecutable( [ 'python2',
                                                              'python',
                                                              'python3' ] )
  if python_interpreter:
    return python_interpreter

  raise RuntimeError( "Cannot find Python 2.7 or 3.4+. "
                      "Set the 'g:ycm_server_python_interpreter' option "
                      "to a Python interpreter path." )


def _PathToPythonUsedDuringBuild():
  from ycmd import utils

  try:
    filepath = os.path.join( DIR_OF_YCMD, 'PYTHON_USED_DURING_BUILDING' )
    return utils.ReadFile( filepath ).strip()
  # We need to check for IOError for Python2 and OSError for Python3
  except ( IOError, OSError ):
    return None


def _EndsWithPython( path ):
  """Check if given path ends with a python 2.7 or 3.4+ name."""
  return path and PYTHON_BINARY_REGEX.search( path ) is not None


def PathToServerScript():
  return os.path.join( DIR_OF_YCMD, 'ycmd' )
<EOF>
<BOF>
# Copyright (C) 2011, 2012, 2013  Google Inc.
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

import vim
from ycm import vimsupport
from ycmd import utils
from ycmd.completers.completer import Completer
from ycm.client.base_request import BaseRequest

OMNIFUNC_RETURNED_BAD_VALUE = 'Omnifunc returned bad value to YCM!'
OMNIFUNC_NOT_LIST = ( 'Omnifunc did not return a list or a dict with a "words" '
                     ' list when expected.' )


class OmniCompleter( Completer ):
  def __init__( self, user_options ):
    super( OmniCompleter, self ).__init__( user_options )
    self._omnifunc = None


  def SupportedFiletypes( self ):
    return []


  def ShouldUseCache( self ):
    return bool( self.user_options[ 'cache_omnifunc' ] )


  def ShouldUseNow( self, request_data ):
    self._omnifunc = utils.ToUnicode( vim.eval( '&omnifunc' ) )
    if not self._omnifunc:
      return False
    if self.ShouldUseCache():
      return super( OmniCompleter, self ).ShouldUseNow( request_data )
    return self.ShouldUseNowInner( request_data )


  def ShouldUseNowInner( self, request_data ):
    if request_data[ 'force_semantic' ]:
      return True
    disabled_filetypes = self.user_options[
      'filetype_specific_completion_to_disable' ]
    if not vimsupport.CurrentFiletypesEnabled( disabled_filetypes ):
      return False
    return super( OmniCompleter, self ).ShouldUseNowInner( request_data )


  def ComputeCandidates( self, request_data ):
    if self.ShouldUseCache():
      return super( OmniCompleter, self ).ComputeCandidates( request_data )
    if self.ShouldUseNowInner( request_data ):
      return self.ComputeCandidatesInner( request_data )
    return []


  def ComputeCandidatesInner( self, request_data ):
    if not self._omnifunc:
      return []

    # Calling directly the omnifunc may move the cursor position. This is the
    # case with the default Vim omnifunc for C-family languages
    # (ccomplete#Complete) which calls searchdecl to find a declaration. This
    # function is supposed to move the cursor to the found declaration but it
    # doesn't when called through the omni completion mapping (CTRL-X CTRL-O).
    # So, we restore the cursor position after the omnifunc calls.
    line, column = vimsupport.CurrentLineAndColumn()

    try:
      start_column = vimsupport.GetIntValue( self._omnifunc + '(1,"")' )

      # Vim only stops completion if the value returned by the omnifunc is -3 or
      # -2. In other cases, if the value is negative or greater than the current
      # column, the start column is set to the current column; otherwise, the
      # value is used as the start column.
      if start_column in ( -3, -2 ):
        return []
      if start_column < 0 or start_column > column:
        start_column = column

      # Use the start column calculated by the omnifunc, rather than our own
      # interpretation. This is important for certain languages where our
      # identifier detection is either incorrect or not compatible with the
      # behaviour of the omnifunc. Note: do this before calling the omnifunc
      # because it affects the value returned by 'query'.
      request_data[ 'start_column' ] = start_column + 1

      # Vim internally moves the cursor to the start column before calling again
      # the omnifunc. Some omnifuncs like the one defined by the
      # LanguageClient-neovim plugin depend on this behavior to compute the list
      # of candidates.
      vimsupport.SetCurrentLineAndColumn( line, start_column )

      omnifunc_call = [ self._omnifunc,
                        "(0,'",
                        vimsupport.EscapeForVim( request_data[ 'query' ] ),
                        "')" ]
      items = vim.eval( ''.join( omnifunc_call ) )

      if isinstance( items, dict ) and 'words' in items:
        items = items[ 'words' ]

      if not hasattr( items, '__iter__' ):
        raise TypeError( OMNIFUNC_NOT_LIST )

      # Vim allows each item of the list to be either a string or a dictionary
      # but ycmd only supports lists where items are all strings or all
      # dictionaries. Convert all strings into dictionaries.
      for index, item in enumerate( items ):
        if not isinstance( item, dict ):
          items[ index ] = { 'word': item }

      return items

    except ( TypeError, ValueError, vim.error ) as error:
      vimsupport.PostVimMessage(
        OMNIFUNC_RETURNED_BAD_VALUE + ' ' + str( error ) )
      return []

    finally:
      vimsupport.SetCurrentLineAndColumn( line, column )


  def FilterAndSortCandidatesInner( self, candidates, sort_property, query ):
    request_data = {
      'candidates': candidates,
      'sort_property': sort_property,
      'query': query
    }

    response = BaseRequest().PostDataToHandler( request_data,
                                                'filter_and_sort_candidates' )
    return response if response is not None else []
<EOF>
<BOF>
# Copyright (C) 2016  YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import MockVimModule
MockVimModule()

from hamcrest import assert_that, equal_to
from ycm.diagnostic_filter import DiagnosticFilter


def _assert_accept_equals( filter, text_or_obj, expected ):
  if not isinstance( text_or_obj, dict ):
    text_or_obj = { 'text': text_or_obj }

  assert_that( filter.IsAllowed( text_or_obj ), equal_to( expected ) )


def _assert_accepts( filter, text ):
  _assert_accept_equals( filter, text, True )


def _assert_rejects( filter, text ):
  _assert_accept_equals( filter, text, False )


def _JavaFilter( config ):
  return { 'filter_diagnostics' : { 'java': config } }


def _CreateFilterForTypes( opts, types ):
  return DiagnosticFilter.CreateFromOptions( opts ).SubsetForTypes( types )


def RegexFilter_test():
  opts = _JavaFilter( { 'regex' : 'taco' } )
  f = _CreateFilterForTypes( opts, [ 'java' ] )

  _assert_rejects( f, 'This is a Taco' )
  _assert_accepts( f, 'This is a Burrito' )


def RegexSingleList_test():
  opts = _JavaFilter( { 'regex' : [ 'taco' ] } )
  f = _CreateFilterForTypes( opts, [ 'java' ] )

  _assert_rejects( f, 'This is a Taco' )
  _assert_accepts( f, 'This is a Burrito' )


def RegexMultiList_test():
  opts = _JavaFilter( { 'regex' : [ 'taco', 'burrito' ] } )
  f = _CreateFilterForTypes( opts, [ 'java' ] )

  _assert_rejects( f, 'This is a Taco' )
  _assert_rejects( f, 'This is a Burrito' )


def RegexNotFiltered_test():
  opts = _JavaFilter( { 'regex' : 'taco' } )
  f = _CreateFilterForTypes( opts, [ 'cs' ] )

  _assert_accepts( f, 'This is a Taco' )
  _assert_accepts( f, 'This is a Burrito' )


def LevelWarnings_test():
  opts = _JavaFilter( { 'level' : 'warning' } )
  f = _CreateFilterForTypes( opts, [ 'java' ] )

  _assert_rejects( f, { 'text' : 'This is an unimportant taco',
                        'kind' : 'WARNING' } )
  _assert_accepts( f, { 'text' : 'This taco will be shown',
                        'kind' : 'ERROR' } )


def LevelErrors_test():
  opts = _JavaFilter( { 'level' : 'error' } )
  f = _CreateFilterForTypes( opts, [ 'java' ] )

  _assert_accepts( f, { 'text' : 'This is an IMPORTANT taco',
                        'kind' : 'WARNING' } )
  _assert_rejects( f, { 'text' : 'This taco will NOT be shown',
                        'kind' : 'ERROR' } )


def MultipleFilterTypesTypeTest_test():

  opts = _JavaFilter( { 'regex' : '.*taco.*',
                        'level' : 'warning' } )
  f = _CreateFilterForTypes( opts, [ 'java' ] )

  _assert_rejects( f, { 'text' : 'This is an unimportant taco',
                        'kind' : 'WARNING' } )
  _assert_rejects( f, { 'text' : 'This taco will NOT be shown',
                        'kind' : 'ERROR' } )
  _assert_accepts( f, { 'text' : 'This burrito WILL be shown',
                        'kind' : 'ERROR' } )


def MergeMultipleFiletypes_test():

  opts = { 'filter_diagnostics' : {
    'java' : { 'regex' : '.*taco.*' },
    'xml'  : { 'regex' : '.*burrito.*' } } }

  f = _CreateFilterForTypes( opts, [ 'java', 'xml' ] )

  _assert_rejects( f, 'This is a Taco' )
  _assert_rejects( f, 'This is a Burrito' )
  _assert_accepts( f, 'This is some Nachos' )


def CommaSeparatedFiletypes_test():

  opts = { 'filter_diagnostics' : {
    'java,c,cs' : { 'regex' : '.*taco.*' } } }

  f = _CreateFilterForTypes( opts, [ 'cs' ] )

  _assert_rejects( f, 'This is a Taco' )
  _assert_accepts( f, 'This is a Burrito' )
<EOF>
<BOF>
# encoding: utf-8
#
# Copyright (C) 2016-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from hamcrest import assert_that, contains, empty, has_entries

from ycm.tests.test_utils import ( MockVimBuffers, MockVimModule, ToBytesOnPY2,
                                   VimBuffer )
MockVimModule()

from ycm import vimsupport
from ycm.tests import YouCompleteMeInstance

FILETYPE = 'ycmtest'
TRIGGERS = {
  'ycmtest': [ '.' ]
}


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_List_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 5 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [
          { 'word': 'a' },
          { 'word': 'b' },
          { 'word': 'cdef' }
        ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_ListFilter_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.t' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 6 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': empty(),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 0,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_NoCache_List_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 5 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [
          { 'word': 'a' },
          { 'word': 'b' },
          { 'word': 'cdef' }
        ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 0,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_NoCache_ListFilter_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.t' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 6 ) ):
    ycm.SendCompletionRequest()
    # Actual result is that the results are not filtered, as we expect the
    # omnifunc or vim itself to do this filtering.
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [
          { 'word': 'a' },
          { 'word': 'b' },
          { 'word': 'cdef' }
        ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 0,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_NoCache_UseFindStart_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 0
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.t' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 6 ) ):
    ycm.SendCompletionRequest()
    # Actual result is that the results are not filtered, as we expect the
    # omnifunc or vim itself to do this filtering.
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [
          { 'word': 'a' },
          { 'word': 'b' },
          { 'word': 'cdef' }
        ] ),
        'completion_start_column': 1
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_UseFindStart_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 0
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.t' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 6 ) ):
    ycm.SendCompletionRequest()
    # There are no results because the query 'test.t' doesn't match any
    # candidate (and cache_omnifunc=1, so we FilterAndSortCandidates).
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': empty(),
        'completion_start_column': 1
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_Object_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return { 'words': [ 'a', 'b', 'CDtEF' ] }

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.t' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 6 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': [ { 'word': 'CDtEF' } ],
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_ObjectList_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [
      {
        'word': 'a',
        'abbr': 'ABBR',
        'menu': 'MENU',
        'info': 'INFO',
        'kind': 'K'
      },
      {
        'word': 'test',
        'abbr': 'ABBRTEST',
        'menu': 'MENUTEST',
        'info': 'INFOTEST',
        'kind': 'T'
      }
    ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.tt' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 7 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': contains( {
          'word': 'test',
          'abbr': 'ABBRTEST',
          'menu': 'MENUTEST',
          'info': 'INFOTEST',
          'kind': 'T'
        } ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 0,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_NoCache_ObjectList_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [
      {
        'word': 'a',
        'abbr': 'ABBR',
        'menu': 'MENU',
        'info': 'INFO',
        'kind': 'K'
      },
      {
        'word': 'test',
        'abbr': 'ABBRTEST',
        'menu': 'MENUTEST',
        'info': 'INFOTEST',
        'kind': 'T'
      }
    ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.tt' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 7 ) ):
    ycm.SendCompletionRequest()
    # We don't filter the result - we expect the omnifunc to do that
    # based on the query we supplied (Note: that means no fuzzy matching!).
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [ {
          'word': 'a',
          'abbr': 'ABBR',
          'menu': 'MENU',
          'info': 'INFO',
          'kind': 'K'
        }, {
          'word': 'test',
          'abbr': 'ABBRTEST',
          'menu': 'MENUTEST',
          'info': 'INFOTEST',
          'kind': 'T'
        } ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_ObjectListObject_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return { 'words': [
      {
        'word': 'a',
        'abbr': 'ABBR',
        'menu': 'MENU',
        'info': 'INFO',
        'kind': 'K'
      },
      {
        'word': 'test',
        'abbr': 'ABBRTEST',
        'menu': 'MENUTEST',
        'info': 'INFOTEST',
        'kind': 'T'
      }
    ] }

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.tt' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 7 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [ {
          'word': 'test',
          'abbr': 'ABBRTEST',
          'menu': 'MENUTEST',
          'info': 'INFOTEST',
          'kind': 'T'
        } ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 0,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_NoCache_ObjectListObject_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return { 'words': [
      {
        'word': 'a',
        'abbr': 'ABBR',
        'menu': 'MENU',
        'info': 'INFO',
        'kind': 'K'
      },
      {
        'word': 'test',
        'abbr': 'ABBRTEST',
        'menu': 'MENUTEST',
        'info': 'INFOTEST',
        'kind': 'T'
      }
    ] }

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.tt' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 7 ) ):
    ycm.SendCompletionRequest()
    # No FilterAndSortCandidates for cache_omnifunc=0 (we expect the omnifunc
    # to do the filtering?)
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [ {
          'word': 'a',
          'abbr': 'ABBR',
          'menu': 'MENU',
          'info': 'INFO',
          'kind': 'K'
        }, {
          'word': 'test',
          'abbr': 'ABBRTEST',
          'menu': 'MENUTEST',
          'info': 'INFOTEST',
          'kind': 'T'
        } ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_List_Unicode_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 12
    return [ '†est', 'å_unicode_identifier', 'πππππππ yummy πie' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ '†åsty_π.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 12 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': [
          { 'word': 'å_unicode_identifier' },
          { 'word': 'πππππππ yummy πie' },
          { 'word': '†est' }
        ],
        'completion_start_column': 13
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 0,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_NoCache_List_Unicode_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 12
    return [ '†est', 'å_unicode_identifier', 'πππππππ yummy πie' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ '†åsty_π.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 12 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [
          { 'word': '†est' },
          { 'word': 'å_unicode_identifier' },
          { 'word': 'πππππππ yummy πie' }
        ] ),
        'completion_start_column': 13
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_List_Filter_Unicode_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 12
    return [ '†est', 'å_unicode_identifier', 'πππππππ yummy πie' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ '†åsty_π.ππ' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 17 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': [ { 'word': 'πππππππ yummy πie' } ],
        'completion_start_column': 13
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 0,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_NoCache_List_Filter_Unicode_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 12
    return [ 'πππππππ yummy πie' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ '†åsty_π.ππ' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 17 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [ { 'word': 'πππππππ yummy πie' } ] ),
        'completion_start_column': 13
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_ObjectList_Unicode_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 12
    return [
      {
        'word': 'ålpha∫et',
        'abbr': 'å∫∫®',
        'menu': 'µ´~¨á',
        'info': '^~fo',
        'kind': '˚'
      },
      {
        'word': 'π†´ß†π',
        'abbr': 'ÅııÂÊ‰ÍÊ',
        'menu': '˜‰ˆËÊ‰ÍÊ',
        'info': 'ÈˆÏØÊ‰ÍÊ',
        'kind': 'Ê'
      }
    ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ '†åsty_π.ππ' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 17 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': [ {
          'word': 'π†´ß†π',
          'abbr': 'ÅııÂÊ‰ÍÊ',
          'menu': '˜‰ˆËÊ‰ÍÊ',
          'info': 'ÈˆÏØÊ‰ÍÊ',
          'kind': 'Ê'
        } ],
        'completion_start_column': 13
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_Cache_ObjectListObject_Unicode_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 12
    return {
      'words': [
        {
          'word': 'ålpha∫et',
          'abbr': 'å∫∫®',
          'menu': 'µ´~¨á',
          'info': '^~fo',
          'kind': '˚'
        },
        {
          'word': 'π†´ß†π',
          'abbr': 'ÅııÂÊ‰ÍÊ',
          'menu': '˜‰ˆËÊ‰ÍÊ',
          'info': 'ÈˆÏØÊ‰ÍÊ',
          'kind': 'Ê'
        },
        {
          'word': 'test',
          'abbr': 'ÅııÂÊ‰ÍÊ',
          'menu': '˜‰ˆËÊ‰ÍÊ',
          'info': 'ÈˆÏØÊ‰ÍÊ',
          'kind': 'Ê'
        }
      ]
    }

  current_buffer = VimBuffer( 'buffer',
                              contents = [ '†åsty_π.t' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 13 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': contains( {
          'word': 'test',
          'abbr': 'ÅııÂÊ‰ÍÊ',
          'menu': '˜‰ˆËÊ‰ÍÊ',
          'info': 'ÈˆÏØÊ‰ÍÊ',
          'kind': 'Ê'
        }, {
          'word': 'ålpha∫et',
          'abbr': 'å∫∫®',
          'menu': 'µ´~¨á',
          'info': '^~fo',
          'kind': '˚'
        } ),
        'completion_start_column': 13
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_RestoreCursorPositionAfterOmnifuncCall_test(
  ycm ):

  # This omnifunc moves the cursor to the test definition like
  # ccomplete#Complete would.
  def Omnifunc( findstart, base ):
    vimsupport.SetCurrentLineAndColumn( 0, 0 )
    if findstart:
      return 5
    return [ 'length' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'String test',
                                           '',
                                           'test.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 3, 5 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      vimsupport.CurrentLineAndColumn(),
      contains( 2, 5 )
    )
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [ { 'word': 'length' } ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_MoveCursorPositionAtStartColumn_test( ycm ):
  # This omnifunc relies on the cursor being moved at the start column when
  # called the second time like LanguageClient#complete from the
  # LanguageClient-neovim plugin.
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    if vimsupport.CurrentColumn() == 5:
      return [ 'length' ]
    return []

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'String test',
                                           '',
                                           'test.le' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 3, 7 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      vimsupport.CurrentLineAndColumn(),
      contains( 2, 7 )
    )
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [ { 'word': 'length' } ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1 } )
def StartColumnCompliance( ycm,
                           omnifunc_start_column,
                           ycm_completions,
                           ycm_start_column ):
  def Omnifunc( findstart, base ):
    if findstart:
      return omnifunc_start_column
    return [ 'foo' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'fo' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 2 ) ):
    ycm.SendCompletionRequest( force_semantic = True )
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( ycm_completions ),
        'completion_start_column': ycm_start_column
      } )
    )


def OmniCompleter_GetCompletions_StartColumnCompliance_test():
  yield StartColumnCompliance, -4, [ { 'word': 'foo' } ], 3
  yield StartColumnCompliance, -3, [],        1
  yield StartColumnCompliance, -2, [],        1
  yield StartColumnCompliance, -1, [ { 'word': 'foo' } ], 3
  yield StartColumnCompliance,  0, [ { 'word': 'foo' } ], 1
  yield StartColumnCompliance,  1, [ { 'word': 'foo' } ], 2
  yield StartColumnCompliance,  2, [ { 'word': 'foo' } ], 3
  yield StartColumnCompliance,  3, [ { 'word': 'foo' } ], 3


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 0,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_NoCache_NoSemanticTrigger_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 0
    return [ 'test' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'te' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 3 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': empty(),
        'completion_start_column': 1
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 0,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_NoCache_ForceSemantic_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 0
    return [ 'test' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'te' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 3 ) ):
    ycm.SendCompletionRequest( force_semantic = True )
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [ { 'word': 'test' } ] ),
        'completion_start_column': 1
      } )
    )


@YouCompleteMeInstance( { 'g:ycm_cache_omnifunc': 1,
                          'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_ConvertStringsToDictionaries_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [
      { 'word': 'a' },
      'b'
    ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 7 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [
          { 'word': 'a' },
          { 'word': 'b' }
        ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( {
  'g:ycm_cache_omnifunc': 0,
  'g:ycm_filetype_specific_completion_to_disable': { FILETYPE: 1 },
  'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_FiletypeDisabled_SemanticTrigger_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 6 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': empty(),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( {
  'g:ycm_cache_omnifunc': 0,
  'g:ycm_filetype_specific_completion_to_disable': { '*': 1 },
  'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_AllFiletypesDisabled_SemanticTrigger_test(
  ycm ):

  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 6 ) ):
    ycm.SendCompletionRequest()
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': empty(),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( {
  'g:ycm_cache_omnifunc': 0,
  'g:ycm_filetype_specific_completion_to_disable': { FILETYPE: 1 },
  'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_FiletypeDisabled_ForceSemantic_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 6 ) ):
    ycm.SendCompletionRequest( force_semantic = True )
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [
          { 'word': 'a' },
          { 'word': 'b' },
          { 'word': 'cdef' }
        ] ),
        'completion_start_column': 6
      } )
    )


@YouCompleteMeInstance( {
  'g:ycm_cache_omnifunc': 0,
  'g:ycm_filetype_specific_completion_to_disable': { '*': 1 },
  'g:ycm_semantic_triggers': TRIGGERS } )
def OmniCompleter_GetCompletions_AllFiletypesDisabled_ForceSemantic_test( ycm ):
  def Omnifunc( findstart, base ):
    if findstart:
      return 5
    return [ 'a', 'b', 'cdef' ]

  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'test.' ],
                              filetype = FILETYPE,
                              omnifunc = Omnifunc )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 6 ) ):
    ycm.SendCompletionRequest( force_semantic = True )
    assert_that(
      ycm.GetCompletionResponse(),
      has_entries( {
        'completions': ToBytesOnPY2( [
          { 'word': 'a' },
          { 'word': 'b' },
          { 'word': 'cdef' }
        ] ),
        'completion_start_column': 6
      } )
    )
<EOF>
<BOF>
# Copyright (C) 2016-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import MockVimModule
MockVimModule()

import contextlib
import functools
import os
import requests
import time
import warnings

from ycm.client.base_request import BaseRequest
from ycm.tests import test_utils
from ycm.youcompleteme import YouCompleteMe
from ycmd.utils import CloseStandardStreams, WaitUntilProcessIsTerminated

# The default options which are required for a working YouCompleteMe object.
DEFAULT_CLIENT_OPTIONS = {
  # YCM options
  'g:ycm_log_level': 'info',
  'g:ycm_keep_logfiles': 0,
  'g:ycm_extra_conf_vim_data': [],
  'g:ycm_server_python_interpreter': '',
  'g:ycm_show_diagnostics_ui': 1,
  'g:ycm_enable_diagnostic_signs': 1,
  'g:ycm_enable_diagnostic_highlighting': 0,
  'g:ycm_echo_current_diagnostic': 1,
  'g:ycm_filter_diagnostics': {},
  'g:ycm_always_populate_location_list': 0,
  'g:ycm_collect_identifiers_from_tags_files': 0,
  'g:ycm_seed_identifiers_with_syntax': 0,
  'g:ycm_goto_buffer_command': 'same-buffer',
  # ycmd options
  'g:ycm_auto_trigger': 1,
  'g:ycm_min_num_of_chars_for_completion': 2,
  'g:ycm_semantic_triggers': {},
  'g:ycm_filetype_specific_completion_to_disable': { 'gitcommit': 1 },
  'g:ycm_max_num_candidates': 50,
  'g:ycm_max_diagnostics_to_display': 30
}


def PathToTestFile( *args ):
  dir_of_current_script = os.path.dirname( os.path.abspath( __file__ ) )
  return os.path.join( dir_of_current_script, 'testdata', *args )


@contextlib.contextmanager
def UserOptions( options ):
  old_vim_options = test_utils.VIM_OPTIONS.copy()
  test_utils.VIM_OPTIONS.update( DEFAULT_CLIENT_OPTIONS )
  test_utils.VIM_OPTIONS.update( options )
  try:
    yield
  finally:
    test_utils.VIM_OPTIONS = old_vim_options


def _IsReady():
  return BaseRequest().GetDataFromHandler( 'ready' )


def WaitUntilReady( timeout = 5 ):
  expiration = time.time() + timeout
  while True:
    try:
      if time.time() > expiration:
        raise RuntimeError( 'Waited for the server to be ready '
                            'for {0} seconds, aborting.'.format( timeout ) )
      if _IsReady():
        return
    except requests.exceptions.ConnectionError:
      pass
    finally:
      time.sleep( 0.1 )


def StopServer( ycm ):
  try:
    ycm.OnVimLeave()
    WaitUntilProcessIsTerminated( ycm._server_popen )
    CloseStandardStreams( ycm._server_popen )
  except Exception:
    pass


def setUpPackage():
  # We treat warnings as errors in our tests because warnings raised inside Vim
  # will interrupt user workflow with a traceback and we don't want that.
  warnings.filterwarnings( 'error' )
  # We ignore warnings from nose as we are not interested in them.
  warnings.filterwarnings( 'ignore', module = 'nose' )


def tearDownPackage():
  warnings.resetwarnings()


def YouCompleteMeInstance( custom_options = {} ):
  """Defines a decorator function for tests that passes a unique YouCompleteMe
  instance as a parameter. This instance is initialized with the default options
  `DEFAULT_CLIENT_OPTIONS`. Use the optional parameter |custom_options| to give
  additional options and/or override the already existing ones.

  Do NOT attach it to test generators but directly to the yielded tests.

  Example usage:

    from ycm.tests import YouCompleteMeInstance

    @YouCompleteMeInstance( { 'log_level': 'debug',
                              'keep_logfiles': 1 } )
    def Debug_test( ycm ):
        ...
  """
  def Decorator( test ):
    @functools.wraps( test )
    def Wrapper( *args, **kwargs ):
      with UserOptions( custom_options ):
        ycm = YouCompleteMe()
        WaitUntilReady()
        ycm.CheckIfServerIsReady()
        try:
          test( ycm, *args, **kwargs )
        finally:
          StopServer( ycm )
    return Wrapper
  return Decorator
<EOF>
<BOF>
# Copyright (C) 2016-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import MockVimModule, MockVimBuffers, VimBuffer
MockVimModule()

from hamcrest import assert_that, contains, has_entries
from mock import patch

from ycm.tests import YouCompleteMeInstance


@YouCompleteMeInstance( { 'g:ycm_extra_conf_vim_data': [ 'tempname()' ] } )
def SendCommandRequest_ExtraConfVimData_Works_test( ycm ):
  current_buffer = VimBuffer( 'buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.youcompleteme.SendCommandRequest' ) as send_request:
      ycm.SendCommandRequest( [ 'GoTo' ], 'aboveleft', False, 1, 1 )
      assert_that(
        # Positional arguments passed to SendCommandRequest.
        send_request.call_args[ 0 ],
        contains(
          contains( 'GoTo' ),
          'aboveleft',
          'same-buffer',
          has_entries( {
            'options': has_entries( {
              'tab_size': 2,
              'insert_spaces': True,
            } ),
            'extra_conf_data': has_entries( {
              'tempname()': '_TEMP_FILE_'
            } ),
          } )
        )
      )


@YouCompleteMeInstance( { 'g:ycm_extra_conf_vim_data': [ 'undefined_value' ] } )
def SendCommandRequest_ExtraConfData_UndefinedValue_test( ycm ):
  current_buffer = VimBuffer( 'buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.youcompleteme.SendCommandRequest' ) as send_request:
      ycm.SendCommandRequest( [ 'GoTo' ], 'belowright', False, 1, 1 )
      assert_that(
        # Positional arguments passed to SendCommandRequest.
        send_request.call_args[ 0 ],
        contains(
          contains( 'GoTo' ),
          'belowright',
          'same-buffer',
          has_entries( {
            'options': has_entries( {
              'tab_size': 2,
              'insert_spaces': True,
            } )
          } )
        )
      )


@YouCompleteMeInstance()
def SendCommandRequest_BuildRange_NoVisualMarks_test( ycm, *args ):
  current_buffer = VimBuffer( 'buffer', contents = [ 'first line',
                                                     'second line' ] )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.youcompleteme.SendCommandRequest' ) as send_request:
      ycm.SendCommandRequest( [ 'GoTo' ], '', True, 1, 2 )
      send_request.assert_called_once_with(
        [ 'GoTo' ],
        '',
        'same-buffer',
        {
          'options': {
            'tab_size': 2,
            'insert_spaces': True
          },
          'range': {
            'start': {
              'line_num': 1,
              'column_num': 1
            },
            'end': {
              'line_num': 2,
              'column_num': 12
            }
          }
        }
      )


@YouCompleteMeInstance()
def SendCommandRequest_BuildRange_VisualMarks_test( ycm, *args ):
  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'first line',
                                           'second line' ],
                              visual_start = [ 1, 4 ],
                              visual_end = [ 2, 8 ] )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.youcompleteme.SendCommandRequest' ) as send_request:
      ycm.SendCommandRequest( [ 'GoTo' ], 'tab', True, 1, 2 )
      send_request.assert_called_once_with(
        [ 'GoTo' ],
        'tab',
        'same-buffer',
        {
          'options': {
            'tab_size': 2,
            'insert_spaces': True
          },
          'range': {
            'start': {
              'line_num': 1,
              'column_num': 5
            },
            'end': {
              'line_num': 2,
              'column_num': 9
            }
          }
        }
      )


@YouCompleteMeInstance()
def SendCommandRequest_IgnoreFileTypeOption_test( ycm, *args ):
  current_buffer = VimBuffer( 'buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    expected_args = (
      [ 'GoTo' ],
      '',
      'same-buffer',
      {
        'options': {
          'tab_size': 2,
          'insert_spaces': True
        },
      }
    )

    with patch( 'ycm.youcompleteme.SendCommandRequest' ) as send_request:
      ycm.SendCommandRequest( [ 'ft=ycm:ident', 'GoTo' ], '', False, 1, 1 )
      send_request.assert_called_once_with( *expected_args )

    with patch( 'ycm.youcompleteme.SendCommandRequest' ) as send_request:
      ycm.SendCommandRequest( [ 'GoTo', 'ft=python' ], '', False, 1, 1 )
      send_request.assert_called_once_with( *expected_args )
<EOF>
<BOF>
# Copyright (C) 2013 Google Inc.
#               2016 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import MockVimModule
MockVimModule()

import os
from hamcrest import assert_that, contains_inanyorder, has_item, has_items
from ycm import syntax_parse
from ycmd.utils import ReadFile


def ContentsOfTestFile( test_file ):
  dir_of_script = os.path.dirname( os.path.abspath( __file__ ) )
  full_path_to_test_file = os.path.join( dir_of_script, 'testdata', test_file )
  return ReadFile( full_path_to_test_file )


def KeywordsFromSyntaxListOutput_PythonSyntax_test():
  expected_keywords = (
    'bytearray', 'IndexError', 'all', 'help', 'vars', 'SyntaxError', 'global',
    'elif', 'unicode', 'sorted', 'memoryview', 'isinstance', 'except',
    'nonlocal', 'NameError', 'finally', 'BytesWarning', 'dict', 'IOError',
    'pass', 'oct', 'bin', 'SystemExit', 'return', 'StandardError', 'format',
    'TabError', 'break', 'next', 'not', 'UnicodeDecodeError', 'False',
    'RuntimeWarning', 'list', 'iter', 'try', 'reload', 'Warning', 'round',
    'dir', 'cmp', 'set', 'bytes', 'UnicodeTranslateError', 'intern',
    'issubclass', 'yield', 'Ellipsis', 'hash', 'locals', 'BufferError',
    'slice', 'for', 'FloatingPointError', 'sum', 'VMSError', 'getattr', 'abs',
    'print', 'import', 'True', 'FutureWarning', 'ImportWarning', 'None',
    'EOFError', 'len', 'frozenset', 'ord', 'super', 'raise', 'TypeError',
    'KeyboardInterrupt', 'UserWarning', 'filter', 'range', 'staticmethod',
    'SystemError', 'or', 'BaseException', 'pow', 'RuntimeError', 'float',
    'MemoryError', 'StopIteration', 'globals', 'divmod', 'enumerate', 'apply',
    'LookupError', 'open', 'basestring', 'from', 'UnicodeError', 'zip', 'hex',
    'long', 'IndentationError', 'int', 'chr', '__import__', 'type',
    'Exception', 'continue', 'tuple', 'reduce', 'reversed', 'else', 'assert',
    'UnicodeEncodeError', 'input', 'with', 'hasattr', 'delattr', 'setattr',
    'raw_input', 'PendingDeprecationWarning', 'compile', 'ArithmeticError',
    'while', 'del', 'str', 'property', 'def', 'and', 'GeneratorExit',
    'ImportError', 'xrange', 'is', 'EnvironmentError', 'KeyError', 'coerce',
    'SyntaxWarning', 'file', 'in', 'unichr', 'ascii', 'any', 'as', 'if',
    'OSError', 'DeprecationWarning', 'min', 'UnicodeWarning', 'execfile', 'id',
    'complex', 'bool', 'ValueError', 'NotImplemented', 'map', 'exec', 'buffer',
    'max', 'class', 'object', 'repr', 'callable', 'ZeroDivisionError', 'eval',
    '__debug__', 'ReferenceError', 'AssertionError', 'classmethod',
    'UnboundLocalError', 'NotImplementedError', 'lambda', 'AttributeError',
    'OverflowError', 'WindowsError' )

  assert_that( syntax_parse._KeywordsFromSyntaxListOutput(
                   ContentsOfTestFile( 'python_syntax' ) ),
               contains_inanyorder( *expected_keywords ) )


def KeywordsFromSyntaxListOutput_CppSyntax_test():
  expected_keywords = (
    'int_fast32_t', 'FILE', 'size_t', 'bitor', 'typedef', 'const', 'struct',
    'uint8_t', 'fpos_t', 'thread_local', 'unsigned', 'uint_least16_t', 'do',
    'intptr_t', 'uint_least64_t', 'return', 'auto', 'void', '_Complex',
    'break', '_Alignof', 'not', 'using', '_Static_assert', '_Thread_local',
    'public', 'uint_fast16_t', 'this', 'continue', 'char32_t', 'int16_t',
    'intmax_t', 'static', 'clock_t', 'sizeof', 'int_fast64_t', 'mbstate_t',
    'try', 'xor', 'uint_fast32_t', 'int_least8_t', 'div_t', 'volatile',
    'template', 'char16_t', 'new', 'ldiv_t', 'int_least16_t', 'va_list',
    'uint_least8_t', 'goto', 'noreturn', 'enum', 'static_assert', 'bitand',
    'compl', 'imaginary', 'jmp_buf', 'throw', 'asm', 'ptrdiff_t', 'uint16_t',
    'or', 'uint_fast8_t', '_Bool', 'int32_t', 'float', 'private', 'restrict',
    'wint_t', 'operator', 'not_eq', '_Imaginary', 'alignas', 'union', 'long',
    'uint_least32_t', 'int_least64_t', 'friend', 'uintptr_t', 'int8_t', 'else',
    'export', 'int_fast8_t', 'catch', 'true', 'case', 'default', 'double',
    '_Noreturn', 'signed', 'typename', 'while', 'protected', 'wchar_t',
    'wctrans_t', 'uint64_t', 'delete', 'and', 'register', 'false', 'int',
    'uintmax_t', 'off_t', 'char', 'int64_t', 'int_fast16_t', 'DIR', '_Atomic',
    'time_t', 'xor_eq', 'namespace', 'virtual', 'complex', 'bool', 'mutable',
    'if', 'int_least32_t', 'sig_atomic_t', 'and_eq', 'ssize_t', 'alignof',
    '_Alignas', '_Generic', 'extern', 'class', 'typeid', 'short', 'for',
    'uint_fast64_t', 'wctype_t', 'explicit', 'or_eq', 'switch', 'uint32_t',
    'inline' )

  assert_that( syntax_parse._KeywordsFromSyntaxListOutput(
                   ContentsOfTestFile( 'cpp_syntax' ) ),
               contains_inanyorder( *expected_keywords ) )


def KeywordsFromSyntaxListOutput_JavaSyntax_test():
  expected_keywords = (
    'code', 'text', 'cols', 'datetime', 'disabled', 'shape', 'codetype', 'alt',
    'compact', 'style', 'valuetype', 'short', 'finally', 'continue', 'extends',
    'valign', 'bordercolor', 'do', 'return', 'rel', 'rules', 'void',
    'nohref', 'abbr', 'background', 'scrolling', 'instanceof', 'name',
    'summary', 'try', 'default', 'noshade', 'coords', 'dir', 'frame', 'usemap',
    'ismap', 'static', 'hspace', 'vlink', 'for', 'selected', 'rev', 'vspace',
    'content', 'method', 'version', 'volatile', 'above', 'new', 'charoff',
    'public', 'alink', 'enum', 'codebase', 'if', 'noresize', 'interface',
    'checked', 'byte', 'super', 'throw', 'src', 'language', 'package',
    'standby', 'script', 'longdesc', 'maxlength', 'cellpadding', 'throws',
    'tabindex', 'color', 'colspan', 'accesskey', 'float', 'while', 'private',
    'height', 'boolean', 'wrap', 'prompt', 'nowrap', 'size', 'rows', 'span',
    'clip', 'bgcolor', 'top', 'long', 'start', 'scope', 'scheme', 'type',
    'final', 'lang', 'visibility', 'else', 'assert', 'transient', 'link',
    'catch', 'true', 'serializable', 'target', 'lowsrc', 'this', 'double',
    'align', 'value', 'cite', 'headers', 'below', 'protected', 'declare',
    'classid', 'defer', 'false', 'synchronized', 'int', 'abstract', 'accept',
    'hreflang', 'char', 'border', 'id', 'native', 'rowspan', 'charset',
    'archive', 'strictfp', 'readonly', 'axis', 'cellspacing', 'profile',
    'multiple', 'object', 'action', 'pagex', 'pagey', 'marginheight', 'data',
    'class', 'frameborder', 'enctype', 'implements', 'break', 'gutter', 'url',
    'clear', 'face', 'switch', 'marginwidth', 'width', 'left' )

  assert_that( syntax_parse._KeywordsFromSyntaxListOutput(
                   ContentsOfTestFile( 'java_syntax' ) ),
               contains_inanyorder( *expected_keywords ) )


def KeywordsFromSyntaxListOutput_PhpSyntax_ContainsFunctions_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput(
                   ContentsOfTestFile( 'php_syntax' ) ),
               has_items( 'array_change_key_case' ) )


def KeywordsFromSyntaxListOutput_PhpSyntax_ContainsPreProc_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput(
                   ContentsOfTestFile( 'php_syntax' ) ),
               has_items( 'skip', 'function' ) )


def KeywordsFromSyntaxListOutput_Basic_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput( """
foogroup xxx foo bar
             zoo goo
             links to Statement""" ),
              contains_inanyorder( 'foo', 'bar', 'zoo', 'goo' ) )


def KeywordsFromSyntaxListOutput_Function_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput( """
foogroup xxx foo bar
             zoo goo
             links to Function""" ),
               contains_inanyorder( 'foo', 'bar', 'zoo', 'goo' ) )


def KeywordsFromSyntaxListOutput_ContainedArgAllowed_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput( """
phpFunctions   xxx contained gzclose yaz_syntax html_entity_decode fbsql_read_blob png2wbmp mssql_init cpdf_set_title gztell fbsql_insert_id empty cpdf_restore mysql_field_type closelog swftext ldap_search curl_errno gmp_div_r mssql_data_seek getmyinode printer_draw_pie mcve_initconn ncurses_getmaxyx defined
                   contained replace_child has_attributes specified insertdocument assign node_name hwstat addshape get_attribute_node html_dump_mem userlist
                   links to Function""" ), # noqa
              has_items( 'gzclose', 'userlist', 'ldap_search' ) )


def KeywordsFromSyntaxListOutput_JunkIgnored_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput( """
--- Syntax items ---
foogroup xxx foo bar
             zoo goo
             links to Statement
Spell        cluster=NONE
NoSpell      cluster=NONE""" ),
               contains_inanyorder( 'foo', 'bar', 'zoo', 'goo' ) )


def KeywordsFromSyntaxListOutput_MultipleStatementGroups_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput( """
foogroup xxx foo bar
             links to Statement
bargroup xxx zoo goo
             links to Statement""" ),
               contains_inanyorder( 'foo', 'bar', 'zoo', 'goo' ) )


def KeywordsFromSyntaxListOutput_StatementAndTypeGroups_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput( """
foogroup xxx foo bar
             links to Statement
bargroup xxx zoo goo
             links to Type""" ),
               contains_inanyorder( 'foo', 'bar', 'zoo', 'goo' ) )


def KeywordsFromSyntaxListOutput_StatementHierarchy_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput( """
baa xxx foo bar
        links to Foo
Foo xxx zoo goo
        links to Bar
Bar xxx qux moo
        links to Statement""" ),
               contains_inanyorder( 'foo', 'bar', 'zoo', 'goo', 'qux', 'moo' ) )


def KeywordsFromSyntaxListOutput_TypeHierarchy_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput( """
baa xxx foo bar
        links to Foo
Foo xxx zoo goo
        links to Bar
Bar xxx qux moo
        links to Type""" ),
              contains_inanyorder( 'foo', 'bar', 'zoo', 'goo', 'qux', 'moo' ) )


def KeywordsFromSyntaxListOutput_StatementAndTypeHierarchy_test():
  assert_that( syntax_parse._KeywordsFromSyntaxListOutput( """
tBaa xxx foo bar
         links to tFoo
tFoo xxx zoo goo
         links to tBar
tBar xxx qux moo
         links to Type
sBaa xxx na bar
         links to sFoo
sFoo xxx zoo nb
         links to sBar
sBar xxx qux nc
         links to Statement""" ),
              contains_inanyorder( 'foo', 'bar', 'zoo', 'goo', 'qux', 'moo',
                                   'na', 'nb', 'nc' ) )


def SyntaxGroupsFromOutput_Basic_test():
  assert_that( syntax_parse._SyntaxGroupsFromOutput( """
foogroup xxx foo bar
             zoo goo
             links to Statement""" ),
               has_item( 'foogroup' ) )


def ExtractKeywordsFromGroup_Basic_test():
  assert_that( syntax_parse._ExtractKeywordsFromGroup(
                 syntax_parse.SyntaxGroup( '', [
                   'foo bar',
                   'zoo goo',
                 ] ) ),
               contains_inanyorder( 'foo', 'bar', 'zoo', 'goo' ) )


def ExtractKeywordsFromGroup_Commas_test():
  assert_that( syntax_parse._ExtractKeywordsFromGroup(
                 syntax_parse.SyntaxGroup( '', [
                   'foo, bar,',
                   'zoo goo',
                 ] ) ),
               contains_inanyorder( 'foo', 'bar', 'zoo', 'goo' ) )


def ExtractKeywordsFromGroup_WithLinksTo_test():
  assert_that( syntax_parse._ExtractKeywordsFromGroup(
                 syntax_parse.SyntaxGroup( '', [
                   'foo bar',
                   'zoo goo',
                   'links to Statement'
                 ] ) ),
               contains_inanyorder( 'foo', 'bar', 'zoo', 'goo' ) )


def ExtractKeywordsFromGroup_KeywordStarts_test():
  assert_that( syntax_parse._ExtractKeywordsFromGroup(
                 syntax_parse.SyntaxGroup( '', [
                   'foo bar',
                   'contained boo baa',
                   'zoo goo',
                 ] ) ),
               contains_inanyorder( 'foo', 'bar', 'boo', 'baa', 'zoo', 'goo' ) )


def ExtractKeywordsFromGroup_KeywordMiddle_test():
  assert_that( syntax_parse._ExtractKeywordsFromGroup(
                 syntax_parse.SyntaxGroup( '', [
                   'foo contained bar',
                   'zoo goo'
                 ] ) ),
               contains_inanyorder( 'foo', 'contained', 'bar', 'zoo', 'goo' ) )


def ExtractKeywordsFromGroup_KeywordAssign_test():
  assert_that( syntax_parse._ExtractKeywordsFromGroup(
                 syntax_parse.SyntaxGroup( '', [
                   'nextgroup=zoo skipwhite foo bar',
                   'zoo goo',
                 ] ) ),
               contains_inanyorder( 'foo', 'bar', 'zoo', 'goo' ) )


def ExtractKeywordsFromGroup_KeywordAssignAndMiddle_test():
  assert_that( syntax_parse._ExtractKeywordsFromGroup(
                 syntax_parse.SyntaxGroup( '', [
                   'nextgroup=zoo foo skipnl bar',
                   'zoo goo',
                 ] ) ),
               contains_inanyorder( 'foo', 'skipnl', 'bar', 'zoo', 'goo' ) )


def ExtractKeywordsFromGroup_KeywordWithoutNextgroup_test():
  assert_that( syntax_parse._ExtractKeywordsFromGroup(
                 syntax_parse.SyntaxGroup( '', [
                   'skipempty foo bar',
                   'zoo goo',
                 ] ) ),
               contains_inanyorder( 'skipempty', 'foo', 'bar', 'zoo', 'goo' ) )


def ExtractKeywordsFromGroup_ContainedSyntaxArgAllowed_test():
  assert_that( syntax_parse._ExtractKeywordsFromGroup(
                 syntax_parse.SyntaxGroup( '', [
                   'contained foo zoq',
                   'contained bar goo',
                   'far'
                 ] ) ),
               contains_inanyorder( 'foo', 'zoq', 'bar', 'goo', 'far' ) )
<EOF>
<BOF>
# coding: utf-8
#
# Copyright (C) 2016 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import ( CurrentWorkingDirectory, ExtendedMock,
                                   MockVimModule, MockVimBuffers, VimBuffer )
MockVimModule()

import contextlib
from hamcrest import assert_that, contains, empty, has_entries
from mock import call, MagicMock, patch
from nose.tools import ok_

from ycm.tests import PathToTestFile, YouCompleteMeInstance
from ycmd.responses import ServerError


@contextlib.contextmanager
def MockCompletionRequest( response_method ):
  """Mock out the CompletionRequest, replacing the response handler
  JsonFromFuture with the |response_method| parameter."""

  # We don't want the requests to actually be sent to the server, just have it
  # return success.
  with patch( 'ycm.client.completer_available_request.'
              'CompleterAvailableRequest.PostDataToHandler',
              return_value = True ):
    with patch( 'ycm.client.completion_request.CompletionRequest.'
                'PostDataToHandlerAsync',
                return_value = MagicMock( return_value=True ) ):

      # We set up a fake response.
      with patch( 'ycm.client.base_request._JsonFromFuture',
                  side_effect = response_method ):
        yield


@YouCompleteMeInstance()
def SendCompletionRequest_UnicodeWorkingDirectory_test( ycm ):
  unicode_dir = PathToTestFile( 'uni¢𐍈d€' )
  current_buffer = VimBuffer( PathToTestFile( 'uni¢𐍈d€', 'current_buffer' ) )

  def ServerResponse( *args ):
    return { 'completions': [], 'completion_start_column': 1 }

  with CurrentWorkingDirectory( unicode_dir ):
    with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
      with MockCompletionRequest( ServerResponse ):
        ycm.SendCompletionRequest()
        ok_( ycm.CompletionRequestReady() )
        assert_that(
          ycm.GetCompletionResponse(),
          has_entries( {
            'completions': empty(),
            'completion_start_column': 1
          } )
        )


@YouCompleteMeInstance()
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def SendCompletionRequest_ResponseContainingError_test( ycm, post_vim_message ):
  current_buffer = VimBuffer( 'buffer' )

  def ServerResponse( *args ):
    return {
      'completions': [ {
        'insertion_text': 'insertion_text',
        'menu_text': 'menu_text',
        'extra_menu_info': 'extra_menu_info',
        'detailed_info': 'detailed_info',
        'kind': 'kind',
        'extra_data': {
           'doc_string': 'doc_string'
        }
      } ],
      'completion_start_column': 3,
      'errors': [ {
        'exception': {
           'TYPE': 'Exception'
        },
        'message': 'message',
        'traceback': 'traceback'
      } ]
    }

  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with MockCompletionRequest( ServerResponse ):
      ycm.SendCompletionRequest()
      ok_( ycm.CompletionRequestReady() )
      response = ycm.GetCompletionResponse()
      post_vim_message.assert_has_exact_calls( [
        call( 'Exception: message', truncate = True )
      ] )
      assert_that(
        response,
        has_entries( {
          'completions': contains( has_entries( {
            'word': 'insertion_text',
            'abbr': 'menu_text',
            'menu': 'extra_menu_info',
            'info': 'detailed_info\ndoc_string',
            'kind': 'k',
            'dup': 1,
            'empty': 1
          } ) ),
          'completion_start_column': 3
        } )
      )


@YouCompleteMeInstance()
@patch( 'ycm.client.base_request._logger', autospec = True )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def SendCompletionRequest_ErrorFromServer_test( ycm,
                                                post_vim_message,
                                                logger ):
  current_buffer = VimBuffer( 'buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with MockCompletionRequest( ServerError( 'Server error' ) ):
      ycm.SendCompletionRequest()
      ok_( ycm.CompletionRequestReady() )
      response = ycm.GetCompletionResponse()
      logger.exception.assert_called_with( 'Error while handling server '
                                           'response' )
      post_vim_message.assert_has_exact_calls( [
        call( 'Server error', truncate = True )
      ] )
      assert_that(
        response,
        has_entries( {
          'completions': empty(),
          'completion_start_column': -1
        } )
      )
<EOF>
<BOF>
# Copyright (C) 2017 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

import mock
import requests


class FakeResponse( object ):
  """A fake version of a requests response object, just about suitable for
  mocking a server response. Not usually used directly. See
  MockServerResponse* methods"""
  def __init__( self, response, exception ):
    self._json = response
    self._exception = exception
    self.status_code = requests.codes.ok
    self.text = not exception

  def json( self ):
    if self._exception:
      return None
    return self._json


  def raise_for_status( self ):
    if self._exception:
      raise self._exception


class FakeFuture( object ):
  """A fake version of a future response object, just about suitable for
  mocking a server response as generated by PostDataToHandlerAsync.
  Not usually used directly. See MockAsyncServerResponse* methods"""
  def __init__( self, done, response = None, exception = None ):
    self._done = done

    if not done:
      self._result = None
    else:
      self._result = FakeResponse( response, exception )


  def done( self ):
    return self._done


  def result( self ):
    return self._result


def MockAsyncServerResponseDone( response ):
  """Return a fake future object that is complete with the supplied response
  message. Suitable for mocking a response future within a client request. For
  example:

    server_message = {
      'message': 'this message came from the server'
    }

    with patch.object( ycm._message_poll_request,
                       '_response_future',
                       new = MockAsyncServerResponseDone( [] ) ) as mock_future:
      ycm.OnPeriodicTick() # Uses ycm._message_poll_request ...
  """
  return mock.MagicMock( wraps = FakeFuture( True, response ) )


def MockAsyncServerResponseInProgress():
  """Return a fake future object that is incomplete. Suitable for mocking a
  response future within a client request. For example:

    with patch.object( ycm._message_poll_request,
                       '_response_future',
                       new = MockAsyncServerResponseInProgress() ):
      ycm.OnPeriodicTick() # Uses ycm._message_poll_request ...
  """
  return mock.MagicMock( wraps = FakeFuture( False ) )


def MockAsyncServerResponseException( exception ):
  """Return a fake future object that is complete, but raises an exception.
  Suitable for mocking a response future within a client request. For example:

    exception = RuntimeError( 'Check client handles exception' )
    with patch.object( ycm._message_poll_request,
                       '_response_future',
                       new = MockAsyncServerResponseException( exception ) ):
      ycm.OnPeriodicTick() # Uses ycm._message_poll_request ...
  """
  return mock.MagicMock( wraps = FakeFuture( True, None, exception ) )


# TODO: In future, implement MockServerResponse and MockServerResponseException
# for synchronous cases when such test cases are needed.
<EOF>
<BOF>
# Copyright (C) 2016-2017 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import MockVimModule
MockVimModule()

from nose.tools import ok_
from ycm.paths import _EndsWithPython


def EndsWithPython_Good( path ):
  ok_( _EndsWithPython( path ),
       'Path {0} does not end with a Python name.'.format( path ) )


def EndsWithPython_Bad( path ):
  ok_( not _EndsWithPython( path ),
       'Path {0} does end with a Python name.'.format( path ) )


def EndsWithPython_Python2Paths_test():
  python_paths = [
    'python',
    'python2',
    '/usr/bin/python2.7',
    '/home/user/.pyenv/shims/python2.7',
    r'C:\Python27\python.exe',
    '/Contents/MacOS/Python'
  ]

  for path in python_paths:
    yield EndsWithPython_Good, path


def EndsWithPython_Python3Paths_test():
  python_paths = [
    'python3',
    '/usr/bin/python3.4',
    '/home/user/.pyenv/shims/python3.4',
    r'C:\Python34\python.exe'
  ]

  for path in python_paths:
    yield EndsWithPython_Good, path


def EndsWithPython_BadPaths_test():
  not_python_paths = [
    None,
    '',
    '/opt/local/bin/vim',
    r'C:\Program Files\Vim\vim74\gvim.exe',
    '/usr/bin/python2.5',
    '/home/user/.pyenv/shims/python3.2',
  ]

  for path in not_python_paths:
    yield EndsWithPython_Bad, path
<EOF>
<BOF>
# encoding: utf-8
#
# Copyright (C) 2015-2016 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import MockVimModule
MockVimModule()

import contextlib
from mock import MagicMock, DEFAULT, patch
from nose.tools import eq_, ok_

from ycm import vimsupport
from ycmd.utils import ToBytes
from ycm.client.completion_request import ( CompletionRequest,
                                            _FilterToMatchingCompletions,
                                            _GetRequiredNamespaceImport )


def CompleteItemIs( word, abbr = None, menu = None,
                    info = None, kind = None, **kwargs ):
  item = {
    'word': ToBytes( word ),
    'abbr': ToBytes( abbr ),
    'menu': ToBytes( menu ),
    'info': ToBytes( info ),
    'kind': ToBytes( kind ),
  }
  item.update( **kwargs )
  return item


def GetVariableValue_CompleteItemIs( word, abbr = None, menu = None,
                                     info = None, kind = None, **kwargs ):
  def Result( variable ):
    if variable == 'v:completed_item':
      return CompleteItemIs( word, abbr, menu, info, kind, **kwargs )
    return DEFAULT
  return MagicMock( side_effect = Result )


def BuildCompletion( insertion_text = 'Test',
                     menu_text = None,
                     extra_menu_info = None,
                     detailed_info = None,
                     kind = None,
                     extra_data = None ):
  completion = {
    'insertion_text': insertion_text
  }

  if extra_menu_info:
    completion[ 'extra_menu_info' ] = extra_menu_info
  if menu_text:
    completion[ 'menu_text' ] = menu_text
  if detailed_info:
    completion[ 'detailed_info' ] = detailed_info
  if kind:
    completion[ 'kind' ] = kind
  if extra_data:
    completion[ 'extra_data' ] = extra_data
  return completion


def BuildCompletionNamespace( namespace = None,
                              insertion_text = 'Test',
                              menu_text = None,
                              extra_menu_info = None,
                              detailed_info = None,
                              kind = None ):
  return BuildCompletion( insertion_text = insertion_text,
                          menu_text = menu_text,
                          extra_menu_info = extra_menu_info,
                          detailed_info = detailed_info,
                          kind = kind,
                          extra_data = {
                            'required_namespace_import': namespace
                          } )


def BuildCompletionFixIt( fixits,
                          insertion_text = 'Test',
                          menu_text = None,
                          extra_menu_info = None,
                          detailed_info = None,
                          kind = None ):
  return BuildCompletion( insertion_text = insertion_text,
                          menu_text = menu_text,
                          extra_menu_info = extra_menu_info,
                          detailed_info = detailed_info,
                          kind = kind,
                          extra_data = {
                            'fixits': fixits,
                          } )


@contextlib.contextmanager
def _SetupForCsharpCompletionDone( completions ):
  with patch( 'ycm.vimsupport.InsertNamespace' ):
    with _SetUpCompleteDone( completions ) as request:
      yield request


@contextlib.contextmanager
def _SetUpCompleteDone( completions ):
  with patch( 'ycm.vimsupport.TextBeforeCursor', return_value = '   Test' ):
    request = CompletionRequest( None )
    request.Done = MagicMock( return_value = True )
    request.RawResponse = MagicMock( return_value = {
      'completions': completions
    } )
    yield request


@patch( 'ycm.vimsupport.CurrentFiletypes', return_value = [ 'ycmtest' ] )
def OnCompleteDone_DefaultFixIt_test( *args ):
  request = CompletionRequest( None )
  request.Done = MagicMock( return_value = True )
  request._OnCompleteDone_Csharp = MagicMock()
  request._OnCompleteDone_FixIt = MagicMock()
  request.OnCompleteDone()
  request._OnCompleteDone_Csharp.assert_not_called()
  request._OnCompleteDone_FixIt.assert_called_once_with()


@patch( 'ycm.vimsupport.CurrentFiletypes', return_value = [ 'cs' ] )
def OnCompleteDone_CsharpFixIt_test( *args ):
  request = CompletionRequest( None )
  request.Done = MagicMock( return_value = True )
  request._OnCompleteDone_Csharp = MagicMock()
  request._OnCompleteDone_FixIt = MagicMock()
  request.OnCompleteDone()
  request._OnCompleteDone_Csharp.assert_called_once_with()
  request._OnCompleteDone_FixIt.assert_not_called()


@patch( 'ycm.vimsupport.CurrentFiletypes', return_value = [ 'ycmtest' ] )
def OnCompleteDone_NoFixItIfNotDone_test( *args ):
  request = CompletionRequest( None )
  request.Done = MagicMock( return_value = False )
  request._OnCompleteDone_Csharp = MagicMock()
  request._OnCompleteDone_FixIt = MagicMock()
  request.OnCompleteDone()
  request._OnCompleteDone_Csharp.assert_not_called()
  request._OnCompleteDone_FixIt.assert_not_called()


def FilterToCompletedCompletions_MatchIsReturned_test():
  completions = [ BuildCompletion( insertion_text = 'Test' ) ]
  result = _FilterToMatchingCompletions( CompleteItemIs( 'Test' ), completions )
  eq_( list( result ), completions )


def FilterToCompletedCompletions_ShortTextDoesntRaise_test():
  completions = [ BuildCompletion( insertion_text = 'AAA' ) ]
  result = _FilterToMatchingCompletions( CompleteItemIs( 'A' ), completions )
  eq_( list( result ), [] )


def FilterToCompletedCompletions_ExactMatchIsReturned_test():
  completions = [ BuildCompletion( insertion_text = 'Test' ) ]
  result = _FilterToMatchingCompletions( CompleteItemIs( 'Test' ), completions )
  eq_( list( result ), completions )


def FilterToCompletedCompletions_NonMatchIsntReturned_test():
  completions = [ BuildCompletion( insertion_text = 'A' ) ]
  result = _FilterToMatchingCompletions( CompleteItemIs( '   Quote' ),
                                         completions )
  eq_( list( result ), [] )


def FilterToCompletedCompletions_Unicode_test():
  completions = [ BuildCompletion( insertion_text = '†es†' ) ]
  result = _FilterToMatchingCompletions( CompleteItemIs( '†es†' ),
                                         completions )
  eq_( list( result ), completions )


def GetRequiredNamespaceImport_ReturnNoneForNoExtraData_test():
  eq_( _GetRequiredNamespaceImport( {} ), None )


def GetRequiredNamespaceImport_ReturnNamespaceFromExtraData_test():
  namespace = 'A_NAMESPACE'
  eq_( _GetRequiredNamespaceImport( BuildCompletionNamespace( namespace ) ),
       namespace )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Te' ) )
def GetCompletionsUserMayHaveCompleted_ReturnEmptyIfPendingMatches_test(
    *args ):
  completions = [ BuildCompletionNamespace( None ) ]
  with _SetupForCsharpCompletionDone( completions ) as request:
    eq_( request._GetCompletionsUserMayHaveCompleted(), [] )


def GetCompletionsUserMayHaveCompleted_ReturnMatchIfExactMatches_test( *args ):
  info = [ 'NS', 'Test', 'Abbr', 'Menu', 'Info', 'Kind' ]
  completions = [ BuildCompletionNamespace( *info ) ]
  with _SetupForCsharpCompletionDone( completions ) as request:
    with patch( 'ycm.vimsupport.GetVariableValue',
                GetVariableValue_CompleteItemIs( *info[ 1: ] ) ):
      eq_( request._GetCompletionsUserMayHaveCompleted(), completions )


def GetCompletionsUserMayHaveCompleted_ReturnMatchIfExactMatchesEvenIfPartial_test(): # noqa
  info = [ 'NS', 'Test', 'Abbr', 'Menu', 'Info', 'Kind' ]
  completions = [ BuildCompletionNamespace( *info ),
                  BuildCompletion( insertion_text = 'TestTest' ) ]
  with _SetupForCsharpCompletionDone( completions ) as request:
    with patch( 'ycm.vimsupport.GetVariableValue',
                GetVariableValue_CompleteItemIs( *info[ 1: ] ) ):
      eq_( request._GetCompletionsUserMayHaveCompleted(), [ completions[ 0 ] ] )


def GetCompletionsUserMayHaveCompleted_DontReturnMatchIfNoExactMatchesAndPartial_test(): # noqa
  info = [ 'NS', 'Test', 'Abbr', 'Menu', 'Info', 'Kind' ]
  completions = [ BuildCompletion( insertion_text = info[ 0 ] ),
                  BuildCompletion( insertion_text = 'TestTest' ) ]
  with _SetupForCsharpCompletionDone( completions ) as request:
    with patch( 'ycm.vimsupport.GetVariableValue',
                GetVariableValue_CompleteItemIs( *info[ 1: ] ) ):
      eq_( request._GetCompletionsUserMayHaveCompleted(), [] )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test' ) )
def GetCompletionsUserMayHaveCompleted_ReturnMatchIfMatches_test( *args ):
  completions = [ BuildCompletionNamespace( None ) ]
  with _SetupForCsharpCompletionDone( completions ) as request:
    eq_( request._GetCompletionsUserMayHaveCompleted(), completions )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test', user_data='0' ) )
def GetCompletionsUserMayHaveCompleted_UseUserData0_test( *args ):
  # Identical completions but we specify the first one via user_data.
  completions = [
    BuildCompletionNamespace( 'namespace1' ),
    BuildCompletionNamespace( 'namespace2' )
  ]

  with _SetupForCsharpCompletionDone( completions ) as request:
    eq_( request._GetCompletionsUserMayHaveCompleted(),
         [ BuildCompletionNamespace( 'namespace1' ) ] )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test', user_data='1' ) )
def GetCompletionsUserMayHaveCompleted_UseUserData1_test( *args ):
  # Identical completions but we specify the second one via user_data.
  completions = [
    BuildCompletionNamespace( 'namespace1' ),
    BuildCompletionNamespace( 'namespace2' )
  ]

  with _SetupForCsharpCompletionDone( completions ) as request:
    eq_( request._GetCompletionsUserMayHaveCompleted(),
         [ BuildCompletionNamespace( 'namespace2' ) ] )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test', user_data='' ) )
def GetCompletionsUserMayHaveCompleted_EmptyUserData_test( *args ):
  # Identical completions but none is selected.
  completions = [
    BuildCompletionNamespace( 'namespace1' ),
    BuildCompletionNamespace( 'namespace2' )
  ]

  with _SetupForCsharpCompletionDone( completions ) as request:
    eq_( request._GetCompletionsUserMayHaveCompleted(), [] )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test' ) )
def PostCompleteCsharp_EmptyDoesntInsertNamespace_test( *args ):
  with _SetupForCsharpCompletionDone( [] ) as request:
    request._OnCompleteDone_Csharp()
    ok_( not vimsupport.InsertNamespace.called )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test' ) )
def PostCompleteCsharp_ExistingWithoutNamespaceDoesntInsertNamespace_test(
    *args ):
  completions = [ BuildCompletionNamespace( None ) ]
  with _SetupForCsharpCompletionDone( completions ) as request:
    request._OnCompleteDone_Csharp()
    ok_( not vimsupport.InsertNamespace.called )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test' ) )
def PostCompleteCsharp_ValueDoesInsertNamespace_test( *args ):
  namespace = 'A_NAMESPACE'
  completions = [ BuildCompletionNamespace( namespace ) ]
  with _SetupForCsharpCompletionDone( completions ) as request:
    request._OnCompleteDone_Csharp()
    vimsupport.InsertNamespace.assert_called_once_with( namespace )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test' ) )
@patch( 'ycm.vimsupport.PresentDialog', return_value = 1 )
def PostCompleteCsharp_InsertSecondNamespaceIfSelected_test( *args ):
  namespace = 'A_NAMESPACE'
  namespace2 = 'ANOTHER_NAMESPACE'
  completions = [
    BuildCompletionNamespace( namespace ),
    BuildCompletionNamespace( namespace2 ),
  ]
  with _SetupForCsharpCompletionDone( completions ) as request:
    request._OnCompleteDone_Csharp()
    vimsupport.InsertNamespace.assert_called_once_with( namespace2 )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test' ) )
@patch( 'ycm.vimsupport.ReplaceChunks' )
def PostCompleteFixIt_ApplyFixIt_NoFixIts_test( replace_chunks, *args ):
  completions = [
    BuildCompletionFixIt( [] )
  ]
  with _SetUpCompleteDone( completions ) as request:
    request._OnCompleteDone_FixIt()
    replace_chunks.assert_not_called()


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test' ) )
@patch( 'ycm.vimsupport.ReplaceChunks' )
def PostCompleteFixIt_ApplyFixIt_EmptyFixIt_test( replace_chunks, *args ):
  completions = [
    BuildCompletionFixIt( [ { 'chunks': [] } ] )
  ]
  with _SetUpCompleteDone( completions ) as request:
    request._OnCompleteDone_FixIt()
    replace_chunks.assert_called_once_with( [], silent = True )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test' ) )
@patch( 'ycm.vimsupport.ReplaceChunks' )
def PostCompleteFixIt_ApplyFixIt_NoFixIt_test( replace_chunks, *args ):
  completions = [
    BuildCompletion()
  ]
  with _SetUpCompleteDone( completions ) as request:
    request._OnCompleteDone_FixIt()
    replace_chunks.assert_not_called()


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test' ) )
@patch( 'ycm.vimsupport.ReplaceChunks' )
def PostCompleteFixIt_ApplyFixIt_PickFirst_test( replace_chunks, *args ):
  completions = [
    BuildCompletionFixIt( [ { 'chunks': 'one' } ] ),
    BuildCompletionFixIt( [ { 'chunks': 'two' } ] ),
  ]
  with _SetUpCompleteDone( completions ) as request:
    request._OnCompleteDone_FixIt()
    replace_chunks.assert_called_once_with( 'one', silent = True )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test', user_data='0' ) )
@patch( 'ycm.vimsupport.ReplaceChunks' )
def PostCompleteFixIt_ApplyFixIt_PickFirstUserData_test( replace_chunks,
                                                         *args ):
  completions = [
    BuildCompletionFixIt( [ { 'chunks': 'one' } ] ),
    BuildCompletionFixIt( [ { 'chunks': 'two' } ] ),
  ]
  with _SetUpCompleteDone( completions ) as request:
    request._OnCompleteDone_FixIt()
    replace_chunks.assert_called_once_with( 'one', silent = True )


@patch( 'ycm.vimsupport.GetVariableValue',
        GetVariableValue_CompleteItemIs( 'Test', user_data='1' ) )
@patch( 'ycm.vimsupport.ReplaceChunks' )
def PostCompleteFixIt_ApplyFixIt_PickSecond_test( replace_chunks, *args ):
  completions = [
    BuildCompletionFixIt( [ { 'chunks': 'one' } ] ),
    BuildCompletionFixIt( [ { 'chunks': 'two' } ] ),
  ]
  with _SetUpCompleteDone( completions ) as request:
    request._OnCompleteDone_FixIt()
    replace_chunks.assert_called_once_with( 'two', silent = True )
<EOF>
<BOF>
# coding: utf-8
#
# Copyright (C) 2015-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

# Intentionally not importing unicode_literals!
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests import PathToTestFile
from ycm.tests.test_utils import ( CurrentWorkingDirectory, ExtendedMock,
                                   MockVimBuffers, MockVimModule, Version,
                                   VimBuffer, VimError )
MockVimModule()

from ycm import vimsupport
from nose.tools import eq_
from hamcrest import ( assert_that, calling, contains, empty, equal_to,
                       has_entry, raises )
from mock import MagicMock, call, patch
from ycmd.utils import ToBytes
import os
import json


@patch( 'vim.eval', new_callable = ExtendedMock )
def SetLocationListsForBuffer_Current_test( vim_eval ):
  diagnostics = [ {
    'bufnr': 3,
    'filename': 'some_filename',
    'lnum': 5,
    'col': 22,
    'type': 'E',
    'valid': 1
  } ]
  current_buffer = VimBuffer( '/test', number = 3 )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    vimsupport.SetLocationListsForBuffer( 3, diagnostics )

  vim_eval.assert_has_exact_calls( [
    call( 'setloclist( 1, {0} )'.format( json.dumps( diagnostics ) ) )
  ] )


@patch( 'vim.eval', new_callable = ExtendedMock )
def SetLocationListsForBuffer_NotCurrent_test( vim_eval ):
  diagnostics = [ {
    'bufnr': 3,
    'filename': 'some_filename',
    'lnum': 5,
    'col': 22,
    'type': 'E',
    'valid': 1
  } ]
  current_buffer = VimBuffer( '/test', number = 3 )
  other_buffer = VimBuffer( '/notcurrent', number = 1 )
  with MockVimBuffers( [ current_buffer, other_buffer ], [ current_buffer ] ):
    vimsupport.SetLocationListsForBuffer( 1, diagnostics )

  vim_eval.assert_not_called()


@patch( 'vim.eval', new_callable = ExtendedMock, side_effect = [ -1, 1 ] )
def SetLocationListsForBuffer_NotVisible_test( vim_eval ):
  diagnostics = [ {
    'bufnr': 3,
    'filename': 'some_filename',
    'lnum': 5,
    'col': 22,
    'type': 'E',
    'valid': 1
  } ]
  current_buffer = VimBuffer( '/test', number = 3 )
  other_buffer = VimBuffer( '/notcurrent', number = 1 )
  with MockVimBuffers( [ current_buffer, other_buffer ], [ current_buffer ] ):
    vimsupport.SetLocationListsForBuffer( 1, diagnostics )

  vim_eval.assert_not_called()


@patch( 'vim.eval', new_callable = ExtendedMock, side_effect = [ -1, 1 ] )
def SetLocationListsForBuffer_MultipleWindows_test( vim_eval ):
  diagnostics = [ {
    'bufnr': 3,
    'filename': 'some_filename',
    'lnum': 5,
    'col': 22,
    'type': 'E',
    'valid': 1
  } ]
  current_buffer = VimBuffer( '/test', number = 3 )
  other_buffer = VimBuffer( '/notcurrent', number = 1 )
  with MockVimBuffers( [ current_buffer, other_buffer ],
                       [ current_buffer, other_buffer ] ):
    vimsupport.SetLocationListsForBuffer( 1, diagnostics )

  vim_eval.assert_has_exact_calls( [
    call( 'setloclist( 2, {0} )'.format( json.dumps( diagnostics ) ) )
  ] )


@patch( 'vim.eval', new_callable = ExtendedMock )
def SetLocationList_test( vim_eval ):
  diagnostics = [ {
    'bufnr': 3,
    'filename': 'some_filename',
    'lnum': 5,
    'col': 22,
    'type': 'E',
    'valid': 1
  } ]
  current_buffer = VimBuffer( '/test', number = 3 )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 1 ) ):
    vimsupport.SetLocationList( diagnostics )

  vim_eval.assert_has_calls( [
    call( 'setloclist( 0, {0} )'.format( json.dumps( diagnostics ) ) ),
  ] )


@patch( 'vim.eval', new_callable = ExtendedMock )
def SetLocationList_NotCurrent_test( vim_eval ):
  diagnostics = [ {
    'bufnr': 3,
    'filename': 'some_filename',
    'lnum': 5,
    'col': 22,
    'type': 'E',
    'valid': 1
  } ]
  current_buffer = VimBuffer( '/test', number = 3 )
  other_buffer = VimBuffer( '/notcurrent', number = 1 )
  with MockVimBuffers( [ current_buffer, other_buffer ],
                       [ current_buffer, other_buffer ],
                       ( 1, 1 ) ):
    vimsupport.SetLocationList( diagnostics )

  # This version does not check the current buffer and just sets the current win
  vim_eval.assert_has_exact_calls( [
    call( 'setloclist( 0, {0} )'.format( json.dumps( diagnostics ) ) ),
  ] )


@patch( 'ycm.vimsupport.VariableExists', return_value = True )
@patch( 'ycm.vimsupport.SetFittingHeightForCurrentWindow' )
@patch( 'vim.command', new_callable = ExtendedMock )
def OpenLocationList_test( vim_command, fitting_height, variable_exists ):
  vimsupport.OpenLocationList( focus = False, autoclose = True )
  vim_command.assert_has_exact_calls( [
    call( 'lopen' ),
    call( 'au WinLeave <buffer> q' ),
    call( 'doautocmd User YcmLocationOpened' ),
    call( 'silent! wincmd p' )
  ] )
  fitting_height.assert_called_once_with()
  variable_exists.assert_called_once_with( '#User#YcmLocationOpened' )


@patch( 'vim.command' )
def SetFittingHeightForCurrentWindow_LineWrapOn_test( vim_command, *args ):
  # Create a two lines buffer whose first line is longer than the window width.
  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'a' * 140, 'b' * 80 ] )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ) as vim:
    vim.current.window.width = 120
    vim.current.window.options[ 'wrap' ] = True
    vimsupport.SetFittingHeightForCurrentWindow()
  vim_command.assert_called_once_with( '3wincmd _' )


@patch( 'vim.command' )
def SetFittingHeightForCurrentWindow_LineWrapOff_test( vim_command, *args ):
  # Create a two lines buffer whose first line is longer than the window width.
  current_buffer = VimBuffer( 'buffer',
                              contents = [ 'a' * 140, 'b' * 80 ] )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ) as vim:
    vim.current.window.width = 120
    vim.current.window.options[ 'wrap' ] = False
    vimsupport.SetFittingHeightForCurrentWindow()
  vim_command.assert_called_once_with( '2wincmd _' )


def AssertBuffersAreEqualAsBytes( result_buffer, expected_buffer ):
  eq_( len( result_buffer ), len( expected_buffer ) )
  for result_line, expected_line in zip( result_buffer, expected_buffer ):
    eq_( ToBytes( result_line ), ToBytes( expected_line ) )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Repl_1_test():
  # Replace with longer range
  result_buffer = VimBuffer( 'buffer', contents = [ 'This is a string' ] )
  start, end = _BuildLocations( 1, 11, 1, 17 )
  vimsupport.ReplaceChunk( start, end, 'pie', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This is a pie' ], result_buffer )

  # and replace again
  start, end = _BuildLocations( 1, 10, 1, 11 )
  vimsupport.ReplaceChunk( start, end, ' piece of ', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This is a piece of pie' ], result_buffer )

  # and once more, for luck
  start, end = _BuildLocations( 1, 1, 1, 5 )
  vimsupport.ReplaceChunk( start, end, 'How long', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'How long is a piece of pie' ],
                                result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Repl_2_test():
  # Replace with shorter range
  result_buffer = VimBuffer( 'buffer', contents = [ 'This is a string' ] )
  start, end = _BuildLocations( 1, 11, 1, 17 )
  vimsupport.ReplaceChunk( start, end, 'test', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This is a test' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Repl_3_test():
  # Replace with equal range
  result_buffer = VimBuffer( 'buffer', contents = [ 'This is a string' ] )
  start, end = _BuildLocations( 1, 6, 1, 8 )
  vimsupport.ReplaceChunk( start, end, 'be', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This be a string' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Add_1_test():
  # Insert at start
  result_buffer = VimBuffer( 'buffer', contents = [ 'is a string' ] )
  start, end = _BuildLocations( 1, 1, 1, 1 )
  vimsupport.ReplaceChunk( start, end, 'This ', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This is a string' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Add_2_test():
  # Insert at end
  result_buffer = VimBuffer( 'buffer', contents = [ 'This is a ' ] )
  start, end = _BuildLocations( 1, 11, 1, 11 )
  vimsupport.ReplaceChunk( start, end, 'string', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This is a string' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Add_3_test():
  # Insert in the middle
  result_buffer = VimBuffer( 'buffer', contents = [ 'This is a string' ] )
  start, end = _BuildLocations( 1, 8, 1, 8 )
  vimsupport.ReplaceChunk( start, end, ' not', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This is not a string' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Del_1_test():
  # Delete from start
  result_buffer = VimBuffer( 'buffer', contents = [ 'This is a string' ] )
  start, end = _BuildLocations( 1, 1, 1, 6 )
  vimsupport.ReplaceChunk( start, end, '', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'is a string' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Del_2_test():
  # Delete from end
  result_buffer = VimBuffer( 'buffer', contents = [ 'This is a string' ] )
  start, end = _BuildLocations( 1, 10, 1, 18 )
  vimsupport.ReplaceChunk( start, end, '', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This is a' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Del_3_test():
  # Delete from middle
  result_buffer = VimBuffer( 'buffer', contents = [ 'This is not a string' ] )
  start, end = _BuildLocations( 1, 9, 1, 13 )
  vimsupport.ReplaceChunk( start, end, '', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This is a string' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Unicode_ReplaceUnicodeChars_test():
  # Replace Unicode characters.
  result_buffer = VimBuffer(
    'buffer', contents = [ 'This Uniçø∂‰ string is in the middle' ] )
  start, end = _BuildLocations( 1, 6, 1, 20 )
  vimsupport.ReplaceChunk( start, end, 'Unicode ', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This Unicode string is in the middle' ],
                                 result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Unicode_ReplaceAfterUnicode_test():
  # Replace ASCII characters after Unicode characters in the line.
  result_buffer = VimBuffer(
    'buffer', contents = [ 'This Uniçø∂‰ string is in the middle' ] )
  start, end = _BuildLocations( 1, 30, 1, 43 )
  vimsupport.ReplaceChunk( start, end, 'fåke', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'This Uniçø∂‰ string is fåke' ],
                                 result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleLine_Unicode_Grown_test():
  # Replace ASCII characters after Unicode characters in the line.
  result_buffer = VimBuffer( 'buffer', contents = [ 'a' ] )
  start, end = _BuildLocations( 1, 1, 1, 2 )
  vimsupport.ReplaceChunk( start, end, 'å', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'å' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_RemoveSingleLine_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 2, 1, 3, 1 )
  vimsupport.ReplaceChunk( start, end, '', result_buffer )
  # First line is not affected.
  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleToMultipleLines_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 2, 3, 2, 4 )
  vimsupport.ReplaceChunk( start, end, 'cccc', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aBcccc',
                                  'aCa' ], result_buffer )

  # now make another change to the second line
  start, end = _BuildLocations( 2, 2, 2, 2 )
  vimsupport.ReplaceChunk( start, end, 'Eb\nbF', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aEb',
                                  'bFBcccc',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleToMultipleLines2_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 2, 2, 2, 2 )
  vimsupport.ReplaceChunk( start, end, 'Eb\nbFb\nG', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aEb',
                                  'bFb',
                                  'GBa',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleToMultipleLines3_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 2, 2, 2, 2 )
  vimsupport.ReplaceChunk( start, end, 'Eb\nbFb\nbGb', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aEb',
                                  'bFb',
                                  'bGbBa',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleToMultipleLinesReplace_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 1, 2, 1, 4 )
  vimsupport.ReplaceChunk( start, end, 'Eb\nbFb\nbGb', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aEb',
                                  'bFb',
                                  'bGb',
                                  'aBa',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SingleToMultipleLinesReplace_2_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 1, 4, 1, 4 )
  vimsupport.ReplaceChunk( start, end, 'cccc', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAacccc',
                                  'aBa',
                                  'aCa', ], result_buffer )

  # now do a subsequent change (insert in the middle of the first line)
  start, end = _BuildLocations( 1, 2, 1, 4 )
  vimsupport.ReplaceChunk( start, end, 'Eb\nbFb\nbGb', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aEb',
                                  'bFb',
                                  'bGbcccc',
                                  'aBa',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_MultipleLinesToSingleLine_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCaaaa' ] )
  start, end = _BuildLocations( 3, 4, 3, 5 )
  vimsupport.ReplaceChunk( start, end, 'dd\ndd', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aBa',
                                  'aCadd',
                                  'ddaa' ], result_buffer )

  # make another modification applying offsets
  start, end = _BuildLocations( 3, 3, 3, 4 )
  vimsupport.ReplaceChunk( start, end, 'cccc', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aBa',
                                  'aCccccdd',
                                  'ddaa' ], result_buffer )

  # and another, for luck
  start, end = _BuildLocations( 2, 2, 3, 2 )
  vimsupport.ReplaceChunk( start, end, 'E', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aECccccdd',
                                  'ddaa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_MultipleLinesToSameMultipleLines_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa',
                                                    'aDe' ] )
  start, end = _BuildLocations( 2, 2, 3, 2 )
  vimsupport.ReplaceChunk( start, end, 'Eb\nbF', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aEb',
                                  'bFCa',
                                  'aDe' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_MultipleLinesToMoreMultipleLines_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa',
                                                    'aDe' ] )
  start, end = _BuildLocations( 2, 2, 3, 2 )
  vimsupport.ReplaceChunk( start, end, 'Eb\nbFb\nbG', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aEb',
                                  'bFb',
                                  'bGCa',
                                  'aDe' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_MultipleLinesToLessMultipleLines_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa',
                                                    'aDe' ] )
  start, end = _BuildLocations( 1, 2, 3, 2 )
  vimsupport.ReplaceChunk( start, end, 'Eb\nbF', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aEb',
                                  'bFCa',
                                  'aDe' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_MultipleLinesToEvenLessMultipleLines_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa',
                                                    'aDe' ] )
  start, end = _BuildLocations( 1, 2, 4, 2 )
  vimsupport.ReplaceChunk( start, end, 'Eb\nbF', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aEb',
                                  'bFDe' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_SpanBufferEdge_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 1, 1, 1, 3 )
  vimsupport.ReplaceChunk( start, end, 'bDb', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'bDba',
                                  'aBa',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_DeleteTextInLine_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 2, 2, 2, 3 )
  vimsupport.ReplaceChunk( start, end, '', result_buffer )
  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'aa',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_AddTextInLine_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 2, 2, 2, 2 )
  vimsupport.ReplaceChunk( start, end, 'bDb', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'abDbBa',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_ReplaceTextInLine_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'aAa',
                                                    'aBa',
                                                    'aCa' ] )
  start, end = _BuildLocations( 2, 2, 2, 3 )
  vimsupport.ReplaceChunk( start, end, 'bDb', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'aAa',
                                  'abDba',
                                  'aCa' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_NewlineChunk_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'first line',
                                                    'second line' ] )
  start, end = _BuildLocations( 1, 11, 2, 1 )
  vimsupport.ReplaceChunk( start, end, '\n', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'first line',
                                  'second line' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunk_BeyondEndOfFile_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'first line',
                                                    'second line' ] )
  start, end = _BuildLocations( 1, 11, 3, 1 )
  vimsupport.ReplaceChunk( start, end, '\n', result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'first line' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 3 ) )
def ReplaceChunk_CursorPosition_test():
  result_buffer = VimBuffer( 'buffer', contents = [ 'bar' ] )
  start, end = _BuildLocations( 1, 1, 1, 1 )
  vimsupport.ReplaceChunk( start,
                           end,
                           'xyz\nfoo',
                           result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'xyz', 'foobar' ], result_buffer )
  # Cursor line is 0-based.
  assert_that( vimsupport.CurrentLineAndColumn(), contains( 1, 6 ) )


def _BuildLocations( start_line, start_column, end_line, end_column ):
  return {
    'line_num'  : start_line,
    'column_num': start_column,
  }, {
    'line_num'  : end_line,
    'column_num': end_column,
  }


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunksInBuffer_SortedChunks_test():
  chunks = [
    _BuildChunk( 1, 4, 1, 4, '(' ),
    _BuildChunk( 1, 11, 1, 11, ')' )
  ]

  result_buffer = VimBuffer( 'buffer', contents = [ 'CT<10 >> 2> ct' ] )
  vimsupport.ReplaceChunksInBuffer( chunks, result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'CT<(10 >> 2)> ct' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunksInBuffer_UnsortedChunks_test():
  chunks = [
    _BuildChunk( 1, 11, 1, 11, ')' ),
    _BuildChunk( 1, 4, 1, 4, '(' )
  ]

  result_buffer = VimBuffer( 'buffer', contents = [ 'CT<10 >> 2> ct' ] )
  vimsupport.ReplaceChunksInBuffer( chunks, result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'CT<(10 >> 2)> ct' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunksInBuffer_LineOverlappingChunks_test():
  chunks = [
    _BuildChunk( 1, 11, 2, 1, '\n    ' ),
    _BuildChunk( 2, 12, 3, 1, '\n    ' ),
    _BuildChunk( 3, 11, 4, 1, '\n    ' )
  ]

  result_buffer = VimBuffer( 'buffer', contents = [ 'first line',
                                                    'second line',
                                                    'third line',
                                                    'fourth line' ] )
  vimsupport.ReplaceChunksInBuffer( chunks, result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'first line',
                                  '    second line',
                                  '    third line',
                                  '    fourth line' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunksInBuffer_OutdentChunks_test():
  chunks = [
    _BuildChunk( 1,  1, 1, 5, '  ' ),
    _BuildChunk( 1, 15, 2, 9, '\n    ' ),
    _BuildChunk( 2, 20, 3, 3, '\n' )
  ]

  result_buffer = VimBuffer( 'buffer', contents = [ '    first line',
                                                    '        second line',
                                                    '    third line' ] )
  vimsupport.ReplaceChunksInBuffer( chunks, result_buffer )

  AssertBuffersAreEqualAsBytes( [ '  first line',
                                  '    second line',
                                  '  third line' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunksInBuffer_OneLineIndentingChunks_test():
  chunks = [
    _BuildChunk( 1,  8, 2,  1, '\n ' ),
    _BuildChunk( 2,  9, 2, 10, '\n  ' ),
    _BuildChunk( 2, 19, 2, 20, '\n ' )
  ]

  result_buffer = VimBuffer( 'buffer', contents = [ 'class {',
                                                    'method { statement }',
                                                    '}' ] )
  vimsupport.ReplaceChunksInBuffer( chunks, result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'class {',
                                  ' method {',
                                  '  statement',
                                  ' }',
                                  '}' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
def ReplaceChunksInBuffer_SameLocation_test():
  chunks = [
    _BuildChunk( 1, 1, 1, 1, 'this ' ),
    _BuildChunk( 1, 1, 1, 1, 'is ' ),
    _BuildChunk( 1, 1, 1, 1, 'pure ' )
  ]

  result_buffer = VimBuffer( 'buffer', contents = [ 'folly' ] )
  vimsupport.ReplaceChunksInBuffer( chunks, result_buffer )

  AssertBuffersAreEqualAsBytes( [ 'this is pure folly' ], result_buffer )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
@patch( 'ycm.vimsupport.VariableExists', return_value = False )
@patch( 'ycm.vimsupport.SetFittingHeightForCurrentWindow' )
@patch( 'ycm.vimsupport.GetBufferNumberForFilename',
        return_value = 1,
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.BufferIsVisible',
        return_value = True,
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.OpenFilename' )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
@patch( 'vim.eval', new_callable = ExtendedMock )
@patch( 'vim.command', new_callable = ExtendedMock )
def ReplaceChunks_SingleFile_Open_test( vim_command,
                                        vim_eval,
                                        post_vim_message,
                                        open_filename,
                                        buffer_is_visible,
                                        get_buffer_number_for_filename,
                                        set_fitting_height,
                                        variable_exists ):
  single_buffer_name = os.path.realpath( 'single_file' )

  chunks = [
    _BuildChunk( 1, 1, 2, 1, 'replacement', single_buffer_name )
  ]

  result_buffer = VimBuffer(
    single_buffer_name,
    contents = [
      'line1',
      'line2',
      'line3'
    ]
  )

  with patch( 'vim.buffers', [ None, result_buffer, None ] ):
    vimsupport.ReplaceChunks( chunks )

  # Ensure that we applied the replacement correctly
  eq_( result_buffer.GetLines(), [
    'replacementline2',
    'line3',
  ] )

  # GetBufferNumberForFilename is called twice:
  #  - once to the check if we would require opening the file (so that we can
  #    raise a warning)
  #  - once whilst applying the changes
  get_buffer_number_for_filename.assert_has_exact_calls( [
    call( single_buffer_name ),
    call( single_buffer_name ),
  ] )

  # BufferIsVisible is called twice for the same reasons as above
  buffer_is_visible.assert_has_exact_calls( [
    call( 1 ),
    call( 1 ),
  ] )

  # we don't attempt to open any files
  open_filename.assert_not_called()

  # But we do set the quickfix list
  vim_eval.assert_has_exact_calls( [
    call( 'setqflist( {0} )'.format( json.dumps( [ {
      'bufnr': 1,
      'filename': single_buffer_name,
      'lnum': 1,
      'col': 1,
      'text': 'replacement',
      'type': 'F'
    } ] ) ) ),
  ] )

  # And it is ReplaceChunks that prints the message showing the number of
  # changes
  post_vim_message.assert_has_exact_calls( [
    call( 'Applied 1 changes', warning = False ),
  ] )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
@patch( 'ycm.vimsupport.VariableExists', return_value = False )
@patch( 'ycm.vimsupport.SetFittingHeightForCurrentWindow' )
@patch( 'ycm.vimsupport.GetBufferNumberForFilename',
        side_effect = [ -1, -1, 1 ],
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.BufferIsVisible',
        side_effect = [ False, False, True ],
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.OpenFilename',
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.Confirm',
        return_value = True,
        new_callable = ExtendedMock )
@patch( 'vim.eval', return_value = 10, new_callable = ExtendedMock )
@patch( 'vim.command', new_callable = ExtendedMock )
def ReplaceChunks_SingleFile_NotOpen_test( vim_command,
                                           vim_eval,
                                           confirm,
                                           post_vim_message,
                                           open_filename,
                                           buffer_is_visible,
                                           get_buffer_number_for_filename,
                                           set_fitting_height,
                                           variable_exists ):
  single_buffer_name = os.path.realpath( 'single_file' )

  chunks = [
    _BuildChunk( 1, 1, 2, 1, 'replacement', single_buffer_name )
  ]

  result_buffer = VimBuffer(
    single_buffer_name,
    contents = [
      'line1',
      'line2',
      'line3'
    ]
  )

  with patch( 'vim.buffers', [ None, result_buffer, None ] ):
    vimsupport.ReplaceChunks( chunks )

  # We checked if it was OK to open the file
  confirm.assert_has_exact_calls( [
    call( vimsupport.FIXIT_OPENING_BUFFERS_MESSAGE_FORMAT.format( 1 ) )
  ] )

  # Ensure that we applied the replacement correctly
  eq_( result_buffer.GetLines(), [
    'replacementline2',
    'line3',
  ] )

  # GetBufferNumberForFilename is called 3 times. The return values are set in
  # the @patch call above:
  #  - once to the check if we would require opening the file (so that we can
  #    raise a warning) (-1 return)
  #  - once whilst applying the changes (-1 return)
  #  - finally after calling OpenFilename (1 return)
  get_buffer_number_for_filename.assert_has_exact_calls( [
    call( single_buffer_name ),
    call( single_buffer_name ),
    call( single_buffer_name ),
  ] )

  # BufferIsVisible is called 3 times for the same reasons as above, with the
  # return of each one
  buffer_is_visible.assert_has_exact_calls( [
    call( -1 ),
    call( -1 ),
    call( 1 ),
  ] )

  # We open 'single_file' as expected.
  open_filename.assert_called_with( single_buffer_name, {
    'focus': True,
    'fix': True,
    'size': 10
  } )

  # And close it again, then show the quickfix window.
  vim_command.assert_has_exact_calls( [
    call( 'lclose' ),
    call( 'hide' ),
  ] )

  # And update the quickfix list
  vim_eval.assert_has_exact_calls( [
    call( '&previewheight' ),
    call( 'setqflist( {0} )'.format( json.dumps( [ {
      'bufnr': 1,
      'filename': single_buffer_name,
      'lnum': 1,
      'col': 1,
      'text': 'replacement',
      'type': 'F'
    } ] ) ) ),
  ] )

  # And it is ReplaceChunks that prints the message showing the number of
  # changes
  post_vim_message.assert_has_exact_calls( [
    call( 'Applied 1 changes', warning = False ),
  ] )


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
@patch( 'ycm.vimsupport.VariableExists', return_value = False )
@patch( 'ycm.vimsupport.SetFittingHeightForCurrentWindow' )
@patch( 'ycm.vimsupport.GetBufferNumberForFilename',
        side_effect = [ -1, 1 ],
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.BufferIsVisible',
        side_effect = [ False, True ],
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.OpenFilename',
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.Confirm',
        return_value = True,
        new_callable = ExtendedMock )
@patch( 'vim.eval', return_value = 10, new_callable = ExtendedMock )
@patch( 'vim.command', new_callable = ExtendedMock )
def ReplaceChunks_SingleFile_NotOpen_Silent_test(
  vim_command,
  vim_eval,
  confirm,
  post_vim_message,
  open_filename,
  buffer_is_visible,
  get_buffer_number_for_filename,
  set_fitting_height,
  variable_exists ):

  # This test is the same as ReplaceChunks_SingleFile_NotOpen_test, but we pass
  # the silent flag, as used by post-complete actions, and shows the stuff we
  # _don't_ call in that case.

  single_buffer_name = os.path.realpath( 'single_file' )

  chunks = [
    _BuildChunk( 1, 1, 2, 1, 'replacement', single_buffer_name )
  ]

  result_buffer = VimBuffer(
    single_buffer_name,
    contents = [
      'line1',
      'line2',
      'line3'
    ]
  )

  with patch( 'vim.buffers', [ None, result_buffer, None ] ):
    vimsupport.ReplaceChunks( chunks, silent=True )

  # We didn't check if it was OK to open the file (silent)
  confirm.assert_not_called()

  # Ensure that we applied the replacement correctly
  eq_( result_buffer.GetLines(), [
    'replacementline2',
    'line3',
  ] )

  # GetBufferNumberForFilename is called 2 times. The return values are set in
  # the @patch call above:
  #  - once whilst applying the changes (-1 return)
  #  - finally after calling OpenFilename (1 return)
  get_buffer_number_for_filename.assert_has_exact_calls( [
    call( single_buffer_name ),
    call( single_buffer_name ),
  ] )

  # BufferIsVisible is called 2 times for the same reasons as above, with the
  # return of each one
  buffer_is_visible.assert_has_exact_calls( [
    call( -1 ),
    call( 1 ),
  ] )

  # We open 'single_file' as expected.
  open_filename.assert_called_with( single_buffer_name, {
    'focus': True,
    'fix': True,
    'size': 10
  } )

  # And close it again, but don't show the quickfix window
  vim_command.assert_has_exact_calls( [
    call( 'lclose' ),
    call( 'hide' ),
  ] )
  set_fitting_height.assert_not_called()

  # But we _don't_ update the QuickFix list
  vim_eval.assert_has_exact_calls( [
    call( '&previewheight' ),
  ] )

  # And we don't print a message either
  post_vim_message.assert_not_called()


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
@patch( 'ycm.vimsupport.GetBufferNumberForFilename',
        side_effect = [ -1, -1, 1 ],
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.BufferIsVisible',
        side_effect = [ False, False, True ],
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.OpenFilename',
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.PostVimMessage',
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.Confirm',
        return_value = False,
        new_callable = ExtendedMock )
@patch( 'vim.eval',
        return_value = 10,
        new_callable = ExtendedMock )
@patch( 'vim.command', new_callable = ExtendedMock )
def ReplaceChunks_User_Declines_To_Open_File_test(
                                           vim_command,
                                           vim_eval,
                                           confirm,
                                           post_vim_message,
                                           open_filename,
                                           buffer_is_visible,
                                           get_buffer_number_for_filename ):

  # Same as above, except the user selects Cancel when asked if they should
  # allow us to open lots of (ahem, 1) file.
  single_buffer_name = os.path.realpath( 'single_file' )

  chunks = [
    _BuildChunk( 1, 1, 2, 1, 'replacement', single_buffer_name )
  ]

  result_buffer = VimBuffer(
    single_buffer_name,
    contents = [
      'line1',
      'line2',
      'line3'
    ]
  )

  with patch( 'vim.buffers', [ None, result_buffer, None ] ):
    vimsupport.ReplaceChunks( chunks )

  # We checked if it was OK to open the file
  confirm.assert_has_exact_calls( [
    call( vimsupport.FIXIT_OPENING_BUFFERS_MESSAGE_FORMAT.format( 1 ) )
  ] )

  # Ensure that buffer is not changed
  eq_( result_buffer.GetLines(), [
    'line1',
    'line2',
    'line3',
  ] )

  # GetBufferNumberForFilename is called once. The return values are set in
  # the @patch call above:
  #  - once to the check if we would require opening the file (so that we can
  #    raise a warning) (-1 return)
  get_buffer_number_for_filename.assert_has_exact_calls( [
    call( single_buffer_name ),
  ] )

  # BufferIsVisible is called once for the above file, which wasn't visible.
  buffer_is_visible.assert_has_exact_calls( [
    call( -1 ),
  ] )

  # We don't attempt to open any files or update any quickfix list or anything
  # like that
  open_filename.assert_not_called()
  vim_eval.assert_not_called()
  vim_command.assert_not_called()
  post_vim_message.assert_not_called()


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
@patch( 'ycm.vimsupport.GetBufferNumberForFilename',
        side_effect = [ -1, -1, 1 ],
        new_callable = ExtendedMock )
# Key difference is here: In the final check, BufferIsVisible returns False
@patch( 'ycm.vimsupport.BufferIsVisible',
        side_effect = [ False, False, False ],
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.OpenFilename',
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.PostVimMessage',
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.Confirm',
        return_value = True,
        new_callable = ExtendedMock )
@patch( 'vim.eval',
        return_value = 10,
        new_callable = ExtendedMock )
@patch( 'vim.command',
        new_callable = ExtendedMock )
def ReplaceChunks_User_Aborts_Opening_File_test(
                                           vim_command,
                                           vim_eval,
                                           confirm,
                                           post_vim_message,
                                           open_filename,
                                           buffer_is_visible,
                                           get_buffer_number_for_filename ):

  # Same as above, except the user selects Abort or Quick during the
  # "swap-file-found" dialog
  single_buffer_name = os.path.realpath( 'single_file' )

  chunks = [
    _BuildChunk( 1, 1, 2, 1, 'replacement', single_buffer_name )
  ]

  result_buffer = VimBuffer(
    single_buffer_name,
    contents = [
      'line1',
      'line2',
      'line3'
    ]
  )

  with patch( 'vim.buffers', [ None, result_buffer, None ] ):
    assert_that( calling( vimsupport.ReplaceChunks ).with_args( chunks ),
                 raises( RuntimeError,
                  'Unable to open file: .+single_file\n'
                  'FixIt/Refactor operation aborted prior to completion. '
                  'Your files have not been fully updated. '
                  'Please use undo commands to revert the applied changes.' ) )

  # We checked if it was OK to open the file
  confirm.assert_has_exact_calls( [
    call( vimsupport.FIXIT_OPENING_BUFFERS_MESSAGE_FORMAT.format( 1 ) )
  ] )

  # Ensure that buffer is not changed
  eq_( result_buffer.GetLines(), [
    'line1',
    'line2',
    'line3',
  ] )

  # We tried to open this file
  open_filename.assert_called_with( single_buffer_name, {
    'focus': True,
    'fix': True,
    'size': 10
  } )
  vim_eval.assert_called_with( "&previewheight" )

  # But raised an exception before issuing the message at the end
  post_vim_message.assert_not_called()


@patch( 'vim.current.window.cursor', ( 1, 1 ) )
@patch( 'ycm.vimsupport.VariableExists', return_value = False )
@patch( 'ycm.vimsupport.SetFittingHeightForCurrentWindow' )
@patch( 'ycm.vimsupport.GetBufferNumberForFilename', side_effect = [
          22, # first_file (check)
          -1, # second_file (check)
          22, # first_file (apply)
          -1, # second_file (apply)
          19, # second_file (check after open)
        ],
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.BufferIsVisible', side_effect = [
          True,  # first_file (check)
          False, # second_file (check)
          True,  # first_file (apply)
          False, # second_file (apply)
          True,  # side_effect (check after open)
        ],
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.OpenFilename',
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.PostVimMessage',
        new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.Confirm', return_value = True,
        new_callable = ExtendedMock )
@patch( 'vim.eval', return_value = 10,
        new_callable = ExtendedMock )
@patch( 'vim.command',
        new_callable = ExtendedMock )
def ReplaceChunks_MultiFile_Open_test( vim_command,
                                       vim_eval,
                                       confirm,
                                       post_vim_message,
                                       open_filename,
                                       buffer_is_visible,
                                       get_buffer_number_for_filename,
                                       set_fitting_height,
                                       variable_exists ):

  # Chunks are split across 2 files, one is already open, one isn't
  first_buffer_name = os.path.realpath( '1_first_file' )
  second_buffer_name = os.path.realpath( '2_second_file' )

  chunks = [
    _BuildChunk( 1, 1, 2, 1, 'first_file_replacement ', first_buffer_name ),
    _BuildChunk( 2, 1, 2, 1, 'second_file_replacement ', second_buffer_name ),
  ]

  first_file = VimBuffer(
    first_buffer_name,
    number = 22,
    contents = [
      'line1',
      'line2',
      'line3',
    ]
  )
  second_file = VimBuffer(
    second_buffer_name,
    number = 19,
    contents = [
      'another line1',
      'ACME line2',
    ]
  )

  vim_buffers = [ None ] * 23
  vim_buffers[ 22 ] = first_file
  vim_buffers[ 19 ] = second_file

  with patch( 'vim.buffers', vim_buffers ):
    vimsupport.ReplaceChunks( chunks )

  # We checked for the right file names
  get_buffer_number_for_filename.assert_has_exact_calls( [
    call( first_buffer_name ),
    call( second_buffer_name ),
    call( first_buffer_name ),
    call( second_buffer_name ),
    call( second_buffer_name ),
  ] )

  # We checked if it was OK to open the file
  confirm.assert_has_exact_calls( [
    call( vimsupport.FIXIT_OPENING_BUFFERS_MESSAGE_FORMAT.format( 1 ) )
  ] )

  # Ensure that buffers are updated
  eq_( second_file.GetLines(), [
    'another line1',
    'second_file_replacement ACME line2',
  ] )
  eq_( first_file.GetLines(), [
    'first_file_replacement line2',
    'line3',
  ] )

  # We open '2_second_file' as expected.
  open_filename.assert_called_with( second_buffer_name, {
    'focus': True,
    'fix': True,
    'size': 10
  } )

  # And close it again, then show the quickfix window.
  vim_command.assert_has_exact_calls( [
    call( 'lclose' ),
    call( 'hide' ),
  ] )

  # And update the quickfix list with each entry
  vim_eval.assert_has_exact_calls( [
    call( '&previewheight' ),
    call( 'setqflist( {0} )'.format( json.dumps( [ {
      'bufnr': 22,
      'filename': first_buffer_name,
      'lnum': 1,
      'col': 1,
      'text': 'first_file_replacement ',
      'type': 'F'
    }, {
      'bufnr': 19,
      'filename': second_buffer_name,
      'lnum': 2,
      'col': 1,
      'text': 'second_file_replacement ',
      'type': 'F'
    } ] ) ) ),
  ] )

  # And it is ReplaceChunks that prints the message showing the number of
  # changes
  post_vim_message.assert_has_exact_calls( [
    call( 'Applied 2 changes', warning = False ),
  ] )


def _BuildChunk( start_line,
                 start_column,
                 end_line,
                 end_column,
                 replacement_text, filepath='test_file_name' ):
  return {
    'range': {
      'start': {
        'filepath': filepath,
        'line_num': start_line,
        'column_num': start_column,
      },
      'end': {
        'filepath': filepath,
        'line_num': end_line,
        'column_num': end_column,
      },
    },
    'replacement_text': replacement_text
  }


def GetDiagnosticMatchPattern_ErrorInMiddleOfLine_test():
  current_buffer = VimBuffer(
    'some_file',
    contents = [ 'Highlight this error please' ]
  )

  with patch( 'vim.current.buffer', current_buffer ):
    assert_that(
      vimsupport.GetDiagnosticMatchPattern( 1, 16, 1, 21 ),
      equal_to( '\\%1l\\%16c\\_.\\{-}\\%1l\\%21c' )
    )


def AddDiagnosticSyntaxMatch_WarningAtEndOfLine_test():
  current_buffer = VimBuffer(
    'some_file',
    contents = [ 'Highlight this warning' ]
  )

  with patch( 'vim.current.buffer', current_buffer ):
    assert_that(
      vimsupport.GetDiagnosticMatchPattern( 1, 16, 1, 23 ),
      equal_to( '\\%1l\\%16c\\_.\\{-}\\%1l\\%23c' )
    )


def AddDiagnosticSyntaxMatch_UnicodeAtEndOfLine_test():
  current_buffer = VimBuffer(
    'some_file',
    contents = [ 'Highlight unicøde' ]
  )

  with patch( 'vim.current.buffer', current_buffer ):
    assert_that(
      vimsupport.GetDiagnosticMatchPattern( 1, 16, 1, 19 ),
      equal_to( '\\%1l\\%16c\\_.\\{-}\\%1l\\%19c' )
    )


@patch( 'vim.command', new_callable=ExtendedMock )
@patch( 'vim.current', new_callable=ExtendedMock )
def WriteToPreviewWindow_test( vim_current, vim_command ):
  vim_current.window.options.__getitem__ = MagicMock( return_value = True )

  vimsupport.WriteToPreviewWindow( "test" )

  vim_command.assert_has_exact_calls( [
    call( 'silent! pclose!' ),
    call( 'silent! pedit! _TEMP_FILE_' ),
    call( 'silent! wincmd P' ),
    call( 'silent! wincmd p' ) ] )

  vim_current.buffer.__setitem__.assert_called_with(
      slice( None, None, None ), [ 'test' ] )

  vim_current.buffer.options.__setitem__.assert_has_exact_calls( [
    call( 'modifiable', True ),
    call( 'readonly', False ),
    call( 'buftype', 'nofile' ),
    call( 'bufhidden', 'wipe' ),
    call( 'buflisted', False ),
    call( 'swapfile', False ),
    call( 'modifiable', False ),
    call( 'modified', False ),
    call( 'readonly', True ),
  ], any_order = True )


@patch( 'vim.current' )
def WriteToPreviewWindow_MultiLine_test( vim_current ):
  vim_current.window.options.__getitem__ = MagicMock( return_value = True )
  vimsupport.WriteToPreviewWindow( "test\ntest2" )

  vim_current.buffer.__setitem__.assert_called_with(
      slice( None, None, None ), [ 'test', 'test2' ] )


@patch( 'vim.command', new_callable=ExtendedMock )
@patch( 'vim.current', new_callable=ExtendedMock )
def WriteToPreviewWindow_JumpFail_test( vim_current, vim_command ):
  vim_current.window.options.__getitem__ = MagicMock( return_value = False )

  vimsupport.WriteToPreviewWindow( "test" )

  vim_command.assert_has_exact_calls( [
    call( 'silent! pclose!' ),
    call( 'silent! pedit! _TEMP_FILE_' ),
    call( 'silent! wincmd P' ),
    call( 'redraw' ),
    call( "echo 'test'" ),
  ] )

  vim_current.buffer.__setitem__.assert_not_called()
  vim_current.buffer.options.__setitem__.assert_not_called()


@patch( 'vim.command', new_callable=ExtendedMock )
@patch( 'vim.current', new_callable=ExtendedMock )
def WriteToPreviewWindow_JumpFail_MultiLine_test( vim_current, vim_command ):

  vim_current.window.options.__getitem__ = MagicMock( return_value = False )

  vimsupport.WriteToPreviewWindow( "test\ntest2" )

  vim_command.assert_has_exact_calls( [
    call( 'silent! pclose!' ),
    call( 'silent! pedit! _TEMP_FILE_' ),
    call( 'silent! wincmd P' ),
    call( 'redraw' ),
    call( "echo 'test'" ),
    call( "echo 'test2'" ),
  ] )

  vim_current.buffer.__setitem__.assert_not_called()
  vim_current.buffer.options.__setitem__.assert_not_called()


def BufferIsVisibleForFilename_test():
  visible_buffer = VimBuffer( 'visible_filename', number = 1 )
  hidden_buffer = VimBuffer( 'hidden_filename', number = 2 )

  with MockVimBuffers( [ visible_buffer, hidden_buffer ], [ visible_buffer ] ):
    eq_( vimsupport.BufferIsVisibleForFilename( 'visible_filename' ), True )
    eq_( vimsupport.BufferIsVisibleForFilename( 'hidden_filename' ), False )
    eq_( vimsupport.BufferIsVisibleForFilename( 'another_filename' ), False )


def CloseBuffersForFilename_test():
  current_buffer = VimBuffer( 'some_filename', number = 2 )
  other_buffer = VimBuffer( 'some_filename', number = 5 )

  with MockVimBuffers( [ current_buffer, other_buffer ],
                       [ current_buffer ] ) as vim:
    vimsupport.CloseBuffersForFilename( 'some_filename' )

  assert_that( vim.buffers, empty() )


@patch( 'vim.command', new_callable = ExtendedMock )
@patch( 'vim.current', new_callable = ExtendedMock )
def OpenFilename_test( vim_current, vim_command ):
  # Options used to open a logfile.
  options = {
    'size': vimsupport.GetIntValue( '&previewheight' ),
    'fix': True,
    'focus': False,
    'watch': True,
    'position': 'end'
  }

  vimsupport.OpenFilename( __file__, options )

  vim_command.assert_has_exact_calls( [
    call( '12split {0}'.format( __file__ ) ),
    call( "exec "
          "'au BufEnter <buffer> :silent! checktime {0}'".format( __file__ ) ),
    call( 'silent! normal! Gzz' ),
    call( 'silent! wincmd p' )
  ] )

  vim_current.buffer.options.__setitem__.assert_has_exact_calls( [
    call( 'autoread', True ),
  ] )

  vim_current.window.options.__setitem__.assert_has_exact_calls( [
    call( 'winfixheight', True )
  ] )


def GetUnsavedAndSpecifiedBufferData_EncodedUnicodeCharsInBuffers_test():
  filepath = os.path.realpath( 'filename' )
  contents = [ ToBytes( u'abc' ), ToBytes( u'fДa' ) ]
  vim_buffer = VimBuffer( filepath, contents = contents )

  with patch( 'vim.buffers', [ vim_buffer ] ):
    assert_that( vimsupport.GetUnsavedAndSpecifiedBufferData( vim_buffer,
                                                              filepath ),
                 has_entry( filepath,
                            has_entry( u'contents', u'abc\nfДa\n' ) ) )


def GetBufferFilepath_NoBufferName_UnicodeWorkingDirectory_test():
  vim_buffer = VimBuffer( '', number = 42 )
  unicode_dir = PathToTestFile( u'uni¢𐍈d€' )
  with CurrentWorkingDirectory( unicode_dir ):
    assert_that( vimsupport.GetBufferFilepath( vim_buffer ),
                 equal_to( os.path.join( unicode_dir, '42' ) ) )


# NOTE: Vim returns byte offsets for columns, not actual character columns. This
# makes 'ДД' have 4 columns: column 0, column 2 and column 4.
@patch( 'vim.current.line', ToBytes( 'ДДaa' ) )
@patch( 'ycm.vimsupport.CurrentColumn', side_effect = [ 4 ] )
def TextBeforeCursor_EncodedUnicode_test( *args ):
  eq_( vimsupport.TextBeforeCursor(), u'ДД' )


# NOTE: Vim returns byte offsets for columns, not actual character columns. This
# makes 'ДД' have 4 columns: column 0, column 2 and column 4.
@patch( 'vim.current.line', ToBytes( 'aaДД' ) )
@patch( 'ycm.vimsupport.CurrentColumn', side_effect = [ 2 ] )
def TextAfterCursor_EncodedUnicode_test( *args ):
  eq_( vimsupport.TextAfterCursor(), u'ДД' )


@patch( 'vim.current.line', ToBytes( 'fДa' ) )
def CurrentLineContents_EncodedUnicode_test( *args ):
  eq_( vimsupport.CurrentLineContents(), u'fДa' )


@patch( 'vim.eval', side_effect = lambda x: x )
def VimExpressionToPythonType_IntAsUnicode_test( *args ):
  eq_( vimsupport.VimExpressionToPythonType( '123' ), 123 )


@patch( 'vim.eval', side_effect = lambda x: x )
def VimExpressionToPythonType_IntAsBytes_test( *args ):
  eq_( vimsupport.VimExpressionToPythonType( ToBytes( '123' ) ), 123 )


@patch( 'vim.eval', side_effect = lambda x: x )
def VimExpressionToPythonType_StringAsUnicode_test( *args ):
  eq_( vimsupport.VimExpressionToPythonType( 'foo' ), 'foo' )


@patch( 'vim.eval', side_effect = lambda x: x )
def VimExpressionToPythonType_StringAsBytes_test( *args ):
  eq_( vimsupport.VimExpressionToPythonType( ToBytes( 'foo' ) ), 'foo' )


@patch( 'vim.eval', side_effect = lambda x: x )
def VimExpressionToPythonType_ListPassthrough_test( *args ):
  eq_( vimsupport.VimExpressionToPythonType( [ 1, 2 ] ), [ 1, 2 ] )


@patch( 'vim.eval', side_effect = lambda x: x )
def VimExpressionToPythonType_ObjectPassthrough_test( *args ):
  eq_( vimsupport.VimExpressionToPythonType( { 1: 2 } ), { 1: 2 } )


@patch( 'vim.eval', side_effect = lambda x: x )
def VimExpressionToPythonType_GeneratorPassthrough_test( *args ):
  gen = ( x**2 for x in [ 1, 2, 3 ] )
  eq_( vimsupport.VimExpressionToPythonType( gen ), gen )


@patch( 'vim.eval',
        new_callable = ExtendedMock,
        side_effect = [ None, 2, None ] )
def SelectFromList_LastItem_test( vim_eval ):
  eq_( vimsupport.SelectFromList( 'test', [ 'a', 'b' ] ),
       1 )

  vim_eval.assert_has_exact_calls( [
    call( 'inputsave()' ),
    call( 'inputlist( ["test", "1: a", "2: b"] )' ),
    call( 'inputrestore()' )
  ] )


@patch( 'vim.eval',
        new_callable = ExtendedMock,
        side_effect = [ None, 1, None ] )
def SelectFromList_FirstItem_test( vim_eval ):
  eq_( vimsupport.SelectFromList( 'test', [ 'a', 'b' ] ),
       0 )

  vim_eval.assert_has_exact_calls( [
    call( 'inputsave()' ),
    call( 'inputlist( ["test", "1: a", "2: b"] )' ),
    call( 'inputrestore()' )
  ] )


@patch( 'vim.eval', side_effect = [ None, 3, None ] )
def SelectFromList_OutOfRange_test( vim_eval ):
  assert_that( calling( vimsupport.SelectFromList ).with_args( 'test',
                                                               [ 'a', 'b' ] ),
               raises( RuntimeError, vimsupport.NO_SELECTION_MADE_MSG ) )


@patch( 'vim.eval', side_effect = [ None, 0, None ] )
def SelectFromList_SelectPrompt_test( vim_eval ):
  assert_that( calling( vimsupport.SelectFromList ).with_args( 'test',
                                                             [ 'a', 'b' ] ),
               raises( RuntimeError, vimsupport.NO_SELECTION_MADE_MSG ) )


@patch( 'vim.eval', side_effect = [ None, -199, None ] )
def SelectFromList_Negative_test( vim_eval ):
  assert_that( calling( vimsupport.SelectFromList ).with_args( 'test',
                                                               [ 'a', 'b' ] ),
               raises( RuntimeError, vimsupport.NO_SELECTION_MADE_MSG ) )


def Filetypes_IntegerFiletype_test():
  current_buffer = VimBuffer( 'buffer', number = 1, filetype = '42' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    assert_that( vimsupport.CurrentFiletypes(), contains( '42' ) )
    assert_that( vimsupport.GetBufferFiletypes( 1 ), contains( '42' ) )
    assert_that( vimsupport.FiletypesForBuffer( current_buffer ),
                 contains( '42' ) )


@patch( 'ycm.vimsupport.VariableExists', return_value = False )
@patch( 'ycm.vimsupport.SearchInCurrentBuffer', return_value = 0 )
@patch( 'vim.current' )
def InsertNamespace_insert_test( vim_current, *args ):
  contents = [ '',
               'namespace Taqueria {',
               '',
               '  int taco = Math' ]
  vim_current.buffer = VimBuffer( '', contents = contents )
  vim_current.window.cursor = ( 1, 1 )

  vimsupport.InsertNamespace( 'System' )

  expected_buffer = [ 'using System;',
                      '',
                      'namespace Taqueria {',
                      '',
                      '  int taco = Math' ]
  AssertBuffersAreEqualAsBytes( expected_buffer, vim_current.buffer )


@patch( 'ycm.vimsupport.VariableExists', return_value = False )
@patch( 'ycm.vimsupport.SearchInCurrentBuffer', return_value = 2 )
@patch( 'vim.current' )
def InsertNamespace_append_test( vim_current, *args ):
  contents = [ 'namespace Taqueria {',
               '  using System;',
               '',
               '  class Tasty {',
               '    int taco;',
               '    List salad = new List' ]
  vim_current.buffer = VimBuffer( '', contents = contents )
  vim_current.window.cursor = ( 1, 1 )

  vimsupport.InsertNamespace( 'System.Collections' )

  expected_buffer = [ 'namespace Taqueria {',
                      '  using System;',
                      '  using System.Collections;',
                      '',
                      '  class Tasty {',
                      '    int taco;',
                      '    List salad = new List' ]
  AssertBuffersAreEqualAsBytes( expected_buffer, vim_current.buffer )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_SameFile_SameBuffer_NoSwapFile_test( vim_command ):
  # No 'u' prefix for the current buffer name string to simulate Vim returning
  # bytes on Python 2 but unicode on Python 3.
  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ) as vim:
    vimsupport.JumpToLocation( os.path.realpath( u'uni¢𐍈d€' ),
                               2,
                               5,
                               'aboveleft',
                               'same-buffer' )

    assert_that( vim.current.window.cursor, equal_to( ( 2, 4 ) ) )
    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( 'normal! zz' )
    ] )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_DifferentFile_SameBuffer_Unmodified_test( vim_command ):
  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ) as vim:
    target_name = os.path.realpath( u'different_uni¢𐍈d€' )

    vimsupport.JumpToLocation( target_name, 2, 5, 'belowright', 'same-buffer' )

    assert_that( vim.current.window.cursor, equal_to( ( 2, 4 ) ) )
    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( u'keepjumps belowright edit {0}'.format( target_name ) ),
      call( 'normal! zz' )
    ] )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_DifferentFile_SameBuffer_Modified_CannotHide_test(
    vim_command ):

  current_buffer = VimBuffer( 'uni¢𐍈d€', modified = True )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ) as vim:
    target_name = os.path.realpath( u'different_uni¢𐍈d€' )

    vimsupport.JumpToLocation( target_name, 2, 5, 'botright', 'same-buffer' )

    assert_that( vim.current.window.cursor, equal_to( ( 2, 4 ) ) )
    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( u'keepjumps botright split {0}'.format( target_name ) ),
      call( 'normal! zz' )
    ] )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_DifferentFile_SameBuffer_Modified_CanHide_test(
    vim_command ):

  current_buffer = VimBuffer( 'uni¢𐍈d€', modified = True, bufhidden = "hide" )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ) as vim:
    target_name = os.path.realpath( u'different_uni¢𐍈d€' )

    vimsupport.JumpToLocation( target_name, 2, 5, 'leftabove', 'same-buffer' )

    assert_that( vim.current.window.cursor, equal_to( ( 2, 4 ) ) )
    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( u'keepjumps leftabove edit {0}'.format( target_name ) ),
      call( 'normal! zz' )
    ] )


@patch( 'vim.command',
        side_effect = [ None, VimError( 'Unknown code' ), None ] )
def JumpToLocation_DifferentFile_SameBuffer_SwapFile_Unexpected_test(
    vim_command ):

  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    assert_that(
      calling( vimsupport.JumpToLocation ).with_args(
        os.path.realpath( u'different_uni¢𐍈d€' ),
        2,
        5,
        'rightbelow',
        'same-buffer' ),
      raises( VimError, 'Unknown code' )
    )


@patch( 'vim.command',
        new_callable = ExtendedMock,
        side_effect = [ None, VimError( 'E325' ), None ] )
def JumpToLocation_DifferentFile_SameBuffer_SwapFile_Quit_test( vim_command ):
  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    target_name = os.path.realpath( u'different_uni¢𐍈d€' )

    vimsupport.JumpToLocation( target_name, 2, 5, 'topleft', 'same-buffer' )

    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( u'keepjumps topleft edit {0}'.format( target_name ) )
    ] )


@patch( 'vim.command',
        new_callable = ExtendedMock,
        side_effect = [ None, KeyboardInterrupt, None ] )
def JumpToLocation_DifferentFile_SameBuffer_SwapFile_Abort_test( vim_command ):
  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    target_name = os.path.realpath( u'different_uni¢𐍈d€' )

    vimsupport.JumpToLocation( target_name, 2, 5, 'vertical', 'same-buffer' )

    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( u'keepjumps vertical edit {0}'.format( target_name ) )
    ] )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_DifferentFile_Split_CurrentTab_NotAlreadyOpened_test(
    vim_command ):

  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  current_window = MagicMock( buffer = current_buffer )
  current_tab = MagicMock( windows = [ current_window ] )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ) as vim:
    vim.current.tabpage = current_tab

    target_name = os.path.realpath( u'different_uni¢𐍈d€' )

    vimsupport.JumpToLocation( target_name,
                               2,
                               5,
                               'aboveleft',
                               'split-or-existing-window' )

    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( u'keepjumps aboveleft split {0}'.format( target_name ) ),
      call( 'normal! zz' )
    ] )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_DifferentFile_Split_CurrentTab_AlreadyOpened_test(
    vim_command ):

  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  different_buffer = VimBuffer( 'different_uni¢𐍈d€' )
  current_window = MagicMock( buffer = current_buffer )
  different_window = MagicMock( buffer = different_buffer )
  current_tab = MagicMock( windows = [ current_window, different_window ] )
  with MockVimBuffers( [ current_buffer, different_buffer ],
                       [ current_buffer ] ) as vim:
    vim.current.tabpage = current_tab

    vimsupport.JumpToLocation( os.path.realpath( u'different_uni¢𐍈d€' ),
                               2,
                               5,
                               'belowright',
                               'split-or-existing-window' )

    assert_that( vim.current.tabpage, equal_to( current_tab ) )
    assert_that( vim.current.window, equal_to( different_window ) )
    assert_that( vim.current.window.cursor, equal_to( ( 2, 4 ) ) )
    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( 'normal! zz' )
    ] )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_DifferentFile_Split_AllTabs_NotAlreadyOpened_test(
    vim_command ):

  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    target_name = os.path.realpath( u'different_uni¢𐍈d€' )

    vimsupport.JumpToLocation( target_name,
                               2,
                               5,
                               'tab',
                               'split-or-existing-window' )

    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( u'keepjumps tab split {0}'.format( target_name ) ),
      call( 'normal! zz' )
    ] )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_DifferentFile_Split_AllTabs_AlreadyOpened_test(
    vim_command ):

  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  different_buffer = VimBuffer( 'different_uni¢𐍈d€' )
  current_window = MagicMock( buffer = current_buffer )
  different_window = MagicMock( buffer = different_buffer )
  current_tab = MagicMock( windows = [ current_window, different_window ] )
  with patch( 'vim.tabpages', [ current_tab ] ):
    with MockVimBuffers( [ current_buffer, different_buffer ],
                         [ current_buffer ] ) as vim:
      vimsupport.JumpToLocation( os.path.realpath( u'different_uni¢𐍈d€' ),
                                 2,
                                 5,
                                 'tab',
                                 'split-or-existing-window' )

      assert_that( vim.current.tabpage, equal_to( current_tab ) )
      assert_that( vim.current.window, equal_to( different_window ) )
      assert_that( vim.current.window.cursor, equal_to( ( 2, 4 ) ) )
      vim_command.assert_has_exact_calls( [
        call( 'normal! m\'' ),
        call( 'normal! zz' )
      ] )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_DifferentFile_NewOrExistingTab_NotAlreadyOpened_test(
    vim_command ):

  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    target_name = os.path.realpath( u'different_uni¢𐍈d€' )

    vimsupport.JumpToLocation( target_name,
                               2,
                               5,
                               'aboveleft vertical',
                               'new-or-existing-tab' )

    vim_command.assert_has_exact_calls( [
      call( 'normal! m\'' ),
      call( u'keepjumps aboveleft vertical tabedit {0}'.format( target_name ) ),
      call( 'normal! zz' )
    ] )


@patch( 'vim.command', new_callable = ExtendedMock )
def JumpToLocation_DifferentFile_NewOrExistingTab_AlreadyOpened_test(
    vim_command ):

  current_buffer = VimBuffer( 'uni¢𐍈d€' )
  different_buffer = VimBuffer( 'different_uni¢𐍈d€' )
  current_window = MagicMock( buffer = current_buffer )
  different_window = MagicMock( buffer = different_buffer )
  current_tab = MagicMock( windows = [ current_window, different_window ] )
  with patch( 'vim.tabpages', [ current_tab ] ):
    with MockVimBuffers( [ current_buffer, different_buffer ],
                         [ current_buffer ] ) as vim:
      vimsupport.JumpToLocation( os.path.realpath( u'different_uni¢𐍈d€' ),
                                 2,
                                 5,
                                 'belowright tab',
                                 'new-or-existing-tab' )

      assert_that( vim.current.tabpage, equal_to( current_tab ) )
      assert_that( vim.current.window, equal_to( different_window ) )
      assert_that( vim.current.window.cursor, equal_to( ( 2, 4 ) ) )
      vim_command.assert_has_exact_calls( [
        call( 'normal! m\'' ),
        call( 'normal! zz' )
      ] )


@patch( 'ycm.tests.test_utils.VIM_VERSION', Version( 7, 4, 1578 ) )
def VimVersionAtLeast_test():
  assert_that( vimsupport.VimVersionAtLeast( '7.3.414' ) )
  assert_that( vimsupport.VimVersionAtLeast( '7.4.1578' ) )
  assert_that( not vimsupport.VimVersionAtLeast( '7.4.1579' ) )
  assert_that( not vimsupport.VimVersionAtLeast( '7.4.1898' ) )
  assert_that( not vimsupport.VimVersionAtLeast( '8.1.278' ) )
<EOF>
<BOF>
# Copyright (C) 2011-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from collections import defaultdict, namedtuple
from future.utils import iteritems, PY2
from mock import DEFAULT, MagicMock, patch
from hamcrest import assert_that, equal_to
import contextlib
import functools
import json
import nose
import os
import re
import sys

from ycmd.utils import GetCurrentDirectory, ToBytes, ToUnicode


BUFNR_REGEX = re.compile( '^bufnr\\(\'(?P<buffer_filename>.+)\', ([01])\\)$' )
BUFWINNR_REGEX = re.compile( '^bufwinnr\\((?P<buffer_number>[0-9]+)\\)$' )
BWIPEOUT_REGEX = re.compile(
  '^(?:silent! )bwipeout!? (?P<buffer_number>[0-9]+)$' )
GETBUFVAR_REGEX = re.compile(
  '^getbufvar\\((?P<buffer_number>[0-9]+), "(?P<option>.+)"\\)$' )
MATCHADD_REGEX = re.compile(
  '^matchadd\\(\'(?P<group>.+)\', \'(?P<pattern>.+)\'\\)$' )
MATCHDELETE_REGEX = re.compile( '^matchdelete\\((?P<id>\\d+)\\)$' )
OMNIFUNC_REGEX_FORMAT = (
  '^{omnifunc_name}\\((?P<findstart>[01]),[\'"](?P<base>.*)[\'"]\\)$' )
FNAMEESCAPE_REGEX = re.compile( '^fnameescape\\(\'(?P<filepath>.+)\'\\)$' )
SIGN_LIST_REGEX = re.compile(
  '^silent! sign place buffer=(?P<bufnr>\\d+)$' )
SIGN_PLACE_REGEX = re.compile(
  '^sign place (?P<id>\\d+) name=(?P<name>\\w+) line=(?P<line>\\d+) '
  'buffer=(?P<bufnr>\\d+)$' )
SIGN_UNPLACE_REGEX = re.compile(
  '^sign unplace (?P<id>\\d+) buffer=(?P<bufnr>\\d+)$' )
REDIR_START_REGEX = re.compile( '^redir => (?P<variable>[\\w:]+)$' )
REDIR_END_REGEX = re.compile( '^redir END$' )
EXISTS_REGEX = re.compile( '^exists\\( \'(?P<option>[\\w:]+)\' \\)$' )
LET_REGEX = re.compile( '^let (?P<option>[\\w:]+) = (?P<value>.*)$' )
HAS_PATCH_REGEX = re.compile( '^has\\( \'patch(?P<patch>\\d+)\' \\)$' )

# One-and only instance of mocked Vim object. The first 'import vim' that is
# executed binds the vim module to the instance of MagicMock that is created,
# and subsquent assignments to sys.modules[ 'vim' ] don't retrospectively
# update them. The result is that while running the tests, we must assign only
# one instance of MagicMock to sys.modules[ 'vim' ] and always return it.
#
# More explanation is available:
# https://github.com/Valloric/YouCompleteMe/pull/1694
VIM_MOCK = MagicMock()

VIM_MATCHES_FOR_WINDOW = defaultdict( list )
VIM_SIGNS = []

VIM_OPTIONS = {
  '&previewheight': 12,
  '&columns': 80,
  '&ruler': 0,
  '&showcmd': 1,
  '&hidden': 0,
  '&expandtab': 1
}

# This variable must be patched with a Version object for tests depending on the
# Vim version. Example:
#
#   @patch( 'ycm.tests.test_utils.VIM_VERSION', Version( 7, 4, 1578 ) )
#   def ThisTestDependsOnTheVimVersion_test():
#     ...
#
VIM_VERSION = None

REDIR = {
  'status': False,
  'variable': '',
  'output': ''
}


Version = namedtuple( 'Version', [ 'major', 'minor', 'patch' ] )


@contextlib.contextmanager
def CurrentWorkingDirectory( path ):
  old_cwd = GetCurrentDirectory()
  os.chdir( path )
  try:
    yield
  finally:
    os.chdir( old_cwd )


def _MockGetBufferNumber( buffer_filename ):
  for vim_buffer in VIM_MOCK.buffers:
    if vim_buffer.name == buffer_filename:
      return vim_buffer.number
  return -1


def _MockGetBufferWindowNumber( buffer_number ):
  for window in VIM_MOCK.windows:
    if window.buffer.number == buffer_number:
      return window.number
  return -1


def _MockGetBufferVariable( buffer_number, option ):
  for vim_buffer in VIM_MOCK.buffers:
    if vim_buffer.number == buffer_number:
      if option == '&mod':
        return vim_buffer.modified
      if option == '&ft':
        return vim_buffer.filetype
      if option == 'changedtick':
        return vim_buffer.changedtick
      if option == '&bh':
        return vim_buffer.bufhidden
      return ''
  return ''


def _MockVimBufferEval( value ):
  if value == '&omnifunc':
    return VIM_MOCK.current.buffer.omnifunc_name

  if value == '&filetype':
    return VIM_MOCK.current.buffer.filetype

  match = BUFNR_REGEX.search( value )
  if match:
    buffer_filename = match.group( 'buffer_filename' )
    return _MockGetBufferNumber( buffer_filename )

  match = BUFWINNR_REGEX.search( value )
  if match:
    buffer_number = int( match.group( 'buffer_number' ) )
    return _MockGetBufferWindowNumber( buffer_number )

  match = GETBUFVAR_REGEX.search( value )
  if match:
    buffer_number = int( match.group( 'buffer_number' ) )
    option = match.group( 'option' )
    return _MockGetBufferVariable( buffer_number, option )

  current_buffer = VIM_MOCK.current.buffer
  match = re.search( OMNIFUNC_REGEX_FORMAT.format(
                         omnifunc_name = current_buffer.omnifunc_name ),
                     value )
  if match:
    findstart = int( match.group( 'findstart' ) )
    base = match.group( 'base' )
    value = current_buffer.omnifunc( findstart, base )
    return value if findstart else ToBytesOnPY2( value )

  return None


def _MockVimWindowEval( value ):
  if value == 'winnr("#")':
    # For simplicity, we always assume there is no previous window.
    return 0

  return None


def _MockVimOptionsEval( value ):
  result = VIM_OPTIONS.get( value )
  if result is not None:
    return result

  if value == 'keys( g: )':
    global_options = {}
    for key, value in iteritems( VIM_OPTIONS ):
      if key.startswith( 'g:' ):
        global_options[ key[ 2: ] ] = value
    return global_options

  match = EXISTS_REGEX.search( value )
  if match:
    option = match.group( 'option' )
    return option in VIM_OPTIONS

  return None


def _MockVimFunctionsEval( value ):
  if value == 'tempname()':
    return '_TEMP_FILE_'

  if value == 'tagfiles()':
    return [ 'tags' ]

  if value == 'shiftwidth()':
    return 2

  return None


def _MockVimMatchEval( value ):
  current_window = VIM_MOCK.current.window.number

  if value == 'getmatches()':
    return VIM_MATCHES_FOR_WINDOW[ current_window ]

  match = MATCHADD_REGEX.search( value )
  if match:
    group = match.group( 'group' )
    option = match.group( 'pattern' )
    vim_match = VimMatch( group, option )
    VIM_MATCHES_FOR_WINDOW[ current_window ].append( vim_match )
    return vim_match.id

  match = MATCHDELETE_REGEX.search( value )
  if match:
    match_id = int( match.group( 'id' ) )
    vim_matches = VIM_MATCHES_FOR_WINDOW[ current_window ]
    for index, vim_match in enumerate( vim_matches ):
      if vim_match.id == match_id:
        vim_matches.pop( index )
        return -1
    return 0

  return None


def _MockVimVersionEval( value ):
  match = HAS_PATCH_REGEX.search( value )
  if match:
    if not isinstance( VIM_VERSION, Version ):
      raise RuntimeError( 'Vim version is not set.' )
    return VIM_VERSION.patch >= int( match.group( 'patch' ) )

  if value == 'v:version':
    if not isinstance( VIM_VERSION, Version ):
      raise RuntimeError( 'Vim version is not set.' )
    return VIM_VERSION.major * 100 + VIM_VERSION.minor

  return None


def _MockVimEval( value ):
  result = _MockVimOptionsEval( value )
  if result is not None:
    return result

  result = _MockVimFunctionsEval( value )
  if result is not None:
    return result

  result = _MockVimBufferEval( value )
  if result is not None:
    return result

  result = _MockVimWindowEval( value )
  if result is not None:
    return result

  result = _MockVimMatchEval( value )
  if result is not None:
    return result

  result = _MockVimVersionEval( value )
  if result is not None:
    return result

  match = FNAMEESCAPE_REGEX.search( value )
  if match:
    return match.group( 'filepath' )

  if value == REDIR[ 'variable' ]:
    return REDIR[ 'output' ]

  raise VimError( 'Unexpected evaluation: {0}'.format( value ) )


def _MockWipeoutBuffer( buffer_number ):
  buffers = VIM_MOCK.buffers

  for index, buffer in enumerate( buffers ):
    if buffer.number == buffer_number:
      return buffers.pop( index )


def _MockSignCommand( command ):
  match = SIGN_LIST_REGEX.search( command )
  if match and REDIR[ 'status' ]:
    bufnr = int( match.group( 'bufnr' ) )
    REDIR[ 'output' ] = ( '--- Signs ---\n'
                          'Signs for foo:\n' )
    for sign in VIM_SIGNS:
      if sign.bufnr == bufnr:
        REDIR[ 'output' ] += (
          '    line={0}  id={1}  name={2}'.format( sign.line,
                                                   sign.id,
                                                   sign.name ) )
    return True

  match = SIGN_PLACE_REGEX.search( command )
  if match:
    VIM_SIGNS.append( VimSign( int( match.group( 'id' ) ),
                               int( match.group( 'line' ) ),
                               match.group( 'name' ),
                               int( match.group( 'bufnr' ) ) ) )
    return True

  match = SIGN_UNPLACE_REGEX.search( command )
  if match:
    sign_id = int( match.group( 'id' ) )
    bufnr = int( match.group( 'bufnr' ) )
    for sign in VIM_SIGNS:
      if sign.id == sign_id and sign.bufnr == bufnr:
        VIM_SIGNS.remove( sign )
        return True

  return False


def _MockVimCommand( command ):
  match = BWIPEOUT_REGEX.search( command )
  if match:
    return _MockWipeoutBuffer( int( match.group( 1 ) ) )

  match = REDIR_START_REGEX.search( command )
  if match:
    REDIR[ 'status' ] = True
    REDIR[ 'variable' ] = match.group( 'variable' )
    return

  match = REDIR_END_REGEX.search( command )
  if match:
    REDIR[ 'status' ] = False
    return

  if command == 'unlet ' + REDIR[ 'variable' ]:
    REDIR[ 'variable' ] = ''
    return

  result = _MockSignCommand( command )
  if result:
    return

  match = LET_REGEX.search( command )
  if match:
    option = match.group( 'option' )
    value = json.loads( match.group( 'value' ) )
    VIM_OPTIONS[ option ] = value
    return

  return DEFAULT


class VimBuffer( object ):
  """An object that looks like a vim.buffer object:
   - |name|     : full path of the buffer with symbolic links resolved;
   - |number|   : buffer number;
   - |contents| : list of lines representing the buffer contents;
   - |filetype| : buffer filetype. Empty string if no filetype is set;
   - |modified| : True if the buffer has unsaved changes, False otherwise;
   - |bufhidden|: value of the 'bufhidden' option (see :h bufhidden);
   - |omnifunc| : omni completion function used by the buffer. Must be a Python
                  function that takes the same arguments and returns the same
                  values as a Vim completion function (:h complete-functions).
                  Example:

                    def Omnifunc( findstart, base ):
                      if findstart:
                        return 5
                      return [ 'a', 'b', 'c' ]"""

  def __init__( self, name,
                      number = 1,
                      contents = [ '' ],
                      filetype = '',
                      modified = False,
                      bufhidden = '',
                      omnifunc = None,
                      visual_start = None,
                      visual_end = None ):
    self.name = os.path.realpath( name ) if name else ''
    self.number = number
    self.contents = contents
    self.filetype = filetype
    self.modified = modified
    self.bufhidden = bufhidden
    self.omnifunc = omnifunc
    self.omnifunc_name = omnifunc.__name__ if omnifunc else ''
    self.changedtick = 1
    self.options = {
     'mod': modified,
     'bh': bufhidden
    }
    self.visual_start = visual_start
    self.visual_end = visual_end


  def __getitem__( self, index ):
    """Returns the bytes for a given line at index |index|."""
    return self.contents[ index ]


  def __len__( self ):
    return len( self.contents )


  def __setitem__( self, key, value ):
    return self.contents.__setitem__( key, value )


  def GetLines( self ):
    """Returns the contents of the buffer as a list of unicode strings."""
    return [ ToUnicode( x ) for x in self.contents ]


  def mark( self, name ):
    if name == '<':
      return self.visual_start
    if name == '>':
      return self.visual_end
    raise ValueError( 'Unexpected mark: {name}'.format( name = name ) )


class VimBuffers( object ):
  """An object that looks like a vim.buffers object."""

  def __init__( self, buffers ):
    """|buffers| is a list of VimBuffer objects."""
    self._buffers = buffers


  def __getitem__( self, number ):
    """Emulates vim.buffers[ number ]"""
    for buffer_object in self._buffers:
      if number == buffer_object.number:
        return buffer_object
    raise KeyError( number )


  def __iter__( self ):
    """Emulates for loop on vim.buffers"""
    return iter( self._buffers )


  def pop( self, index ):
    return self._buffers.pop( index )


class VimWindow( object ):
  """An object that looks like a vim.window object:
    - |number|: number of the window;
    - |buffer_object|: a VimBuffer object representing the buffer inside the
      window;
    - |cursor|: a tuple corresponding to the cursor position."""

  def __init__( self, number, buffer_object, cursor = None ):
    self.number = number
    self.buffer = buffer_object
    self.cursor = cursor
    self.options = {}


class VimWindows( object ):
  """An object that looks like a vim.windows object."""

  def __init__( self, buffers, cursor ):
    """|buffers| is a list of VimBuffer objects corresponding to the window
    layout. The first element of that list is assumed to be the current window.
    |cursor| is the cursor position of that window."""
    windows = []
    windows.append( VimWindow( 1, buffers[ 0 ], cursor ) )
    for window_number in range( 1, len( buffers ) ):
      windows.append( VimWindow( window_number + 1, buffers[ window_number ] ) )
    self._windows = windows


  def __getitem__( self, number ):
    """Emulates vim.windows[ number ]"""
    try:
      return self._windows[ number ]
    except IndexError:
      raise IndexError( 'no such window' )


  def __iter__( self ):
    """Emulates for loop on vim.windows"""
    return iter( self._windows )


class VimCurrent( object ):
  """An object that looks like a vim.current object. |current_window| must be a
  VimWindow object."""

  def __init__( self, current_window ):
    self.buffer = current_window.buffer
    self.window = current_window
    self.line = self.buffer.contents[ current_window.cursor[ 0 ] - 1 ]


class VimMatch( object ):

  def __init__( self, group, pattern ):
    current_window = VIM_MOCK.current.window.number
    self.id = len( VIM_MATCHES_FOR_WINDOW[ current_window ] ) + 1
    self.group = group
    self.pattern = pattern


  def __eq__( self, other ):
    return self.group == other.group and self.pattern == other.pattern


  def __repr__( self ):
    return "VimMatch( group = '{0}', pattern = '{1}' )".format( self.group,
                                                                self.pattern )


  def __getitem__( self, key ):
    if key == 'group':
      return self.group
    elif key == 'id':
      return self.id


class VimSign( object ):

  def __init__( self, sign_id, line, name, bufnr ):
    self.id = sign_id
    self.line = line
    self.name = name
    self.bufnr = bufnr


  def __eq__( self, other ):
    return ( self.id == other.id and
             self.line == other.line and
             self.name == other.name and
             self.bufnr == other.bufnr )


  def __repr__( self ):
    return ( "VimSign( id = {0}, line = {1}, "
                      "name = '{2}', bufnr = {3} )".format( self.id,
                                                            self.line,
                                                            self.name,
                                                            self.bufnr ) )


  def __getitem__( self, key ):
    if key == 'group':
      return self.group
    elif key == 'id':
      return self.id


@contextlib.contextmanager
def MockVimBuffers( buffers, window_buffers, cursor_position = ( 1, 1 ) ):
  """Simulates the Vim buffers list |buffers| where |current_buffer| is the
  buffer displayed in the current window and |cursor_position| is the current
  cursor position. All buffers are represented by a VimBuffer object."""
  if ( not isinstance( buffers, list ) or
       not all( isinstance( buf, VimBuffer ) for buf in buffers ) ):
    raise RuntimeError( 'First parameter must be a list of VimBuffer objects.' )
  if ( not isinstance( window_buffers, list ) or
       not all( isinstance( buf, VimBuffer ) for buf in window_buffers ) ):
    raise RuntimeError( 'Second parameter must be a list of VimBuffer objects '
                        'representing the window layout.' )
  if len( window_buffers ) < 1:
    raise RuntimeError( 'Second parameter must contain at least one element '
                        'which corresponds to the current window.' )

  with patch( 'vim.buffers', VimBuffers( buffers ) ):
    with patch( 'vim.windows', VimWindows( window_buffers,
                                           cursor_position ) ) as windows:
      with patch( 'vim.current', VimCurrent( windows[ 0 ] ) ):
        yield VIM_MOCK


def MockVimModule():
  """The 'vim' module is something that is only present when running inside the
  Vim Python interpreter, so we replace it with a MagicMock for tests. If you
  need to add additional mocks to vim module functions, then use 'patch' from
  mock module, to ensure that the state of the vim mock is returned before the
  next test. That is:

    from ycm.tests.test_utils import MockVimModule
    from mock import patch

    # Do this once
    MockVimModule()

    @patch( 'vim.eval', return_value='test' )
    @patch( 'vim.command', side_effect=ValueError )
    def test( vim_command, vim_eval ):
      # use vim.command via vim_command, e.g.:
      vim_command.assert_has_calls( ... )

  Failure to use this approach may lead to unexpected failures in other
  tests."""

  VIM_MOCK.command = MagicMock( side_effect = _MockVimCommand )
  VIM_MOCK.eval = MagicMock( side_effect = _MockVimEval )
  VIM_MOCK.error = VimError
  sys.modules[ 'vim' ] = VIM_MOCK

  return VIM_MOCK


class VimError( Exception ):

  def __init__( self, code ):
    self.code = code


  def __str__( self ):
    return repr( self.code )


class ExtendedMock( MagicMock ):
  """An extension to the MagicMock class which adds the ability to check that a
  callable is called with a precise set of calls in a precise order.

  Example Usage:
    from ycm.tests.test_utils import ExtendedMock
    @patch( 'test.testing', new_callable = ExtendedMock, ... )
    def my_test( test_testing ):
      ...
  """

  def assert_has_exact_calls( self, calls, any_order = False ):
    self.assert_has_calls( calls, any_order )
    assert_that( self.call_count, equal_to( len( calls ) ) )


def ExpectedFailure( reason, *exception_matchers ):
  """Defines a decorator to be attached to tests. This decorator
  marks the test as being known to fail, e.g. where documenting or exercising
  known incorrect behaviour.

  The parameters are:
    - |reason| a textual description of the reason for the known issue. This
               is used for the skip reason
    - |exception_matchers| additional arguments are hamcrest matchers to apply
                 to the exception thrown. If the matchers don't match, then the
                 test is marked as error, with the original exception.

  If the test fails (for the correct reason), then it is marked as skipped.
  If it fails for any other reason, it is marked as failed.
  If the test passes, then it is also marked as failed."""
  def decorator( test ):
    @functools.wraps( test )
    def Wrapper( *args, **kwargs ):
      try:
        test( *args, **kwargs )
      except Exception as test_exception:
        # Ensure that we failed for the right reason
        test_exception_message = ToUnicode( test_exception )
        try:
          for matcher in exception_matchers:
            assert_that( test_exception_message, matcher )
        except AssertionError:
          # Failed for the wrong reason!
          import traceback
          print( 'Test failed for the wrong reason: ' + traceback.format_exc() )
          # Real failure reason is the *original* exception, we're only trapping
          # and ignoring the exception that is expected.
          raise test_exception

        # Failed for the right reason
        raise nose.SkipTest( reason )
      else:
        raise AssertionError( 'Test was expected to fail: {0}'.format(
          reason ) )
    return Wrapper

  return decorator


def ToBytesOnPY2( data ):
  # To test the omnifunc, etc. returning strings, which can be of different
  # types depending on python version, we use ToBytes on PY2 and just the native
  # str on python3. This roughly matches what happens between py2 and py3
  # versions within Vim.
  if not PY2:
    return data

  if isinstance( data, list ):
    return [ ToBytesOnPY2( item ) for item in data ]
  if isinstance( data, dict ):
    for item in data:
      data[ item ] = ToBytesOnPY2( data[ item ] )
    return data
  return ToBytes( data )
<EOF>
<BOF>
# Copyright (C) 2016-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import ( ExtendedMock, MockVimBuffers, MockVimModule,
                                   VimBuffer, VimMatch, VimSign )
MockVimModule()

import os
import sys
from hamcrest import ( assert_that, contains, empty, equal_to, has_entries,
                       is_in, is_not, matches_regexp )
from mock import call, MagicMock, patch

from ycm.paths import _PathToPythonUsedDuringBuild
from ycm.vimsupport import SetVariableValue, SIGN_BUFFER_ID_INITIAL_VALUE
from ycm.tests import ( StopServer, test_utils, UserOptions, WaitUntilReady,
                        YouCompleteMeInstance )
from ycm.client.base_request import _LoadExtraConfFile
from ycm.youcompleteme import YouCompleteMe
from ycmd.responses import ServerError
from ycm.tests.mock_utils import ( MockAsyncServerResponseDone,
                                   MockAsyncServerResponseInProgress,
                                   MockAsyncServerResponseException )


from ycm import buffer as ycm_buffer_module


@YouCompleteMeInstance()
def YouCompleteMe_YcmCoreNotImported_test( ycm ):
  assert_that( 'ycm_core', is_not( is_in( sys.modules ) ) )


@patch( 'ycm.vimsupport.PostVimMessage' )
def YouCompleteMe_InvalidPythonInterpreterPath_test( post_vim_message ):
  with UserOptions( {
    'g:ycm_server_python_interpreter': '/invalid/python/path' } ):
    try:
      ycm = YouCompleteMe()

      assert_that( ycm.IsServerAlive(), equal_to( False ) )
      post_vim_message.assert_called_once_with(
        "Unable to start the ycmd server. "
        "Path in 'g:ycm_server_python_interpreter' option does not point "
        "to a valid Python 2.7 or 3.4+. "
        "Correct the error then restart the server with ':YcmRestartServer'." )

      post_vim_message.reset_mock()

      SetVariableValue( 'g:ycm_server_python_interpreter',
                        _PathToPythonUsedDuringBuild() )
      ycm.RestartServer()

      assert_that( ycm.IsServerAlive(), equal_to( True ) )
      post_vim_message.assert_called_once_with( 'Restarting ycmd server...' )
    finally:
      WaitUntilReady()
      StopServer( ycm )


@patch( 'ycmd.utils.PathToFirstExistingExecutable', return_value = None )
@patch( 'ycm.paths._EndsWithPython', return_value = False )
@patch( 'ycm.vimsupport.PostVimMessage' )
def YouCompleteMe_NoPythonInterpreterFound_test( post_vim_message, *args ):
  with UserOptions( {} ):
    try:
      with patch( 'ycmd.utils.ReadFile', side_effect = IOError ):
        ycm = YouCompleteMe()

      assert_that( ycm.IsServerAlive(), equal_to( False ) )
      post_vim_message.assert_called_once_with(
        "Unable to start the ycmd server. Cannot find Python 2.7 or 3.4+. "
        "Set the 'g:ycm_server_python_interpreter' option to a Python "
        "interpreter path. "
        "Correct the error then restart the server with ':YcmRestartServer'." )

      post_vim_message.reset_mock()

      SetVariableValue( 'g:ycm_server_python_interpreter',
                        _PathToPythonUsedDuringBuild() )
      ycm.RestartServer()

      assert_that( ycm.IsServerAlive(), equal_to( True ) )
      post_vim_message.assert_called_once_with( 'Restarting ycmd server...' )
    finally:
      WaitUntilReady()
      StopServer( ycm )


@YouCompleteMeInstance()
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def RunNotifyUserIfServerCrashed( ycm, test, post_vim_message ):
  StopServer( ycm )

  ycm._logger = MagicMock( autospec = True )
  ycm._server_popen = MagicMock( autospec = True )
  ycm._server_popen.poll.return_value = test[ 'return_code' ]

  ycm.OnFileReadyToParse()

  assert_that( ycm._logger.error.call_args[ 0 ][ 0 ],
               test[ 'expected_message' ] )
  assert_that( post_vim_message.call_args[ 0 ][ 0 ],
               test[ 'expected_message' ] )


def YouCompleteMe_NotifyUserIfServerCrashed_UnexpectedCore_test():
  message = (
    "The ycmd server SHUT DOWN \\(restart with ':YcmRestartServer'\\). "
    "Unexpected error while loading the YCM core library. Type "
    "':YcmToggleLogs ycmd_\\d+_stderr_.+.log' to check the logs." )
  RunNotifyUserIfServerCrashed( {
    'return_code': 3,
    'expected_message': matches_regexp( message )
  } )


def YouCompleteMe_NotifyUserIfServerCrashed_MissingCore_test():
  message = ( "The ycmd server SHUT DOWN (restart with ':YcmRestartServer'). "
              "YCM core library not detected; you need to compile YCM before "
              "using it. Follow the instructions in the documentation." )
  RunNotifyUserIfServerCrashed( {
    'return_code': 4,
    'expected_message': equal_to( message )
  } )


def YouCompleteMe_NotifyUserIfServerCrashed_Python2Core_test():
  message = ( "The ycmd server SHUT DOWN (restart with ':YcmRestartServer'). "
              "YCM core library compiled for Python 2 but loaded in Python 3. "
              "Set the 'g:ycm_server_python_interpreter' option to a Python 2 "
              "interpreter path." )
  RunNotifyUserIfServerCrashed( {
    'return_code': 5,
    'expected_message': equal_to( message )
  } )


def YouCompleteMe_NotifyUserIfServerCrashed_Python3Core_test():
  message = ( "The ycmd server SHUT DOWN (restart with ':YcmRestartServer'). "
              "YCM core library compiled for Python 3 but loaded in Python 2. "
              "Set the 'g:ycm_server_python_interpreter' option to a Python 3 "
              "interpreter path." )
  RunNotifyUserIfServerCrashed( {
    'return_code': 6,
    'expected_message': equal_to( message )
  } )


def YouCompleteMe_NotifyUserIfServerCrashed_OutdatedCore_test():
  message = ( "The ycmd server SHUT DOWN (restart with ':YcmRestartServer'). "
              "YCM core library too old; PLEASE RECOMPILE by running the "
              "install.py script. See the documentation for more details." )
  RunNotifyUserIfServerCrashed( {
    'return_code': 7,
    'expected_message': equal_to( message )
  } )


def YouCompleteMe_NotifyUserIfServerCrashed_UnexpectedExitCode_test():
  message = (
    "The ycmd server SHUT DOWN \\(restart with ':YcmRestartServer'\\). "
    "Unexpected exit code 1. Type "
    "':YcmToggleLogs ycmd_\\d+_stderr_.+.log' to check the logs." )
  RunNotifyUserIfServerCrashed( {
    'return_code': 1,
    'expected_message': matches_regexp( message )
  } )


@YouCompleteMeInstance( { 'g:ycm_extra_conf_vim_data': [ 'tempname()' ] } )
def YouCompleteMe_DebugInfo_ServerRunning_test( ycm ):
  dir_of_script = os.path.dirname( os.path.abspath( __file__ ) )
  buf_name = os.path.join( dir_of_script, 'testdata', 'test.cpp' )
  extra_conf = os.path.join( dir_of_script, 'testdata', '.ycm_extra_conf.py' )
  _LoadExtraConfFile( extra_conf )

  current_buffer = VimBuffer( buf_name, filetype = 'cpp' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    assert_that(
      ycm.DebugInfo(),
      matches_regexp(
        'Client logfile: .+\n'
        'Server Python interpreter: .+\n'
        'Server Python version: .+\n'
        'Server has Clang support compiled in: '
        '(?P<CLANG>True)?(?(CLANG)|False)\n'
        'Clang version: .+\n'
        'Extra configuration file found and loaded\n'
        'Extra configuration path: .*testdata[/\\\\]\\.ycm_extra_conf\\.py\n'
        '(?(CLANG)C-family completer debug information:\n'
        '  Compilation database path: None\n'
        '  Flags: \\[u?\'_TEMP_FILE_\'.*\\]\n'
        '  Translation unit: .+\n)'
        'Server running at: .+\n'
        'Server process ID: \\d+\n'
        'Server logfiles:\n'
        '  .+\n'
        '  .+' )
    )


@YouCompleteMeInstance()
def YouCompleteMe_DebugInfo_ServerNotRunning_test( ycm ):
  StopServer( ycm )

  current_buffer = VimBuffer( 'current_buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    assert_that(
      ycm.DebugInfo(),
      matches_regexp(
        'Client logfile: .+\n'
        'Server errored, no debug info from server\n'
        'Server running at: .+\n'
        'Server process ID: \\d+\n'
        'Server logfiles:\n'
        '  .+\n'
        '  .+' )
    )


@YouCompleteMeInstance()
def YouCompleteMe_OnVimLeave_RemoveClientLogfileByDefault_test( ycm ):
  client_logfile = ycm._client_logfile
  assert_that( os.path.isfile( client_logfile ),
               'Logfile {0} does not exist.'.format( client_logfile ) )
  ycm.OnVimLeave()
  assert_that( not os.path.isfile( client_logfile ),
               'Logfile {0} was not removed.'.format( client_logfile ) )


@YouCompleteMeInstance( { 'g:ycm_keep_logfiles': 1 } )
def YouCompleteMe_OnVimLeave_KeepClientLogfile_test( ycm ):
  client_logfile = ycm._client_logfile
  assert_that( os.path.isfile( client_logfile ),
               'Logfile {0} does not exist.'.format( client_logfile ) )
  ycm.OnVimLeave()
  assert_that( os.path.isfile( client_logfile ),
               'Logfile {0} was removed.'.format( client_logfile ) )


@YouCompleteMeInstance()
@patch( 'ycm.vimsupport.CloseBuffersForFilename', new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.OpenFilename', new_callable = ExtendedMock )
def YouCompleteMe_ToggleLogs_WithParameters_test( ycm,
                                                  open_filename,
                                                  close_buffers_for_filename ):
  logfile_buffer = VimBuffer( ycm._client_logfile )
  with MockVimBuffers( [ logfile_buffer ], [ logfile_buffer ] ):
    ycm.ToggleLogs( os.path.basename( ycm._client_logfile ),
                    'nonexisting_logfile',
                    os.path.basename( ycm._server_stdout ) )

    open_filename.assert_has_exact_calls( [
      call( ycm._server_stdout, { 'size': 12,
                                  'watch': True,
                                  'fix': True,
                                  'focus': False,
                                  'position': 'end' } )
    ] )
    close_buffers_for_filename.assert_has_exact_calls( [
      call( ycm._client_logfile )
    ] )


@YouCompleteMeInstance()
# Select the second item of the list which is the ycmd stderr logfile.
@patch( 'ycm.vimsupport.SelectFromList', return_value = 1 )
@patch( 'ycm.vimsupport.OpenFilename', new_callable = ExtendedMock )
def YouCompleteMe_ToggleLogs_WithoutParameters_SelectLogfileNotAlreadyOpen_test(
  ycm, open_filename, *args ):

  current_buffer = VimBuffer( 'current_buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    ycm.ToggleLogs()

  open_filename.assert_has_exact_calls( [
    call( ycm._server_stderr, { 'size': 12,
                                'watch': True,
                                'fix': True,
                                'focus': False,
                                'position': 'end' } )
  ] )


@YouCompleteMeInstance()
# Select the third item of the list which is the ycmd stdout logfile.
@patch( 'ycm.vimsupport.SelectFromList', return_value = 2 )
@patch( 'ycm.vimsupport.CloseBuffersForFilename', new_callable = ExtendedMock )
def YouCompleteMe_ToggleLogs_WithoutParameters_SelectLogfileAlreadyOpen_test(
  ycm, close_buffers_for_filename, *args ):

  logfile_buffer = VimBuffer( ycm._server_stdout )
  with MockVimBuffers( [ logfile_buffer ], [ logfile_buffer ] ):
    ycm.ToggleLogs()

  close_buffers_for_filename.assert_has_exact_calls( [
    call( ycm._server_stdout )
  ] )


@YouCompleteMeInstance()
@patch( 'ycm.vimsupport.SelectFromList',
        side_effect = RuntimeError( 'Error message' ) )
@patch( 'ycm.vimsupport.PostVimMessage' )
def YouCompleteMe_ToggleLogs_WithoutParameters_NoSelection_test(
  ycm, post_vim_message, *args ):

  current_buffer = VimBuffer( 'current_buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    ycm.ToggleLogs()

  assert_that(
    # Argument passed to PostVimMessage.
    post_vim_message.call_args[ 0 ][ 0 ],
    equal_to( 'Error message' )
  )


@YouCompleteMeInstance()
def YouCompleteMe_GetDefinedSubcommands_ListFromServer_test( ycm ):
  current_buffer = VimBuffer( 'buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.client.base_request._JsonFromFuture',
                return_value = [ 'SomeCommand', 'AnotherCommand' ] ):
      assert_that(
        ycm.GetDefinedSubcommands(),
        contains(
          'SomeCommand',
          'AnotherCommand'
        )
      )


@YouCompleteMeInstance()
@patch( 'ycm.client.base_request._logger', autospec = True )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def YouCompleteMe_GetDefinedSubcommands_ErrorFromServer_test( ycm,
                                                              post_vim_message,
                                                              logger ):
  current_buffer = VimBuffer( 'buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.client.base_request._JsonFromFuture',
                side_effect = ServerError( 'Server error' ) ):
      result = ycm.GetDefinedSubcommands()

  logger.exception.assert_called_with( 'Error while handling server response' )
  post_vim_message.assert_has_exact_calls( [
    call( 'Server error', truncate = False )
  ] )
  assert_that( result, empty() )


@YouCompleteMeInstance()
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def YouCompleteMe_ShowDetailedDiagnostic_MessageFromServer_test(
  ycm, post_vim_message ):

  current_buffer = VimBuffer( 'buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.client.base_request._JsonFromFuture',
                return_value = { 'message': 'some_detailed_diagnostic' } ):
      ycm.ShowDetailedDiagnostic(),

  post_vim_message.assert_has_exact_calls( [
    call( 'some_detailed_diagnostic', warning = False )
  ] )


@YouCompleteMeInstance()
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def YouCompleteMe_ShowDetailedDiagnostic_Exception_test(
  ycm, post_vim_message ):

  current_buffer = VimBuffer( 'buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.client.base_request._JsonFromFuture',
                side_effect = RuntimeError( 'Some exception' ) ):
      ycm.ShowDetailedDiagnostic(),

  post_vim_message.assert_has_exact_calls( [
    call( 'Some exception', truncate = False )
  ] )


@YouCompleteMeInstance()
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def YouCompleteMe_ShowDiagnostics_FiletypeNotSupported_test( ycm,
                                                             post_vim_message ):

  current_buffer = VimBuffer( 'buffer', filetype = 'not_supported' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    ycm.ShowDiagnostics()

  post_vim_message.assert_called_once_with(
    'Native filetype completion not supported for current file, '
    'cannot force recompilation.', warning = False )


@YouCompleteMeInstance()
@patch( 'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = True )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.SetLocationListForWindow', new_callable = ExtendedMock )
def YouCompleteMe_ShowDiagnostics_NoDiagnosticsDetected_test(
  ycm, set_location_list_for_window, post_vim_message, *args ):

  current_buffer = VimBuffer( 'buffer', filetype = 'cpp' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.client.event_notification.EventNotification.Response',
                return_value = {} ):
      ycm.ShowDiagnostics()

  post_vim_message.assert_has_exact_calls( [
    call( 'Forcing compilation, this will block Vim until done.',
          warning = False ),
    call( 'Diagnostics refreshed', warning = False ),
    call( 'No warnings or errors detected.', warning = False )
  ] )
  set_location_list_for_window.assert_called_once_with( 1, [] )


@YouCompleteMeInstance( { 'g:ycm_log_level': 'debug',
                          'g:ycm_keep_logfiles': 1,
                          'g:ycm_open_loclist_on_ycm_diags': 0 } )
@patch( 'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = True )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.SetLocationListForWindow', new_callable = ExtendedMock )
def YouCompleteMe_ShowDiagnostics_DiagnosticsFound_DoNotOpenLocationList_test(
  ycm, set_location_list_for_window, post_vim_message, *args ):

  diagnostic = {
    'kind': 'ERROR',
    'text': 'error text',
    'location': {
      'filepath': 'buffer',
      'line_num': 19,
      'column_num': 2
    }
  }

  current_buffer = VimBuffer( 'buffer',
                              filetype = 'cpp',
                              number = 3 )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.client.event_notification.EventNotification.Response',
                return_value = [ diagnostic ] ):
      ycm.ShowDiagnostics()

  post_vim_message.assert_has_exact_calls( [
    call( 'Forcing compilation, this will block Vim until done.',
          warning = False ),
    call( 'Diagnostics refreshed', warning = False )
  ] )
  set_location_list_for_window.assert_called_once_with( 1, [ {
      'bufnr': 3,
      'lnum': 19,
      'col': 2,
      'text': 'error text',
      'type': 'E',
      'valid': 1
  } ] )


@YouCompleteMeInstance( { 'g:ycm_open_loclist_on_ycm_diags': 1 } )
@patch( 'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = True )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.SetLocationListForWindow', new_callable = ExtendedMock )
@patch( 'ycm.vimsupport.OpenLocationList', new_callable = ExtendedMock )
def YouCompleteMe_ShowDiagnostics_DiagnosticsFound_OpenLocationList_test(
  ycm,
  open_location_list,
  set_location_list_for_window,
  post_vim_message,
  *args ):

  diagnostic = {
    'kind': 'ERROR',
    'text': 'error text',
    'location': {
      'filepath': 'buffer',
      'line_num': 19,
      'column_num': 2
    }
  }

  current_buffer = VimBuffer( 'buffer',
                              filetype = 'cpp',
                              number = 3 )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    with patch( 'ycm.client.event_notification.EventNotification.Response',
                return_value = [ diagnostic ] ):
      ycm.ShowDiagnostics()

  post_vim_message.assert_has_exact_calls( [
    call( 'Forcing compilation, this will block Vim until done.',
          warning = False ),
    call( 'Diagnostics refreshed', warning = False )
  ] )
  set_location_list_for_window.assert_called_once_with( 1, [ {
      'bufnr': 3,
      'lnum': 19,
      'col': 2,
      'text': 'error text',
      'type': 'E',
      'valid': 1
  } ] )
  open_location_list.assert_called_once_with( focus = True )


@YouCompleteMeInstance( { 'g:ycm_echo_current_diagnostic': 1,
                          'g:ycm_enable_diagnostic_signs': 1,
                          'g:ycm_enable_diagnostic_highlighting': 1 } )
@patch( 'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = True )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def YouCompleteMe_UpdateDiagnosticInterface_PrioritizeErrorsOverWarnings_test(
  ycm, post_vim_message, *args ):

  contents = """int main() {
  int x, y;
  x == y
}"""

  # List of diagnostics returned by ycmd for the above code.
  diagnostics = [ {
    'kind': 'ERROR',
    'text': "expected ';' after expression",
    'location': {
      'filepath': 'buffer',
      'line_num': 3,
      'column_num': 9
    },
    # Looks strange but this is really what ycmd is returning.
    'location_extent': {
      'start': {
        'filepath': '',
        'line_num': 0,
        'column_num': 0,
      },
      'end': {
        'filepath': '',
        'line_num': 0,
        'column_num': 0,
      }
    },
    'ranges': [],
    'fixit_available': True
  }, {
    'kind': 'WARNING',
    'text': 'equality comparison result unused',
    'location': {
      'filepath': 'buffer',
      'line_num': 3,
      'column_num': 7,
    },
    'location_extent': {
      'start': {
        'filepath': 'buffer',
        'line_num': 3,
        'column_num': 5,
      },
      'end': {
        'filepath': 'buffer',
        'line_num': 3,
        'column_num': 7,
      }
    },
    'ranges': [ {
      'start': {
        'filepath': 'buffer',
        'line_num': 3,
        'column_num': 3,
      },
      'end': {
        'filepath': 'buffer',
        'line_num': 3,
        'column_num': 9,
      }
    } ],
    'fixit_available': True
  } ]

  current_buffer = VimBuffer( 'buffer',
                              filetype = 'c',
                              contents = contents.splitlines(),
                              number = 5 )

  test_utils.VIM_MATCHES_FOR_WINDOW.clear()
  test_utils.VIM_SIGNS = []

  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 3, 1 ) ):
    with patch( 'ycm.client.event_notification.EventNotification.Response',
                return_value = diagnostics ):
      ycm.OnFileReadyToParse()
      ycm.HandleFileParseRequest( block = True )

    # The error on the current line is echoed, not the warning.
    post_vim_message.assert_called_once_with(
      "expected ';' after expression (FixIt)",
      truncate = True, warning = False )

    # Error match is added after warning matches.
    assert_that(
      test_utils.VIM_MATCHES_FOR_WINDOW,
      has_entries( {
        1: contains(
          VimMatch( 'YcmWarningSection', '\\%3l\\%5c\\_.\\{-}\\%3l\\%7c' ),
          VimMatch( 'YcmWarningSection', '\\%3l\\%3c\\_.\\{-}\\%3l\\%9c' ),
          VimMatch( 'YcmErrorSection', '\\%3l\\%8c' )
        )
      } )
    )

    # Only the error sign is placed.
    assert_that(
      test_utils.VIM_SIGNS,
      contains(
        VimSign( SIGN_BUFFER_ID_INITIAL_VALUE, 3, 'YcmError', 5 )
      )
    )

  # The error is not echoed again when moving the cursor along the line.
  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 3, 2 ) ):
    post_vim_message.reset_mock()
    ycm.OnCursorMoved()
    post_vim_message.assert_not_called()

  # The error is cleared when moving the cursor to another line.
  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 2, 2 ) ):
    post_vim_message.reset_mock()
    ycm.OnCursorMoved()
    post_vim_message.assert_called_once_with( "", warning = False )

  # The error is echoed when moving the cursor back.
  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 3, 2 ) ):
    post_vim_message.reset_mock()
    ycm.OnCursorMoved()
    post_vim_message.assert_called_once_with(
      "expected ';' after expression (FixIt)",
      truncate = True, warning = False )

    with patch( 'ycm.client.event_notification.EventNotification.Response',
                return_value = diagnostics[ 1 : ] ):
      ycm.OnFileReadyToParse()
      ycm.HandleFileParseRequest( block = True )

    assert_that(
      test_utils.VIM_MATCHES_FOR_WINDOW,
      has_entries( {
        1: contains(
          VimMatch( 'YcmWarningSection', '\\%3l\\%5c\\_.\\{-}\\%3l\\%7c' ),
          VimMatch( 'YcmWarningSection', '\\%3l\\%3c\\_.\\{-}\\%3l\\%9c' )
        )
      } )
    )

    assert_that(
      test_utils.VIM_SIGNS,
      contains(
        VimSign( SIGN_BUFFER_ID_INITIAL_VALUE + 1, 3, 'YcmWarning', 5 )
      )
    )


@YouCompleteMeInstance( { 'g:ycm_enable_diagnostic_highlighting': 1 } )
def YouCompleteMe_UpdateMatches_ClearDiagnosticMatchesInNewBuffer_test( ycm ):
  current_buffer = VimBuffer( 'buffer',
                              filetype = 'c',
                              number = 5 )

  test_utils.VIM_MATCHES_FOR_WINDOW.clear()
  test_utils.VIM_MATCHES_FOR_WINDOW[ 1 ] = [
    VimMatch( 'YcmWarningSection', '\\%3l\\%5c\\_.\\{-}\\%3l\\%7c' ),
    VimMatch( 'YcmWarningSection', '\\%3l\\%3c\\_.\\{-}\\%3l\\%9c' ),
    VimMatch( 'YcmErrorSection', '\\%3l\\%8c' )
  ]

  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    ycm.UpdateMatches()

  assert_that( test_utils.VIM_MATCHES_FOR_WINDOW,
               has_entries( { 1: empty() } ) )


@YouCompleteMeInstance( { 'g:ycm_echo_current_diagnostic': 1,
                          'g:ycm_always_populate_location_list': 1,
                          'g:ycm_enable_diagnostic_highlighting': 1 } )
@patch.object( ycm_buffer_module,
               'DIAGNOSTIC_UI_ASYNC_FILETYPES',
               [ 'ycmtest' ] )
@patch( 'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = True )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def YouCompleteMe_AsyncDiagnosticUpdate_SingleFile_test( ycm,
                                                         post_vim_message,
                                                         *args ):

  # This test simulates asynchronous diagnostic updates associated with a single
  # file (e.g. Translation Unit), but where the actual errors refer to other
  # open files and other non-open files. This is not strictly invalid, nor is it
  # completely normal, but it is supported and does work.

  # Contrast with the next test which sends the diagnostics filewise, which is
  # what the language server protocol will do.

  diagnostics = [
    {
      'kind': 'ERROR',
      'text': 'error text in current buffer',
      'location': {
        'filepath': '/current',
        'line_num': 1,
        'column_num': 1
      },
      'location_extent': {
        'start': {
          'filepath': '/current',
          'line_num': 1,
          'column_num': 1,
        },
        'end': {
          'filepath': '/current',
          'line_num': 1,
          'column_num': 1,
        }
      },
      'ranges': []
    },
    {
      'kind': 'ERROR',
      'text': 'error text in hidden buffer',
      'location': {
        'filepath': '/has_diags',
        'line_num': 4,
        'column_num': 2
      },
      'location_extent': {
        'start': {
          'filepath': '/has_diags',
          'line_num': 4,
          'column_num': 2,
        },
        'end': {
          'filepath': '/has_diags',
          'line_num': 4,
          'column_num': 2,
        }
      },
      'ranges': []
    },
    {
      'kind': 'ERROR',
      'text': 'error text in buffer not open in Vim',
      'location': {
        'filepath': '/not_open',
        'line_num': 8,
        'column_num': 4
      },
      'location_extent': {
        'start': {
          'filepath': '/not_open',
          'line_num': 8,
          'column_num': 4,
        },
        'end': {
          'filepath': '/not_open',
          'line_num': 8,
          'column_num': 4,
        }
      },
      'ranges': []
    }
  ]

  current_buffer = VimBuffer( '/current',
                              filetype = 'ycmtest',
                              contents = [ 'current' ] * 10,
                              number = 1 )
  no_diags_buffer = VimBuffer( '/no_diags',
                               filetype = 'ycmtest',
                               contents = [ 'nodiags' ] * 10,
                               number = 2 )
  hidden_buffer = VimBuffer( '/has_diags',
                             filetype = 'ycmtest',
                             contents = [ 'hasdiags' ] * 10,
                             number = 3 )

  buffers = [ current_buffer, no_diags_buffer, hidden_buffer ]
  windows = [ current_buffer, no_diags_buffer ]

  # Register each buffer internally with YCM
  for current in buffers:
    with MockVimBuffers( buffers, [ current ] ):
      ycm.OnFileReadyToParse()

  with patch( 'ycm.vimsupport.SetLocationListForWindow',
              new_callable = ExtendedMock ) as set_location_list_for_window:
    with MockVimBuffers( buffers, windows ):
      ycm.UpdateWithNewDiagnosticsForFile( '/current', diagnostics )

  # We update the diagnostic on the current cursor position
  post_vim_message.assert_has_exact_calls( [
    call( "error text in current buffer", truncate = True, warning = False ),
  ] )

  # Ensure we included all the diags though
  set_location_list_for_window.assert_has_exact_calls( [
    call( 1, [
      {
        'lnum': 1,
        'col': 1,
        'bufnr': 1,
        'valid': 1,
        'type': 'E',
        'text': 'error text in current buffer',
      },
      {
        'lnum': 4,
        'col': 2,
        'bufnr': 3,
        'valid': 1,
        'type': 'E',
        'text': 'error text in hidden buffer',
      },
      {
        'lnum': 8,
        'col': 4,
        'bufnr': -1, # sic: Our mocked bufnr function actually returns -1,
                     # even though YCM is passing "create if needed".
                     # FIXME? we shouldn't do that, and we should pass
                     # filename instead
        'valid': 1,
        'type': 'E',
        'text': 'error text in buffer not open in Vim'
      }
    ] )
  ] )

  assert_that(
    test_utils.VIM_MATCHES_FOR_WINDOW,
    has_entries( {
      1: contains(
        VimMatch( 'YcmErrorSection', '\\%1l\\%1c\\_.\\{-}\\%1l\\%1c' )
      )
    } )
  )


@YouCompleteMeInstance( { 'g:ycm_echo_current_diagnostic': 1,
                          'g:ycm_always_populate_location_list': 1,
                          'g:ycm_enable_diagnostic_highlighting': 1 } )
@patch.object( ycm_buffer_module,
               'DIAGNOSTIC_UI_ASYNC_FILETYPES',
               [ 'ycmtest' ] )
@patch( 'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = True )
@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
def YouCompleteMe_AsyncDiagnosticUpdate_PerFile_test( ycm,
                                                      post_vim_message,
                                                      *args ):

  # This test simulates asynchronous diagnostic updates which are delivered per
  # file, including files which are open and files which are not.

  # Ordered to ensure that the calls to update are deterministic
  diagnostics_per_file = [
    ( '/current', [ {
        'kind': 'ERROR',
        'text': 'error text in current buffer',
        'location': {
          'filepath': '/current',
          'line_num': 1,
          'column_num': 1
        },
        'location_extent': {
          'start': {
            'filepath': '/current',
            'line_num': 1,
            'column_num': 1,
          },
          'end': {
            'filepath': '/current',
            'line_num': 1,
            'column_num': 1,
          }
        },
        'ranges': [],
      } ] ),
    ( '/separate_window', [ {
        'kind': 'ERROR',
        'text': 'error text in a buffer open in a separate window',
        'location': {
          'filepath': '/separate_window',
          'line_num': 3,
          'column_num': 3
        },
        'location_extent': {
          'start': {
            'filepath': '/separate_window',
            'line_num': 3,
            'column_num': 3,
          },
          'end': {
            'filepath': '/separate_window',
            'line_num': 3,
            'column_num': 3,
          }
        },
        'ranges': []
      } ] ),
    ( '/hidden', [ {
        'kind': 'ERROR',
        'text': 'error text in hidden buffer',
        'location': {
          'filepath': '/hidden',
          'line_num': 4,
          'column_num': 2
        },
        'location_extent': {
          'start': {
            'filepath': '/hidden',
            'line_num': 4,
            'column_num': 2,
          },
          'end': {
            'filepath': '/hidden',
            'line_num': 4,
            'column_num': 2,
          }
        },
        'ranges': []
      } ] ),
    ( '/not_open', [ {
        'kind': 'ERROR',
        'text': 'error text in buffer not open in Vim',
        'location': {
          'filepath': '/not_open',
          'line_num': 8,
          'column_num': 4
        },
        'location_extent': {
          'start': {
            'filepath': '/not_open',
            'line_num': 8,
            'column_num': 4,
          },
          'end': {
            'filepath': '/not_open',
            'line_num': 8,
            'column_num': 4,
          }
        },
        'ranges': []
      } ] )
  ]

  current_buffer = VimBuffer( '/current',
                              filetype = 'ycmtest',
                              contents = [ 'current' ] * 10,
                              number = 1 )
  no_diags_buffer = VimBuffer( '/no_diags',
                               filetype = 'ycmtest',
                               contents = [ 'no_diags' ] * 10,
                               number = 2 )
  separate_window = VimBuffer( '/separate_window',
                               filetype = 'ycmtest',
                               contents = [ 'separate_window' ] * 10,
                               number = 3 )
  hidden_buffer = VimBuffer( '/hidden',
                             filetype = 'ycmtest',
                             contents = [ 'hidden' ] * 10,
                             number = 4 )
  buffers = [
    current_buffer,
    no_diags_buffer,
    separate_window,
    hidden_buffer
  ]
  windows = [
    current_buffer,
    no_diags_buffer,
    separate_window
  ]

  # Register each buffer internally with YCM
  for current in buffers:
    with MockVimBuffers( buffers, [ current ] ):
      ycm.OnFileReadyToParse()

  with patch( 'ycm.vimsupport.SetLocationListForWindow',
              new_callable = ExtendedMock ) as set_location_list_for_window:
    with MockVimBuffers( buffers, windows ):
      for filename, diagnostics in diagnostics_per_file:
        ycm.UpdateWithNewDiagnosticsForFile( filename, diagnostics )

  # We update the diagnostic on the current cursor position
  post_vim_message.assert_has_exact_calls( [
    call( "error text in current buffer", truncate = True, warning = False ),
  ] )

  # Ensure we included all the diags though
  set_location_list_for_window.assert_has_exact_calls( [
    call( 1, [
      {
        'lnum': 1,
        'col': 1,
        'bufnr': 1,
        'valid': 1,
        'type': 'E',
        'text': 'error text in current buffer',
      },
    ] ),

    call( 3, [
      {
        'lnum': 3,
        'col': 3,
        'bufnr': 3,
        'valid': 1,
        'type': 'E',
        'text': 'error text in a buffer open in a separate window',
      },
    ] )
  ] )

  # FIXME: diagnostic matches in windows other than the current one are not
  # updated.
  assert_that(
    test_utils.VIM_MATCHES_FOR_WINDOW,
    has_entries( {
      1: contains(
        VimMatch( 'YcmErrorSection', '\\%1l\\%1c\\_.\\{-}\\%1l\\%1c' )
      )
    } )
  )


@YouCompleteMeInstance()
def YouCompleteMe_OnPeriodicTick_ServerNotRunning_test( ycm, *args ):
  with patch.object( ycm, 'IsServerAlive', return_value = False ):
    assert_that( ycm.OnPeriodicTick(), equal_to( False ) )


@YouCompleteMeInstance()
def YouCompleteMe_OnPeriodicTick_ServerNotReady_test( ycm, *args ):
  with patch.object( ycm, 'IsServerAlive', return_value = True ):
    with patch.object( ycm, 'IsServerReady', return_value = False ):
      assert_that( ycm.OnPeriodicTick(), equal_to( True ) )


@YouCompleteMeInstance()
@patch.object( ycm_buffer_module,
               'DIAGNOSTIC_UI_ASYNC_FILETYPES',
               [ 'ycmtest' ] )
@patch( 'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = True )
@patch( 'ycm.client.base_request._ValidateResponseObject', return_value = True )
@patch( 'ycm.client.base_request.BaseRequest.PostDataToHandlerAsync' )
def YouCompleteMe_OnPeriodicTick_DontRetry_test( ycm,
                                                 post_data_to_handler_async,
                                                 *args ):

  current_buffer = VimBuffer( '/current',
                              filetype = 'ycmtest',
                              number = 1 )

  # Create the request and make the first poll; we expect no response
  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 1 ) ):
    assert_that( ycm.OnPeriodicTick(), equal_to( True ) )
    post_data_to_handler_async.assert_called()

  assert ycm._message_poll_request is not None
  post_data_to_handler_async.reset_mock()

  # OK that sent the request, now poll to check if it is complete (say it is
  # not)
  with patch.object( ycm._message_poll_request,
                     '_response_future',
                     new = MockAsyncServerResponseInProgress() ) as mock_future:
    poll_again = ycm.OnPeriodicTick()
    mock_future.done.assert_called()
    mock_future.result.assert_not_called()
    assert_that( poll_again, equal_to( True ) )

  # Poll again, but return a response (telling us to stop polling)
  with patch.object( ycm._message_poll_request,
                     '_response_future',
                     new = MockAsyncServerResponseDone( False ) ) \
      as mock_future:
    poll_again = ycm.OnPeriodicTick()
    mock_future.done.assert_called()
    mock_future.result.assert_called()
    post_data_to_handler_async.assert_not_called()
    # We reset and don't poll anymore
    assert_that( ycm._message_poll_request is None )
    assert_that( poll_again, equal_to( False ) )



@YouCompleteMeInstance()
@patch.object( ycm_buffer_module,
               'DIAGNOSTIC_UI_ASYNC_FILETYPES',
               [ 'ycmtest' ] )
@patch( 'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = True )
@patch( 'ycm.client.base_request._ValidateResponseObject', return_value = True )
@patch( 'ycm.client.base_request.BaseRequest.PostDataToHandlerAsync' )
def YouCompleteMe_OnPeriodicTick_Exception_test( ycm,
                                                 post_data_to_handler_async,
                                                 *args ):

  current_buffer = VimBuffer( '/current',
                              filetype = 'ycmtest',
                              number = 1 )

  # Create the request and make the first poll; we expect no response
  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 1 ) ):
    assert_that( ycm.OnPeriodicTick(), equal_to( True ) )
    post_data_to_handler_async.assert_called()

  post_data_to_handler_async.reset_mock()

  # Poll again, but return an exception response
  mock_response = MockAsyncServerResponseException( RuntimeError( 'test' ) )
  with patch.object( ycm._message_poll_request,
                     '_response_future',
                     new = mock_response ) as mock_future:
    assert_that( ycm.OnPeriodicTick(), equal_to( False ) )
    mock_future.done.assert_called()
    mock_future.result.assert_called()
    post_data_to_handler_async.assert_not_called()
    # We reset and don't poll anymore
    assert_that( ycm._message_poll_request is None )


@YouCompleteMeInstance()
@patch.object( ycm_buffer_module,
               'DIAGNOSTIC_UI_ASYNC_FILETYPES',
               [ 'ycmtest' ] )
@patch( 'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = True )
@patch( 'ycm.client.base_request._ValidateResponseObject', return_value = True )
@patch( 'ycm.client.base_request.BaseRequest.PostDataToHandlerAsync' )
@patch( 'ycm.client.messages_request._HandlePollResponse' )
def YouCompleteMe_OnPeriodicTick_ValidResponse_test( ycm,
                                                     handle_poll_response,
                                                     post_data_to_handler_async,
                                                     *args ):

  current_buffer = VimBuffer( '/current',
                              filetype = 'ycmtest',
                              number = 1 )

  # Create the request and make the first poll; we expect no response
  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 1 ) ):
    assert_that( ycm.OnPeriodicTick(), equal_to( True ) )
    post_data_to_handler_async.assert_called()

  post_data_to_handler_async.reset_mock()

  # Poll again, and return a _proper_ response (finally!).
  # Note, _HandlePollResponse is tested independently (for simplicity)
  with patch.object( ycm._message_poll_request,
                     '_response_future',
                     new = MockAsyncServerResponseDone( [] ) ) as mock_future:
    assert_that( ycm.OnPeriodicTick(), equal_to( True ) )
    handle_poll_response.assert_called()
    mock_future.done.assert_called()
    mock_future.result.assert_called()
    post_data_to_handler_async.assert_called() # Poll again!
    assert_that( ycm._message_poll_request is not None )


@YouCompleteMeInstance()
@patch( 'ycm.client.completion_request.CompletionRequest.OnCompleteDone' )
def YouCompleteMe_OnCompleteDone_CompletionRequest_test( ycm,
                                                         on_complete_done ):
  current_buffer = VimBuffer( 'current_buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 1 ) ):
    ycm.SendCompletionRequest()
  ycm.OnCompleteDone()
  on_complete_done.assert_called()


@YouCompleteMeInstance()
@patch( 'ycm.client.completion_request.CompletionRequest.OnCompleteDone' )
def YouCompleteMe_OnCompleteDone_NoCompletionRequest_test( ycm,
                                                           on_complete_done ):
  ycm.OnCompleteDone()
  on_complete_done.assert_not_called()


@YouCompleteMeInstance()
def YouCompleteMe_ShouldResendFileParseRequest_NoParseRequest_test( ycm ):
  current_buffer = VimBuffer( 'current_buffer' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    assert_that( ycm.ShouldResendFileParseRequest(), equal_to( False ) )
<EOF>
<BOF>
# coding: utf-8
#
# Copyright (C) 2013 Google Inc.
#               2016 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

import contextlib
from nose.tools import eq_, ok_
from mock import patch

from ycm.tests.test_utils import MockVimModule
vim_mock = MockVimModule()
from ycm import base


@contextlib.contextmanager
def MockCurrentFiletypes( filetypes = [ '' ] ):
  with patch( 'ycm.vimsupport.CurrentFiletypes', return_value = filetypes ):
    yield


@contextlib.contextmanager
def MockCurrentColumnAndLineContents( column, line_contents ):
  with patch( 'ycm.vimsupport.CurrentColumn', return_value = column ):
    with patch( 'ycm.vimsupport.CurrentLineContents',
                return_value = line_contents ):
      yield


@contextlib.contextmanager
def MockTextAfterCursor( text ):
  with patch( 'ycm.vimsupport.TextAfterCursor', return_value = text ):
    yield


def AdjustCandidateInsertionText_Basic_test():
  with MockTextAfterCursor( 'bar' ):
    eq_( [ { 'abbr': 'foobar', 'word': 'foo' } ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foobar' } ] ) )


def AdjustCandidateInsertionText_ParenInTextAfterCursor_test():
  with MockTextAfterCursor( 'bar(zoo' ):
    eq_( [ { 'abbr': 'foobar', 'word': 'foo' } ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foobar' } ] ) )


def AdjustCandidateInsertionText_PlusInTextAfterCursor_test():
  with MockTextAfterCursor( 'bar+zoo' ):
    eq_( [ { 'abbr': 'foobar', 'word': 'foo' } ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foobar' } ] ) )


def AdjustCandidateInsertionText_WhitespaceInTextAfterCursor_test():
  with MockTextAfterCursor( 'bar zoo' ):
    eq_( [ { 'abbr': 'foobar', 'word': 'foo' } ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foobar' } ] ) )


def AdjustCandidateInsertionText_MoreThanWordMatchingAfterCursor_test():
  with MockTextAfterCursor( 'bar.h' ):
    eq_( [ { 'abbr': 'foobar.h', 'word': 'foo' } ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foobar.h' } ] ) )

  with MockTextAfterCursor( 'bar(zoo' ):
    eq_( [ { 'abbr': 'foobar(zoo', 'word': 'foo' } ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foobar(zoo' } ] ) )


def AdjustCandidateInsertionText_NotSuffix_test():
  with MockTextAfterCursor( 'bar' ):
    eq_( [ { 'abbr': 'foofoo', 'word': 'foofoo' } ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foofoo' } ] ) )


def AdjustCandidateInsertionText_NothingAfterCursor_test():
  with MockTextAfterCursor( '' ):
    eq_( [ { 'word': 'foofoo' },
           { 'word': 'zobar' } ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foofoo' },
                                              { 'word': 'zobar' } ] ) )


def AdjustCandidateInsertionText_MultipleStrings_test():
  with MockTextAfterCursor( 'bar' ):
    eq_( [ { 'abbr': 'foobar', 'word': 'foo' },
           { 'abbr': 'zobar', 'word': 'zo' },
           { 'abbr': 'qbar', 'word': 'q' },
           { 'abbr': 'bar', 'word': '' }, ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foobar' },
                                              { 'word': 'zobar' },
                                              { 'word': 'qbar' },
                                              { 'word': 'bar' } ] ) )


def AdjustCandidateInsertionText_DictInput_test():
  with MockTextAfterCursor( 'bar' ):
    eq_( [ { 'abbr': 'foobar', 'word': 'foo' } ],
         base.AdjustCandidateInsertionText( [ { 'word': 'foobar' } ] ) )


def AdjustCandidateInsertionText_DontTouchAbbr_test():
  with MockTextAfterCursor( 'bar' ):
    eq_( [ { 'abbr': '1234', 'word': 'foo' } ],
         base.AdjustCandidateInsertionText(
           [ { 'abbr': '1234', 'word': 'foobar' } ] ) )


def OverlapLength_Basic_test():
  eq_( 3, base.OverlapLength( 'foo bar', 'bar zoo' ) )
  eq_( 3, base.OverlapLength( 'foobar', 'barzoo' ) )


def OverlapLength_BasicWithUnicode_test():
  eq_( 3, base.OverlapLength( u'bar fäö', u'fäö bar' ) )
  eq_( 3, base.OverlapLength( u'zoofäö', u'fäözoo' ) )


def OverlapLength_OneCharOverlap_test():
  eq_( 1, base.OverlapLength( 'foo b', 'b zoo' ) )


def OverlapLength_SameStrings_test():
  eq_( 6, base.OverlapLength( 'foobar', 'foobar' ) )


def OverlapLength_Substring_test():
  eq_( 6, base.OverlapLength( 'foobar', 'foobarzoo' ) )
  eq_( 6, base.OverlapLength( 'zoofoobar', 'foobar' ) )


def OverlapLength_LongestOverlap_test():
  eq_( 7, base.OverlapLength( 'bar foo foo', 'foo foo bar' ) )


def OverlapLength_EmptyInput_test():
  eq_( 0, base.OverlapLength( '', 'goobar' ) )
  eq_( 0, base.OverlapLength( 'foobar', '' ) )
  eq_( 0, base.OverlapLength( '', '' ) )


def OverlapLength_NoOverlap_test():
  eq_( 0, base.OverlapLength( 'foobar', 'goobar' ) )
  eq_( 0, base.OverlapLength( 'foobar', '(^($@#$#@' ) )
  eq_( 0, base.OverlapLength( 'foo bar zoo', 'foo zoo bar' ) )


def LastEnteredCharIsIdentifierChar_Basic_test():
  with MockCurrentFiletypes():
    with MockCurrentColumnAndLineContents( 3, 'abc' ):
      ok_( base.LastEnteredCharIsIdentifierChar() )

    with MockCurrentColumnAndLineContents( 2, 'abc' ):
      ok_( base.LastEnteredCharIsIdentifierChar() )

    with MockCurrentColumnAndLineContents( 1, 'abc' ):
      ok_( base.LastEnteredCharIsIdentifierChar() )


def LastEnteredCharIsIdentifierChar_FiletypeHtml_test():
  with MockCurrentFiletypes( [ 'html' ] ):
    with MockCurrentColumnAndLineContents( 3, 'ab-' ):
      ok_( base.LastEnteredCharIsIdentifierChar() )


def LastEnteredCharIsIdentifierChar_ColumnIsZero_test():
  with MockCurrentColumnAndLineContents( 0, 'abc' ):
    ok_( not base.LastEnteredCharIsIdentifierChar() )


def LastEnteredCharIsIdentifierChar_LineEmpty_test():
  with MockCurrentFiletypes():
    with MockCurrentColumnAndLineContents( 3, '' ):
      ok_( not base.LastEnteredCharIsIdentifierChar() )

    with MockCurrentColumnAndLineContents( 0, '' ):
      ok_( not base.LastEnteredCharIsIdentifierChar() )


def LastEnteredCharIsIdentifierChar_NotIdentChar_test():
  with MockCurrentFiletypes():
    with MockCurrentColumnAndLineContents( 3, 'ab;' ):
      ok_( not base.LastEnteredCharIsIdentifierChar() )

    with MockCurrentColumnAndLineContents( 1, ';' ):
      ok_( not base.LastEnteredCharIsIdentifierChar() )

    with MockCurrentColumnAndLineContents( 3, 'ab-' ):
      ok_( not base.LastEnteredCharIsIdentifierChar() )


def LastEnteredCharIsIdentifierChar_Unicode_test():
  with MockCurrentFiletypes():
    # CurrentColumn returns a byte offset and character ø is 2 bytes length.
    with MockCurrentColumnAndLineContents( 5, 'føo(' ):
      ok_( not base.LastEnteredCharIsIdentifierChar() )

    with MockCurrentColumnAndLineContents( 4, 'føo(' ):
      ok_( base.LastEnteredCharIsIdentifierChar() )

    with MockCurrentColumnAndLineContents( 3, 'føo(' ):
      ok_( base.LastEnteredCharIsIdentifierChar() )

    with MockCurrentColumnAndLineContents( 1, 'føo(' ):
      ok_( base.LastEnteredCharIsIdentifierChar() )


def CurrentIdentifierFinished_Basic_test():
  with MockCurrentFiletypes():
    with MockCurrentColumnAndLineContents( 3, 'ab;' ):
      ok_( base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 2, 'ab;' ):
      ok_( not base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 1, 'ab;' ):
      ok_( not base.CurrentIdentifierFinished() )


def CurrentIdentifierFinished_NothingBeforeColumn_test():
  with MockCurrentColumnAndLineContents( 0, 'ab;' ):
    ok_( base.CurrentIdentifierFinished() )

  with MockCurrentColumnAndLineContents( 0, '' ):
    ok_( base.CurrentIdentifierFinished() )


def CurrentIdentifierFinished_InvalidColumn_test():
  with MockCurrentFiletypes():
    with MockCurrentColumnAndLineContents( 5, '' ):
      ok_( base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 5, 'abc' ):
      ok_( not base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 4, 'ab;' ):
      ok_( base.CurrentIdentifierFinished() )


def CurrentIdentifierFinished_InMiddleOfLine_test():
  with MockCurrentFiletypes():
    with MockCurrentColumnAndLineContents( 4, 'bar.zoo' ):
      ok_( base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 4, 'bar(zoo' ):
      ok_( base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 4, 'bar-zoo' ):
      ok_( base.CurrentIdentifierFinished() )


def CurrentIdentifierFinished_Html_test():
  with MockCurrentFiletypes( [ 'html' ] ):
    with MockCurrentColumnAndLineContents( 4, 'bar-zoo' ):
      ok_( not base.CurrentIdentifierFinished() )


def CurrentIdentifierFinished_WhitespaceOnly_test():
  with MockCurrentFiletypes():
    with MockCurrentColumnAndLineContents( 1, '\n' ):
      ok_( base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 3, '\n    ' ):
      ok_( base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 3, '\t\t\t\t' ):
      ok_( base.CurrentIdentifierFinished() )


def CurrentIdentifierFinished_Unicode_test():
  with MockCurrentFiletypes():
    # CurrentColumn returns a byte offset and character ø is 2 bytes length.
    with MockCurrentColumnAndLineContents( 6, 'føo ' ):
      ok_( base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 5, 'føo ' ):
      ok_( base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 4, 'føo ' ):
      ok_( not base.CurrentIdentifierFinished() )

    with MockCurrentColumnAndLineContents( 3, 'føo ' ):
      ok_( not base.CurrentIdentifierFinished() )
<EOF>
<BOF>
# coding: utf-8
#
# Copyright (C) 2015-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import ( CurrentWorkingDirectory, ExtendedMock,
                                   MockVimBuffers, MockVimModule, VimBuffer,
                                   VimSign )
MockVimModule()

import contextlib
import os

from ycm.tests import ( PathToTestFile, test_utils, YouCompleteMeInstance,
                        WaitUntilReady )
from ycm.vimsupport import SIGN_BUFFER_ID_INITIAL_VALUE
from ycmd.responses import ( BuildDiagnosticData, Diagnostic, Location, Range,
                             UnknownExtraConf, ServerError )

from hamcrest import ( assert_that, contains, empty, has_entries, has_entry,
                       has_item, has_items, has_key, is_not )
from mock import call, MagicMock, patch
from nose.tools import eq_, ok_


def PresentDialog_Confirm_Call( message ):
  """Return a mock.call object for a call to vimsupport.PresentDialog, as called
  why vimsupport.Confirm with the supplied confirmation message"""
  return call( message, [ 'Ok', 'Cancel' ] )


@contextlib.contextmanager
def MockArbitraryBuffer( filetype ):
  """Used via the with statement, set up a single buffer with an arbitrary name
  and no contents. Its filetype is set to the supplied filetype."""

  # Arbitrary, but valid, single buffer open.
  current_buffer = VimBuffer( os.path.realpath( 'TEST_BUFFER' ),
                              filetype = filetype )

  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    yield


@contextlib.contextmanager
def MockEventNotification( response_method, native_filetype_completer = True ):
  """Mock out the EventNotification client request object, replacing the
  Response handler's JsonFromFuture with the supplied |response_method|.
  Additionally mock out YouCompleteMe's FiletypeCompleterExistsForFiletype
  method to return the supplied |native_filetype_completer| parameter, rather
  than querying the server"""

  # We don't want the event to actually be sent to the server, just have it
  # return success
  with patch( 'ycm.client.event_notification.EventNotification.'
              'PostDataToHandlerAsync',
              return_value = MagicMock( return_value=True ) ):

    # We set up a fake a Response (as called by EventNotification.Response)
    # which calls the supplied callback method. Generally this callback just
    # raises an apropriate exception, otherwise it would have to return a mock
    # future object.
    with patch( 'ycm.client.base_request._JsonFromFuture',
                side_effect = response_method ):

      # Filetype available information comes from the server, so rather than
      # relying on that request, we mock out the check. The caller decides if
      # filetype completion is available
      with patch(
        'ycm.youcompleteme.YouCompleteMe.FiletypeCompleterExistsForFiletype',
        return_value = native_filetype_completer ):

        yield


@patch( 'ycm.vimsupport.PostVimMessage', new_callable = ExtendedMock )
@YouCompleteMeInstance()
def EventNotification_FileReadyToParse_NonDiagnostic_Error_test(
    ycm, post_vim_message ):

  # This test validates the behaviour of YouCompleteMe.HandleFileParseRequest
  # in combination with YouCompleteMe.OnFileReadyToParse when the completer
  # raises an exception handling FileReadyToParse event notification
  ERROR_TEXT = 'Some completer response text'

  def ErrorResponse( *args ):
    raise ServerError( ERROR_TEXT )

  with MockArbitraryBuffer( 'some_filetype' ):
    with MockEventNotification( ErrorResponse ):
      ycm.OnFileReadyToParse()
      ok_( ycm.FileParseRequestReady() )
      ycm.HandleFileParseRequest()

      # The first call raises a warning
      post_vim_message.assert_has_exact_calls( [
        call( ERROR_TEXT, truncate = True )
      ] )

      # Subsequent calls don't re-raise the warning
      ycm.HandleFileParseRequest()
      post_vim_message.assert_has_exact_calls( [
        call( ERROR_TEXT, truncate = True )
      ] )

      ok_( not ycm.ShouldResendFileParseRequest() )

      # But it does if a subsequent event raises again
      ycm.OnFileReadyToParse()
      ok_( ycm.FileParseRequestReady() )
      ycm.HandleFileParseRequest()
      post_vim_message.assert_has_exact_calls( [
        call( ERROR_TEXT, truncate = True ),
        call( ERROR_TEXT, truncate = True )
      ] )

      ok_( not ycm.ShouldResendFileParseRequest() )


@YouCompleteMeInstance()
def EventNotification_FileReadyToParse_NonDiagnostic_Error_NonNative_test(
  ycm ):

  test_utils.VIM_MATCHES = []
  test_utils.VIM_SIGNS = []

  with MockArbitraryBuffer( 'some_filetype' ):
    with MockEventNotification( None, False ):
      ycm.OnFileReadyToParse()
      ycm.HandleFileParseRequest()
      assert_that(
        test_utils.VIM_MATCHES,
        contains()
      )
      assert_that(
        test_utils.VIM_SIGNS,
        contains()
      )
      ok_( not ycm.ShouldResendFileParseRequest() )


@YouCompleteMeInstance()
def EventNotification_FileReadyToParse_NonDiagnostic_ConfirmExtraConf_test(
    ycm ):

  # This test validates the behaviour of YouCompleteMe.HandleFileParseRequest
  # in combination with YouCompleteMe.OnFileReadyToParse when the completer
  # raises the (special) UnknownExtraConf exception
  FILE_NAME = 'a_file'
  MESSAGE = ( 'Found ' + FILE_NAME + '. Load? \n\n(Question can be '
              'turned off with options, see YCM docs)' )

  def UnknownExtraConfResponse( *args ):
    raise UnknownExtraConf( FILE_NAME )

  with patch( 'ycm.client.base_request.BaseRequest.PostDataToHandler',
              new_callable = ExtendedMock ) as post_data_to_handler:
    with MockArbitraryBuffer( 'some_filetype' ):
      with MockEventNotification( UnknownExtraConfResponse ):

        # When the user accepts the extra conf, we load it
        with patch( 'ycm.vimsupport.PresentDialog',
                    return_value = 0,
                    new_callable = ExtendedMock ) as present_dialog:
          ycm.OnFileReadyToParse()
          ok_( ycm.FileParseRequestReady() )
          ycm.HandleFileParseRequest()

          present_dialog.assert_has_exact_calls( [
            PresentDialog_Confirm_Call( MESSAGE ),
          ] )
          post_data_to_handler.assert_has_exact_calls( [
            call( { 'filepath': FILE_NAME }, 'load_extra_conf_file' )
          ] )

          # Subsequent calls don't re-raise the warning
          ycm.HandleFileParseRequest()

          present_dialog.assert_has_exact_calls( [
            PresentDialog_Confirm_Call( MESSAGE )
          ] )
          post_data_to_handler.assert_has_exact_calls( [
            call( { 'filepath': FILE_NAME }, 'load_extra_conf_file' )
          ] )

          ok_( ycm.ShouldResendFileParseRequest() )

          # But it does if a subsequent event raises again
          ycm.OnFileReadyToParse()
          ok_( ycm.FileParseRequestReady() )
          ycm.HandleFileParseRequest()

          present_dialog.assert_has_exact_calls( [
            PresentDialog_Confirm_Call( MESSAGE ),
            PresentDialog_Confirm_Call( MESSAGE ),
          ] )
          post_data_to_handler.assert_has_exact_calls( [
            call( { 'filepath': FILE_NAME }, 'load_extra_conf_file' ),
            call( { 'filepath': FILE_NAME }, 'load_extra_conf_file' )
          ] )

          ok_( ycm.ShouldResendFileParseRequest() )

        post_data_to_handler.reset_mock()

        # When the user rejects the extra conf, we reject it
        with patch( 'ycm.vimsupport.PresentDialog',
                    return_value = 1,
                    new_callable = ExtendedMock ) as present_dialog:
          ycm.OnFileReadyToParse()
          ok_( ycm.FileParseRequestReady() )
          ycm.HandleFileParseRequest()

          present_dialog.assert_has_exact_calls( [
            PresentDialog_Confirm_Call( MESSAGE ),
          ] )
          post_data_to_handler.assert_has_exact_calls( [
            call( { 'filepath': FILE_NAME }, 'ignore_extra_conf_file' )
          ] )

          # Subsequent calls don't re-raise the warning
          ycm.HandleFileParseRequest()

          present_dialog.assert_has_exact_calls( [
            PresentDialog_Confirm_Call( MESSAGE )
          ] )
          post_data_to_handler.assert_has_exact_calls( [
            call( { 'filepath': FILE_NAME }, 'ignore_extra_conf_file' )
          ] )

          ok_( ycm.ShouldResendFileParseRequest() )

          # But it does if a subsequent event raises again
          ycm.OnFileReadyToParse()
          ok_( ycm.FileParseRequestReady() )
          ycm.HandleFileParseRequest()

          present_dialog.assert_has_exact_calls( [
            PresentDialog_Confirm_Call( MESSAGE ),
            PresentDialog_Confirm_Call( MESSAGE ),
          ] )
          post_data_to_handler.assert_has_exact_calls( [
            call( { 'filepath': FILE_NAME }, 'ignore_extra_conf_file' ),
            call( { 'filepath': FILE_NAME }, 'ignore_extra_conf_file' )
          ] )

          ok_( ycm.ShouldResendFileParseRequest() )


@YouCompleteMeInstance()
def EventNotification_FileReadyToParse_Diagnostic_Error_Native_test( ycm ):
  test_utils.VIM_SIGNS = []

  _Check_FileReadyToParse_Diagnostic_Error( ycm )
  _Check_FileReadyToParse_Diagnostic_Warning( ycm )
  _Check_FileReadyToParse_Diagnostic_Clean( ycm )


def _Check_FileReadyToParse_Diagnostic_Error( ycm ):
  # Tests Vim sign placement and error/warning count python API
  # when one error is returned.
  def DiagnosticResponse( *args ):
    start = Location( 1, 2, 'TEST_BUFFER' )
    end = Location( 1, 4, 'TEST_BUFFER' )
    extent = Range( start, end )
    diagnostic = Diagnostic( [], start, extent, 'expected ;', 'ERROR' )
    return [ BuildDiagnosticData( diagnostic ) ]

  with MockArbitraryBuffer( 'cpp' ):
    with MockEventNotification( DiagnosticResponse ):
      ycm.OnFileReadyToParse()
      ok_( ycm.FileParseRequestReady() )
      ycm.HandleFileParseRequest()
      assert_that(
        test_utils.VIM_SIGNS,
        contains(
          VimSign( SIGN_BUFFER_ID_INITIAL_VALUE, 1, 'YcmError', 1 )
        )
      )
      eq_( ycm.GetErrorCount(), 1 )
      eq_( ycm.GetWarningCount(), 0 )

      # Consequent calls to HandleFileParseRequest shouldn't mess with
      # existing diagnostics, when there is no new parse request.
      ycm.HandleFileParseRequest()
      assert_that(
        test_utils.VIM_SIGNS,
        contains(
          VimSign( SIGN_BUFFER_ID_INITIAL_VALUE, 1, 'YcmError', 1 )
        )
      )
      eq_( ycm.GetErrorCount(), 1 )
      eq_( ycm.GetWarningCount(), 0 )

      ok_( not ycm.ShouldResendFileParseRequest() )

      # New identical requests should result in the same diagnostics.
      ycm.OnFileReadyToParse()
      ok_( ycm.FileParseRequestReady() )
      ycm.HandleFileParseRequest()
      assert_that(
        test_utils.VIM_SIGNS,
        contains(
          VimSign( SIGN_BUFFER_ID_INITIAL_VALUE, 1, 'YcmError', 1 )
        )
      )
      eq_( ycm.GetErrorCount(), 1 )
      eq_( ycm.GetWarningCount(), 0 )

      ok_( not ycm.ShouldResendFileParseRequest() )


def _Check_FileReadyToParse_Diagnostic_Warning( ycm ):
  # Tests Vim sign placement/unplacement and error/warning count python API
  # when one warning is returned.
  # Should be called after _Check_FileReadyToParse_Diagnostic_Error
  def DiagnosticResponse( *args ):
    start = Location( 2, 2, 'TEST_BUFFER' )
    end = Location( 2, 4, 'TEST_BUFFER' )
    extent = Range( start, end )
    diagnostic = Diagnostic( [], start, extent, 'cast', 'WARNING' )
    return [ BuildDiagnosticData( diagnostic ) ]

  with MockArbitraryBuffer( 'cpp' ):
    with MockEventNotification( DiagnosticResponse ):
      ycm.OnFileReadyToParse()
      ok_( ycm.FileParseRequestReady() )
      ycm.HandleFileParseRequest()
      assert_that(
        test_utils.VIM_SIGNS,
        contains(
          VimSign( SIGN_BUFFER_ID_INITIAL_VALUE + 2, 2, 'YcmWarning', 1 )
        )
      )
      eq_( ycm.GetErrorCount(), 0 )
      eq_( ycm.GetWarningCount(), 1 )

      # Consequent calls to HandleFileParseRequest shouldn't mess with
      # existing diagnostics, when there is no new parse request.
      ycm.HandleFileParseRequest()
      assert_that(
        test_utils.VIM_SIGNS,
        contains(
          VimSign( SIGN_BUFFER_ID_INITIAL_VALUE + 2, 2, 'YcmWarning', 1 )
        )
      )
      eq_( ycm.GetErrorCount(), 0 )
      eq_( ycm.GetWarningCount(), 1 )

      ok_( not ycm.ShouldResendFileParseRequest() )


def _Check_FileReadyToParse_Diagnostic_Clean( ycm ):
  # Tests Vim sign unplacement and error/warning count python API
  # when there are no errors/warnings left.
  # Should be called after _Check_FileReadyToParse_Diagnostic_Warning
  with MockArbitraryBuffer( 'cpp' ):
    with MockEventNotification( MagicMock( return_value = [] ) ):
      ycm.OnFileReadyToParse()
      ycm.HandleFileParseRequest()
      assert_that(
        test_utils.VIM_SIGNS,
        empty()
      )
      eq_( ycm.GetErrorCount(), 0 )
      eq_( ycm.GetWarningCount(), 0 )
      ok_( not ycm.ShouldResendFileParseRequest() )


@patch( 'ycm.youcompleteme.YouCompleteMe._AddUltiSnipsDataIfNeeded' )
@YouCompleteMeInstance( { 'g:ycm_collect_identifiers_from_tags_files': 1 } )
def EventNotification_FileReadyToParse_TagFiles_UnicodeWorkingDirectory_test(
    ycm, *args ):
  unicode_dir = PathToTestFile( 'uni¢𐍈d€' )
  current_buffer_file = PathToTestFile( 'uni¢𐍈d€', 'current_buffer' )
  current_buffer = VimBuffer( name = current_buffer_file,
                              contents = [ 'current_buffer_contents' ],
                              filetype = 'some_filetype' )

  with patch( 'ycm.client.event_notification.EventNotification.'
              'PostDataToHandlerAsync' ) as post_data_to_handler_async:
    with CurrentWorkingDirectory( unicode_dir ):
      with MockVimBuffers( [ current_buffer ], [ current_buffer ], ( 1, 5 ) ):
        ycm.OnFileReadyToParse()

    assert_that(
      # Positional arguments passed to PostDataToHandlerAsync.
      post_data_to_handler_async.call_args[ 0 ],
      contains(
        has_entries( {
          'filepath': current_buffer_file,
          'line_num': 1,
          'column_num': 6,
          'file_data': has_entries( {
            current_buffer_file: has_entries( {
              'contents': 'current_buffer_contents\n',
              'filetypes': [ 'some_filetype' ]
            } )
          } ),
          'event_name': 'FileReadyToParse',
          'tag_files': has_item( PathToTestFile( 'uni¢𐍈d€', 'tags' ) )
        } ),
        'event_notification'
      )
    )


@patch( 'ycm.youcompleteme.YouCompleteMe._AddUltiSnipsDataIfNeeded' )
@YouCompleteMeInstance()
def EventNotification_BufferVisit_BuildRequestForCurrentAndUnsavedBuffers_test(
    ycm, *args ):

  current_buffer_file = os.path.realpath( 'current_buffer' )
  current_buffer = VimBuffer( name = current_buffer_file,
                              number = 1,
                              contents = [ 'current_buffer_contents' ],
                              filetype = 'some_filetype',
                              modified = False )
  modified_buffer_file = os.path.realpath( 'modified_buffer' )
  modified_buffer = VimBuffer( name = modified_buffer_file,
                               number = 2,
                               contents = [ 'modified_buffer_contents' ],
                               filetype = 'some_filetype',
                               modified = True )

  unmodified_buffer_file = os.path.realpath( 'unmodified_buffer' )
  unmodified_buffer = VimBuffer( name = unmodified_buffer_file,
                                 number = 3,
                                 contents = [ 'unmodified_buffer_contents' ],
                                 filetype = 'some_filetype',
                                 modified = False )

  with patch( 'ycm.client.event_notification.EventNotification.'
              'PostDataToHandlerAsync' ) as post_data_to_handler_async:
    with MockVimBuffers( [ current_buffer, modified_buffer, unmodified_buffer ],
                         [ current_buffer ],
                         ( 1, 5 ) ):
      ycm.OnBufferVisit()

    assert_that(
      # Positional arguments passed to PostDataToHandlerAsync.
      post_data_to_handler_async.call_args[ 0 ],
      contains(
        has_entries( {
          'filepath': current_buffer_file,
          'line_num': 1,
          'column_num': 6,
          'file_data': has_entries( {
            current_buffer_file: has_entries( {
              'contents': 'current_buffer_contents\n',
              'filetypes': [ 'some_filetype' ]
            } ),
            modified_buffer_file: has_entries( {
              'contents': 'modified_buffer_contents\n',
              'filetypes': [ 'some_filetype' ]
            } )
          } ),
          'event_name': 'BufferVisit'
        } ),
        'event_notification'
      )
    )


@YouCompleteMeInstance()
def EventNotification_BufferUnload_BuildRequestForDeletedAndUnsavedBuffers_test(
    ycm ):
  current_buffer_file = os.path.realpath( 'current_βuffer' )
  current_buffer = VimBuffer( name = current_buffer_file,
                              number = 1,
                              contents = [ 'current_buffer_contents' ],
                              filetype = 'some_filetype',
                              modified = True )

  deleted_buffer_file = os.path.realpath( 'deleted_βuffer' )
  deleted_buffer = VimBuffer( name = deleted_buffer_file,
                              number = 2,
                              contents = [ 'deleted_buffer_contents' ],
                              filetype = 'some_filetype',
                              modified = False )

  with patch( 'ycm.client.event_notification.EventNotification.'
              'PostDataToHandlerAsync' ) as post_data_to_handler_async:
    with MockVimBuffers( [ current_buffer, deleted_buffer ],
                         [ current_buffer ] ):
      ycm.OnBufferUnload( deleted_buffer.number )

  assert_that(
    # Positional arguments passed to PostDataToHandlerAsync.
    post_data_to_handler_async.call_args[ 0 ],
    contains(
      has_entries( {
        'filepath': deleted_buffer_file,
        'line_num': 1,
        'column_num': 1,
        'file_data': has_entries( {
          current_buffer_file: has_entries( {
            'contents': 'current_buffer_contents\n',
            'filetypes': [ 'some_filetype' ]
          } ),
          deleted_buffer_file: has_entries( {
            'contents': 'deleted_buffer_contents\n',
            'filetypes': [ 'some_filetype' ]
          } )
        } ),
        'event_name': 'BufferUnload'
      } ),
      'event_notification'
    )
  )


@patch( 'ycm.vimsupport.CaptureVimCommand', return_value = """
fooGroup xxx foo bar
             links to Statement""" )
@YouCompleteMeInstance( { 'g:ycm_seed_identifiers_with_syntax': 1 } )
def EventNotification_FileReadyToParse_SyntaxKeywords_SeedWithCache_test(
    ycm, *args ):

  current_buffer = VimBuffer( name = 'current_buffer',
                              filetype = 'some_filetype' )

  with patch( 'ycm.client.event_notification.EventNotification.'
              'PostDataToHandlerAsync' ) as post_data_to_handler_async:
    with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
      ycm.OnFileReadyToParse()
      assert_that(
        # Positional arguments passed to PostDataToHandlerAsync.
        post_data_to_handler_async.call_args[ 0 ],
        contains(
          has_entry( 'syntax_keywords', has_items( 'foo', 'bar' ) ),
          'event_notification'
        )
      )

      # Do not send again syntax keywords in subsequent requests.
      ycm.OnFileReadyToParse()
      assert_that(
        # Positional arguments passed to PostDataToHandlerAsync.
        post_data_to_handler_async.call_args[ 0 ],
        contains(
          is_not( has_key( 'syntax_keywords' ) ),
          'event_notification'
        )
      )


@patch( 'ycm.vimsupport.CaptureVimCommand', return_value = """
fooGroup xxx foo bar
             links to Statement""" )
@YouCompleteMeInstance( { 'g:ycm_seed_identifiers_with_syntax': 1 } )
def EventNotification_FileReadyToParse_SyntaxKeywords_ClearCacheIfRestart_test(
    ycm, *args ):

  current_buffer = VimBuffer( name = 'current_buffer',
                              filetype = 'some_filetype' )

  with patch( 'ycm.client.event_notification.EventNotification.'
              'PostDataToHandlerAsync' ) as post_data_to_handler_async:
    with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
      ycm.OnFileReadyToParse()
      assert_that(
        # Positional arguments passed to PostDataToHandlerAsync.
        post_data_to_handler_async.call_args[ 0 ],
        contains(
          has_entry( 'syntax_keywords', has_items( 'foo', 'bar' ) ),
          'event_notification'
        )
      )

      # Send again the syntax keywords after restarting the server.
      ycm.RestartServer()
      WaitUntilReady()
      ycm.OnFileReadyToParse()
      assert_that(
        # Positional arguments passed to PostDataToHandlerAsync.
        post_data_to_handler_async.call_args[ 0 ],
        contains(
          has_entry( 'syntax_keywords', has_items( 'foo', 'bar' ) ),
          'event_notification'
        )
      )
<EOF>
<BOF>
# Copyright (C) 2017-2018 YouCompleteMe Contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import MockVimBuffers, MockVimModule, VimBuffer
MockVimModule()

from hamcrest import assert_that, has_entry
from mock import patch
from ycm.client.base_request import BuildRequestData


@patch( 'ycm.client.base_request.GetCurrentDirectory',
        return_value = '/some/dir' )
def BuildRequestData_AddWorkingDir_test( *args ):
  current_buffer = VimBuffer( 'foo' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    assert_that( BuildRequestData(), has_entry( 'working_dir', '/some/dir' ) )


@patch( 'ycm.client.base_request.GetCurrentDirectory',
        return_value = '/some/dir' )
def BuildRequestData_AddWorkingDirWithFileName_test( *args ):
  current_buffer = VimBuffer( 'foo' )
  with MockVimBuffers( [ current_buffer ], [ current_buffer ] ):
    assert_that( BuildRequestData( current_buffer.number ),
                 has_entry( 'working_dir', '/some/dir' ) )
<EOF>
<BOF>
# Copyright (C) 2017 YouCompleteMe Contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from copy import deepcopy
from hamcrest import assert_that, contains_string, equal_to

from ycm.client.debug_info_request import FormatDebugInfoResponse


GENERIC_RESPONSE = {
  'clang': {
    'has_support': True,
    'version': 'Clang version'
  },
  'completer': {
    'items': [
      {
        'key': 'key',
        'value': 'value'
      }
    ],
    'name': 'Completer name',
    'servers': [
      {
        'address': '127.0.0.1',
        'executable': '/path/to/executable',
        'extras': [
          {
            'key': 'key',
            'value': 'value'
          }
        ],
        'is_running': True,
        'logfiles': [
          '/path/to/stdout/logfile',
          '/path/to/stderr/logfile'
        ],
        'name': 'Server name',
        'pid': 12345,
        'port': 1234
      }
    ]
  },
  'extra_conf': {
    'is_loaded': False,
    'path': '/path/to/extra/conf'
  },
  'python': {
    'executable': '/path/to/python/interpreter',
    'version': 'Python version'
  }
}


def FormatDebugInfoResponse_NoResponse_test():
  assert_that(
    FormatDebugInfoResponse( None ),
    equal_to( 'Server errored, no debug info from server\n' )
  )


def FormatDebugInfoResponse_NoExtraConf_test():
  response = deepcopy( GENERIC_RESPONSE )
  response[ 'extra_conf' ].update( {
    'is_loaded': False,
    'path': None
  } )
  assert_that(
    FormatDebugInfoResponse( response ),
    contains_string(
      'No extra configuration file found\n'
    )
  )


def FormatDebugInfoResponse_ExtraConfFoundButNotLoaded_test():
  response = deepcopy( GENERIC_RESPONSE )
  response[ 'extra_conf' ].update( {
    'is_loaded': False,
    'path': '/path/to/extra/conf'
  } )
  assert_that(
    FormatDebugInfoResponse( response ),
    contains_string(
      'Extra configuration file found but not loaded\n'
      'Extra configuration path: /path/to/extra/conf\n'
    )
  )


def FormatDebugInfoResponse_ExtraConfFoundAndLoaded_test():
  response = deepcopy( GENERIC_RESPONSE )
  response[ 'extra_conf' ].update( {
    'is_loaded': True,
    'path': '/path/to/extra/conf'
  } )
  assert_that(
    FormatDebugInfoResponse( response ),
    contains_string(
      'Extra configuration file found and loaded\n'
      'Extra configuration path: /path/to/extra/conf\n'
    )
  )


def FormatDebugInfoResponse_Completer_ServerRunningWithHost_test():
  response = deepcopy( GENERIC_RESPONSE )
  assert_that(
    FormatDebugInfoResponse( response ),
    contains_string(
      'Completer name completer debug information:\n'
      '  Server name running at: http://127.0.0.1:1234\n'
      '  Server name process ID: 12345\n'
      '  Server name executable: /path/to/executable\n'
      '  Server name logfiles:\n'
      '    /path/to/stdout/logfile\n'
      '    /path/to/stderr/logfile\n'
      '  Server name key: value\n'
      '  Key: value\n'
    )
  )


def FormatDebugInfoResponse_Completer_ServerRunningWithoutHost_test():
  response = deepcopy( GENERIC_RESPONSE )
  response[ 'completer' ][ 'servers' ][ 0 ].update( {
    'address': None,
    'port': None
  } )
  assert_that(
    FormatDebugInfoResponse( response ),
    contains_string(
      'Completer name completer debug information:\n'
      '  Server name running\n'
      '  Server name process ID: 12345\n'
      '  Server name executable: /path/to/executable\n'
      '  Server name logfiles:\n'
      '    /path/to/stdout/logfile\n'
      '    /path/to/stderr/logfile\n'
      '  Server name key: value\n'
      '  Key: value\n'
    )
  )


def FormatDebugInfoResponse_Completer_ServerNotRunningWithNoLogfiles_test():
  response = deepcopy( GENERIC_RESPONSE )
  response[ 'completer' ][ 'servers' ][ 0 ].update( {
    'is_running': False,
    'logfiles': []
  } )
  assert_that(
    FormatDebugInfoResponse( response ),
    contains_string(
      'Completer name completer debug information:\n'
      '  Server name not running\n'
      '  Server name executable: /path/to/executable\n'
      '  No logfiles available\n'
      '  Server name key: value\n'
      '  Key: value\n'
    )
  )
<EOF>
<BOF>
# Copyright (C) 2016 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from mock import MagicMock
from nose.tools import eq_
from hamcrest import assert_that, has_entries

from ycm.client.omni_completion_request import OmniCompletionRequest


def BuildOmnicompletionRequest( results, start_column = 1 ):
  omni_completer = MagicMock()
  omni_completer.ComputeCandidates = MagicMock( return_value = results )

  request_data = {
    'line_num': 1,
    'column_num': 1,
    'start_column': start_column
  }
  request = OmniCompletionRequest( omni_completer, request_data )
  request.Start()

  return request


def Done_AlwaysTrue_test():
  request = BuildOmnicompletionRequest( [] )

  eq_( request.Done(), True )


def Response_FromOmniCompleter_test():
  results = [ { "word": "test" } ]
  request = BuildOmnicompletionRequest( results )

  eq_( request.Response(), {
    'line': 1,
    'column': 1,
    'completion_start_column': 1,
    'completions': results
  } )


def RawResponse_ConvertedFromOmniCompleter_test():
  vim_results = [
    { "word": "WORD", "abbr": "ABBR", "menu": "MENU",
      "kind": "KIND", "info": "INFO" },
    { "word": "WORD2", "abbr": "ABBR2", "menu": "MENU2",
      "kind": "KIND2", "info": "INFO" },
    { "word": "WORD", "abbr": "ABBR", },
    {},
  ]
  expected_results = [
    has_entries( { "insertion_text": "WORD", "menu_text": "ABBR",
                   "extra_menu_info": "MENU", "kind": [ "KIND" ],
                   "detailed_info": "INFO" } ),
    has_entries( { "insertion_text": "WORD2", "menu_text": "ABBR2",
                   "extra_menu_info": "MENU2", "kind": [ "KIND2" ],
                   "detailed_info": "INFO" } ),
    has_entries( { "insertion_text": "WORD", "menu_text": "ABBR", } ),
    has_entries( {} ),
  ]
  request = BuildOmnicompletionRequest( vim_results )

  results = request.RawResponse()[ 'completions' ]

  eq_( len( results ), len( expected_results ) )
  for result, expected_result in zip( results, expected_results ):
    assert_that( result, expected_result )
<EOF>
<BOF>
# Copyright (C) 2016 YouCompleteMe Contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import ExtendedMock, MockVimModule
MockVimModule()

import json
from mock import patch, call
from nose.tools import ok_
from ycm.client.command_request import CommandRequest


class GoToResponse_QuickFix_test( object ):
  """This class tests the generation of QuickFix lists for GoTo responses which
  return multiple locations, such as the Python completer and JavaScript
  completer. It mostly proves that we use 1-based indexing for the column
  number."""

  def setUp( self ):
    self._request = CommandRequest( [ 'GoToTest' ] )


  def tearDown( self ):
    self._request = None


  def GoTo_EmptyList_test( self ):
    self._CheckGoToList( [], [] )


  def GoTo_SingleItem_List_test( self ):
    self._CheckGoToList( [ {
      'filepath':     'dummy_file',
      'line_num':     10,
      'column_num':   1,
      'description': 'this is some text',
    } ], [ {
      'filename':    'dummy_file',
      'text':        'this is some text',
      'lnum':        10,
      'col':         1
    } ] )


  def GoTo_MultiItem_List_test( self ):
    self._CheckGoToList( [ {
      'filepath':     'dummy_file',
      'line_num':     10,
      'column_num':   1,
      'description': 'this is some other text',
    }, {
      'filepath':     'dummy_file2',
      'line_num':     1,
      'column_num':   21,
      'description': 'this is some text',
    } ], [ {
      'filename':    'dummy_file',
      'text':        'this is some other text',
      'lnum':        10,
      'col':         1
    }, {
      'filename':    'dummy_file2',
      'text':        'this is some text',
      'lnum':        1,
      'col':         21
    } ] )


  @patch( 'ycm.vimsupport.VariableExists', return_value = True )
  @patch( 'ycm.vimsupport.SetFittingHeightForCurrentWindow' )
  @patch( 'vim.command', new_callable = ExtendedMock )
  @patch( 'vim.eval', new_callable = ExtendedMock )
  def _CheckGoToList( self,
                      completer_response,
                      expected_qf_list,
                      vim_eval,
                      vim_command,
                      set_fitting_height,
                      variable_exists ):
    self._request._response = completer_response

    self._request.RunPostCommandActionsIfNeeded( 'aboveleft' )

    vim_eval.assert_has_exact_calls( [
      call( 'setqflist( {0} )'.format( json.dumps( expected_qf_list ) ) )
    ] )
    vim_command.assert_has_exact_calls( [
      call( 'botright copen' ),
      call( 'au WinLeave <buffer> q' ),
      call( 'doautocmd User YcmQuickFixOpened' )
    ] )
    set_fitting_height.assert_called_once_with()


class Response_Detection_test( object ):

  def BasicResponse_test( self ):
    def _BasicResponseTest( command, response ):
      with patch( 'vim.command' ) as vim_command:
        request = CommandRequest( [ command ] )
        request._response = response
        request.RunPostCommandActionsIfNeeded( 'belowright' )
        vim_command.assert_called_with( "echo '{0}'".format( response ) )

    tests = [
      [ 'AnythingYouLike',        True ],
      [ 'GoToEvenWorks',          10 ],
      [ 'FixItWorks',             'String!' ],
      [ 'and8434fd andy garbag!', 10.3 ],
    ]

    for test in tests:
      yield _BasicResponseTest, test[ 0 ], test[ 1 ]


  def FixIt_Response_Empty_test( self ):
    # Ensures we recognise and handle fixit responses which indicate that there
    # are no fixits available
    def EmptyFixItTest( command ):
      with patch( 'ycm.vimsupport.ReplaceChunks' ) as replace_chunks:
        with patch( 'ycm.vimsupport.PostVimMessage' ) as post_vim_message:
          request = CommandRequest( [ command ] )
          request._response = {
            'fixits': []
          }
          request.RunPostCommandActionsIfNeeded( 'botright' )

          post_vim_message.assert_called_with(
            'No fixits found for current line', warning = False )
          replace_chunks.assert_not_called()

    for test in [ 'FixIt', 'Refactor', 'GoToHell', 'any_old_garbade!!!21' ]:
      yield EmptyFixItTest, test


  def FixIt_Response_test( self ):
    # Ensures we recognise and handle fixit responses with some dummy chunk data
    def FixItTest( command, response, chunks, selection, silent ):
      with patch( 'ycm.vimsupport.ReplaceChunks' ) as replace_chunks:
        with patch( 'ycm.vimsupport.PostVimMessage' ) as post_vim_message:
          with patch( 'ycm.vimsupport.SelectFromList',
                      return_value = selection ):
            request = CommandRequest( [ command ] )
            request._response = response
            request.RunPostCommandActionsIfNeeded( 'leftabove' )

            replace_chunks.assert_called_with( chunks, silent = silent )
            post_vim_message.assert_not_called()

    basic_fixit = {
      'fixits': [ {
        'chunks': [ {
          'dummy chunk contents': True
        } ]
      } ]
    }
    basic_fixit_chunks = basic_fixit[ 'fixits' ][ 0 ][ 'chunks' ]

    multi_fixit = {
      'fixits': [ {
        'text': 'first',
        'chunks': [ {
          'dummy chunk contents': True
        } ]
      }, {
        'text': 'second',
        'chunks': [ {
          'dummy chunk contents': False
        } ]
      } ]
    }
    multi_fixit_first_chunks = multi_fixit[ 'fixits' ][ 0 ][ 'chunks' ]
    multi_fixit_second_chunks = multi_fixit[ 'fixits' ][ 1 ][ 'chunks' ]

    tests = [
      [ 'AnythingYouLike',
        basic_fixit,  basic_fixit_chunks,        0, False ],
      [ 'GoToEvenWorks',
        basic_fixit,  basic_fixit_chunks,        0, False ],
      [ 'FixItWorks',
        basic_fixit,  basic_fixit_chunks,        0, False ],
      [ 'and8434fd andy garbag!',
        basic_fixit,  basic_fixit_chunks,        0, False ],
      [ 'Format',
        basic_fixit,  basic_fixit_chunks,        0, True ],
      [ 'select from multiple 1',
        multi_fixit,  multi_fixit_first_chunks,  0, False ],
      [ 'select from multiple 2',
        multi_fixit,  multi_fixit_second_chunks, 1, False ],
    ]

    for test in tests:
      yield FixItTest, test[ 0 ], test[ 1 ], test[ 2 ], test[ 3 ], test[ 4 ]


  def Message_Response_test( self ):
    # Ensures we correctly recognise and handle responses with a message to show
    # to the user

    def MessageTest( command, message ):
      with patch( 'ycm.vimsupport.PostVimMessage' ) as post_vim_message:
        request = CommandRequest( [ command ] )
        request._response = { 'message': message }
        request.RunPostCommandActionsIfNeeded( 'rightbelow' )
        post_vim_message.assert_called_with( message, warning = False )

    tests = [
      [ '___________', 'This is a message' ],
      [ '',            'this is also a message' ],
      [ 'GetType',     'std::string' ],
    ]

    for test in tests:
      yield MessageTest, test[ 0 ], test[ 1 ]


  def Detailed_Info_test( self ):
    # Ensures we correctly detect and handle detailed_info responses which are
    # used to display information in the preview window

    def DetailedInfoTest( command, info ):
      with patch( 'ycm.vimsupport.WriteToPreviewWindow' ) as write_to_preview:
        request = CommandRequest( [ command ] )
        request._response = { 'detailed_info': info }
        request.RunPostCommandActionsIfNeeded( 'topleft' )
        write_to_preview.assert_called_with( info )

    tests = [
      [ '___________', 'This is a message' ],
      [ '',            'this is also a message' ],
      [ 'GetDoc',      'std::string\netc\netc' ],
    ]

    for test in tests:
      yield DetailedInfoTest, test[ 0 ], test[ 1 ]


  def GoTo_Single_test( self ):
    # Ensures we handle any unknown type of response as a GoTo response

    def GoToTest( command, response ):
      with patch( 'ycm.vimsupport.JumpToLocation' ) as jump_to_location:
        request = CommandRequest( [ command ] )
        request._response = response
        request.RunPostCommandActionsIfNeeded( 'rightbelow' )
        jump_to_location.assert_called_with(
            response[ 'filepath' ],
            response[ 'line_num' ],
            response[ 'column_num' ],
            'rightbelow',
            'same-buffer' )

    def GoToListTest( command, response ):
      # Note: the detail of these called are tested by
      # GoToResponse_QuickFix_test, so here we just check that the right call is
      # made
      with patch( 'ycm.vimsupport.SetQuickFixList' ) as set_qf_list:
        with patch( 'ycm.vimsupport.OpenQuickFixList' ) as open_qf_list:
          request = CommandRequest( [ command ] )
          request._response = response
          request.RunPostCommandActionsIfNeeded( 'tab' )
          ok_( set_qf_list.called )
          ok_( open_qf_list.called )

    basic_goto = {
      'filepath': 'test',
      'line_num': 10,
      'column_num': 100,
    }

    tests = [
      [ GoToTest,     'AnythingYouLike', basic_goto ],
      [ GoToTest,     'GoTo',            basic_goto ],
      [ GoToTest,     'FindAThing',      basic_goto ],
      [ GoToTest,     'FixItGoto',       basic_goto ],
      [ GoToListTest, 'AnythingYouLike', [ basic_goto ] ],
      [ GoToListTest, 'GoTo',            [] ],
      [ GoToListTest, 'FixItGoto',       [ basic_goto, basic_goto ] ],
    ]

    for test in tests:
      yield test[ 0 ], test[ 1 ], test[ 2 ]
<EOF>
<BOF>
# Copyright (C) 2017 YouCompleteMe Contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.


from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.tests.test_utils import MockVimModule
MockVimModule()

from hamcrest import assert_that, equal_to
from mock import patch, call

from ycm.client.messages_request import _HandlePollResponse
from ycm.tests.test_utils import ExtendedMock


def HandlePollResponse_NoMessages_test():
  assert_that( _HandlePollResponse( True, None ), equal_to( True ) )

  # Other non-False responses mean the same thing
  assert_that( _HandlePollResponse( '', None ), equal_to( True ) )
  assert_that( _HandlePollResponse( 1, None ), equal_to( True ) )
  assert_that( _HandlePollResponse( {}, None ), equal_to( True ) )


def HandlePollResponse_PollingNotSupported_test():
  assert_that( _HandlePollResponse( False, None ), equal_to( False ) )

  # 0 is not False
  assert_that( _HandlePollResponse( 0, None ), equal_to( True ) )


@patch( 'ycm.client.messages_request.PostVimMessage',
        new_callable = ExtendedMock )
def HandlePollResponse_SingleMessage_test( post_vim_message ):
  assert_that( _HandlePollResponse( [ { 'message': 'this is a message' } ] ,
                                    None ),
               equal_to( True ) )

  post_vim_message.assert_has_exact_calls( [
    call( 'this is a message', warning=False, truncate=True )
  ] )


@patch( 'ycm.client.messages_request.PostVimMessage',
        new_callable = ExtendedMock )
def HandlePollResponse_MultipleMessages_test( post_vim_message ):
  assert_that( _HandlePollResponse( [ { 'message': 'this is a message' },
                                      { 'message': 'this is another one' } ] ,
                                    None ),
               equal_to( True ) )

  post_vim_message.assert_has_exact_calls( [
    call( 'this is a message', warning=False, truncate=True ),
    call( 'this is another one', warning=False, truncate=True )
  ] )


def HandlePollResponse_SingleDiagnostic_test():
  diagnostics_handler = ExtendedMock()
  messages = [
    { 'filepath': 'foo', 'diagnostics': [ 'PLACEHOLDER' ] },
  ]
  assert_that( _HandlePollResponse( messages, diagnostics_handler ),
               equal_to( True ) )
  diagnostics_handler.UpdateWithNewDiagnosticsForFile.assert_has_exact_calls( [
    call( 'foo', [ 'PLACEHOLDER' ] )
  ] )


def HandlePollResponse_MultipleDiagnostics_test():
  diagnostics_handler = ExtendedMock()
  messages = [
    { 'filepath': 'foo', 'diagnostics': [ 'PLACEHOLDER1' ] },
    { 'filepath': 'bar', 'diagnostics': [ 'PLACEHOLDER2' ] },
    { 'filepath': 'baz', 'diagnostics': [ 'PLACEHOLDER3' ] },
    { 'filepath': 'foo', 'diagnostics': [ 'PLACEHOLDER4' ] },
  ]
  assert_that( _HandlePollResponse( messages, diagnostics_handler ),
               equal_to( True ) )
  diagnostics_handler.UpdateWithNewDiagnosticsForFile.assert_has_exact_calls( [
    call( 'foo', [ 'PLACEHOLDER1' ] ),
    call( 'bar', [ 'PLACEHOLDER2' ] ),
    call( 'baz', [ 'PLACEHOLDER3' ] ),
    call( 'foo', [ 'PLACEHOLDER4' ] )
  ] )


@patch( 'ycm.client.messages_request.PostVimMessage',
        new_callable = ExtendedMock )
def HandlePollResponse_MultipleMessagesAndDiagnostics_test( post_vim_message ):
  diagnostics_handler = ExtendedMock()
  messages = [
    { 'filepath': 'foo', 'diagnostics': [ 'PLACEHOLDER1' ] },
    { 'message': 'On the first day of Christmas, my VimScript gave to me' },
    { 'filepath': 'bar', 'diagnostics': [ 'PLACEHOLDER2' ] },
    { 'message': 'A test file in a Command-T' },
    { 'filepath': 'baz', 'diagnostics': [ 'PLACEHOLDER3' ] },
    { 'message': 'On the second day of Christmas, my VimScript gave to me' },
    { 'filepath': 'foo', 'diagnostics': [ 'PLACEHOLDER4' ] },
    { 'message': 'Two popup menus, and a test file in a Command-T' },
  ]
  assert_that( _HandlePollResponse( messages, diagnostics_handler ),
               equal_to( True ) )
  diagnostics_handler.UpdateWithNewDiagnosticsForFile.assert_has_exact_calls( [
    call( 'foo', [ 'PLACEHOLDER1' ] ),
    call( 'bar', [ 'PLACEHOLDER2' ] ),
    call( 'baz', [ 'PLACEHOLDER3' ] ),
    call( 'foo', [ 'PLACEHOLDER4' ] )
  ] )

  post_vim_message.assert_has_exact_calls( [
    call( 'On the first day of Christmas, my VimScript gave to me',
          warning=False,
          truncate=True ),
    call( 'A test file in a Command-T', warning=False, truncate=True ),
    call( 'On the second day of Christmas, my VimScript gave to me',
          warning=False,
          truncate=True ),
    call( 'Two popup menus, and a test file in a Command-T',
          warning=False,
          truncate=True ),
  ] )
<EOF>
<BOF>
# Copyright (C) 2015-2016 YouCompleteMe Contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from nose.tools import eq_
from ycm.tests.test_utils import MockVimModule
vim_mock = MockVimModule()

from ycm.client import completion_request


class ConvertCompletionResponseToVimDatas_test( object ):
  """ This class tests the
      completion_request._ConvertCompletionResponseToVimDatas method """

  def _Check( self, completion_id, completion_data, expected_vim_data ):
    vim_data = completion_request._ConvertCompletionDataToVimData(
        completion_id,
        completion_data )

    try:
      eq_( expected_vim_data, vim_data )
    except Exception:
      print( "Expected:\n'{0}'\nwhen parsing:\n'{1}'\nBut found:\n'{2}'".format(
          expected_vim_data,
          completion_data,
          vim_data ) )
      raise


  def AllFields_test( self ):
    self._Check( 0, {
      'insertion_text':  'INSERTION TEXT',
      'menu_text':       'MENU TEXT',
      'extra_menu_info': 'EXTRA MENU INFO',
      'kind':            'K',
      'detailed_info':   'DETAILED INFO',
      'extra_data': {
        'doc_string':    'DOC STRING',
      },
    }, {
      'word'     : 'INSERTION TEXT',
      'abbr'     : 'MENU TEXT',
      'menu'     : 'EXTRA MENU INFO',
      'kind'     : 'k',
      'info'     : 'DETAILED INFO\nDOC STRING',
      'dup'      : 1,
      'empty'    : 1,
      'user_data': '0',
    } )


  def OnlyInsertionTextField_test( self ):
    self._Check( 17, {
      'insertion_text':  'INSERTION TEXT'
    }, {
      'word'     : 'INSERTION TEXT',
      'abbr'     : '',
      'menu'     : '',
      'kind'     : '',
      'info'     : '',
      'dup'      : 1,
      'empty'    : 1,
      'user_data': '17',
    } )


  def JustDetailedInfo_test( self ):
    self._Check( 9999999999, {
      'insertion_text':  'INSERTION TEXT',
      'menu_text':       'MENU TEXT',
      'extra_menu_info': 'EXTRA MENU INFO',
      'kind':            'K',
      'detailed_info':   'DETAILED INFO',
    }, {
      'word'     : 'INSERTION TEXT',
      'abbr'     : 'MENU TEXT',
      'menu'     : 'EXTRA MENU INFO',
      'kind'     : 'k',
      'info'     : 'DETAILED INFO',
      'dup'      : 1,
      'empty'    : 1,
      'user_data': '9999999999',
    } )


  def JustDocString_test( self ):
    self._Check( 'not_an_int', {
      'insertion_text':  'INSERTION TEXT',
      'menu_text':       'MENU TEXT',
      'extra_menu_info': 'EXTRA MENU INFO',
      'kind':            'K',
      'extra_data': {
        'doc_string':    'DOC STRING',
      },
    }, {
      'word'     : 'INSERTION TEXT',
      'abbr'     : 'MENU TEXT',
      'menu'     : 'EXTRA MENU INFO',
      'kind'     : 'k',
      'info'     : 'DOC STRING',
      'dup'      : 1,
      'empty'    : 1,
      'user_data': 'not_an_int',
    } )


  def ExtraInfoNoDocString_test( self ):
    self._Check( 0, {
      'insertion_text':  'INSERTION TEXT',
      'menu_text':       'MENU TEXT',
      'extra_menu_info': 'EXTRA MENU INFO',
      'kind':            'K',
      'extra_data': {
      },
    }, {
      'word'     : 'INSERTION TEXT',
      'abbr'     : 'MENU TEXT',
      'menu'     : 'EXTRA MENU INFO',
      'kind'     : 'k',
      'info'     : '',
      'dup'      : 1,
      'empty'    : 1,
      'user_data': '0',
    } )


  def NullCharactersInExtraInfoAndDocString_test( self ):
    self._Check( '0', {
      'insertion_text':  'INSERTION TEXT',
      'menu_text':       'MENU TEXT',
      'extra_menu_info': 'EXTRA MENU INFO',
      'kind':            'K',
      'detailed_info':   'DETAILED\x00INFO',
      'extra_data': {
        'doc_string': 'DOC\x00STRING'
      },
    }, {
      'word'     : 'INSERTION TEXT',
      'abbr'     : 'MENU TEXT',
      'menu'     : 'EXTRA MENU INFO',
      'kind'     : 'k',
      'info'     : 'DETAILEDINFO\nDOCSTRING',
      'dup'      : 1,
      'empty'    : 1,
      'user_data': '0',
    } )


  def ExtraInfoNoDocStringWithDetailedInfo_test( self ):
    self._Check( '0', {
      'insertion_text':  'INSERTION TEXT',
      'menu_text':       'MENU TEXT',
      'extra_menu_info': 'EXTRA MENU INFO',
      'kind':            'K',
      'detailed_info':   'DETAILED INFO',
      'extra_data': {
      },
    }, {
      'word'     : 'INSERTION TEXT',
      'abbr'     : 'MENU TEXT',
      'menu'     : 'EXTRA MENU INFO',
      'kind'     : 'k',
      'info'     : 'DETAILED INFO',
      'dup'      : 1,
      'empty'    : 1,
      'user_data': '0',
    } )


  def EmptyInsertionText_test( self ):
    self._Check( 0, {
      'insertion_text':  '',
      'menu_text':       'MENU TEXT',
      'extra_menu_info': 'EXTRA MENU INFO',
      'kind':            'K',
      'detailed_info':   'DETAILED INFO',
      'extra_data': {
        'doc_string':    'DOC STRING',
      },
    }, {
      'word'     : '',
      'abbr'     : 'MENU TEXT',
      'menu'     : 'EXTRA MENU INFO',
      'kind'     : 'k',
      'info'     : 'DETAILED INFO\nDOC STRING',
      'dup'      : 1,
      'empty'    : 1,
      'user_data': '0',
    } )
<EOF>
<BOF>
# Copyright (C) 2013  Google Inc.
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.client.completion_request import CompletionRequest


class OmniCompletionRequest( CompletionRequest ):
  def __init__( self, omni_completer, request_data ):
    super( OmniCompletionRequest, self ).__init__( request_data )
    self._omni_completer = omni_completer


  def Start( self ):
    self._results = self._omni_completer.ComputeCandidates( self.request_data )


  def Done( self ):
    return True


  def RawResponse( self ):
    return {
      'line': self.request_data[ 'line_num' ],
      'column': self.request_data[ 'column_num' ],
      'completion_start_column': self.request_data[ 'start_column' ],
      'completions': _ConvertVimDatasToCompletionDatas( self._results )
    }


  def Response( self ):
    return {
      'line': self.request_data[ 'line_num' ],
      'column': self.request_data[ 'column_num' ],
      'completion_start_column': self.request_data[ 'start_column' ],
      'completions': self._results
    }


def ConvertVimDataToCompletionData( vim_data ):
  # see :h complete-items for a description of the dictionary fields
  completion_data = {}

  if 'word' in vim_data:
    completion_data[ 'insertion_text' ] = vim_data[ 'word' ]
  if 'abbr' in vim_data:
    completion_data[ 'menu_text' ] = vim_data[ 'abbr' ]
  if 'menu' in vim_data:
    completion_data[ 'extra_menu_info' ] = vim_data[ 'menu' ]
  if 'kind' in vim_data:
    completion_data[ 'kind' ] = [ vim_data[ 'kind' ] ]
  if 'info' in vim_data:
    completion_data[ 'detailed_info' ] = vim_data[ 'info' ]

  return completion_data


def _ConvertVimDatasToCompletionDatas( response_data ):
  return [ ConvertVimDataToCompletionData( x )
           for x in response_data ]
<EOF>
<BOF>
# Copyright (C) 2013  Google Inc.
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.client.base_request import BaseRequest, BuildRequestData
from ycm import vimsupport
from ycmd.utils import ToUnicode


def _EnsureBackwardsCompatibility( arguments ):
  if arguments and arguments[ 0 ] == 'GoToDefinitionElseDeclaration':
    arguments[ 0 ] = 'GoTo'
  return arguments


class CommandRequest( BaseRequest ):
  def __init__( self,
                arguments,
                buffer_command = 'same-buffer',
                extra_data = None ):
    super( CommandRequest, self ).__init__()
    self._arguments = _EnsureBackwardsCompatibility( arguments )
    self._command = arguments and arguments[ 0 ]
    self._buffer_command = buffer_command
    self._extra_data = extra_data
    self._response = None


  def Start( self ):
    request_data = BuildRequestData()
    if self._extra_data:
      request_data.update( self._extra_data )
    request_data.update( {
      'command_arguments': self._arguments
    } )
    self._response = self.PostDataToHandler( request_data,
                                             'run_completer_command' )


  def Response( self ):
    return self._response


  def RunPostCommandActionsIfNeeded( self, modifiers ):
    if not self.Done() or self._response is None:
      return

    # If not a dictionary or a list, the response is necessarily a
    # scalar: boolean, number, string, etc. In this case, we print
    # it to the user.
    if not isinstance( self._response, ( dict, list ) ):
      return self._HandleBasicResponse()

    if 'fixits' in self._response:
      return self._HandleFixitResponse()

    if 'message' in self._response:
      return self._HandleMessageResponse()

    if 'detailed_info' in self._response:
      return self._HandleDetailedInfoResponse()

    # The only other type of response we understand is GoTo, and that is the
    # only one that we can't detect just by inspecting the response (it should
    # either be a single location or a list)
    return self._HandleGotoResponse( modifiers )


  def _HandleGotoResponse( self, modifiers ):
    if isinstance( self._response, list ):
      vimsupport.SetQuickFixList(
        [ _BuildQfListItem( x ) for x in self._response ] )
      vimsupport.OpenQuickFixList( focus = True, autoclose = True )
    else:
      vimsupport.JumpToLocation( self._response[ 'filepath' ],
                                 self._response[ 'line_num' ],
                                 self._response[ 'column_num' ],
                                 modifiers,
                                 self._buffer_command )


  def _HandleFixitResponse( self ):
    if not len( self._response[ 'fixits' ] ):
      vimsupport.PostVimMessage( 'No fixits found for current line',
                                 warning = False )
    else:
      try:
        fixit_index = 0

        # When there are multiple fixit suggestions, present them as a list to
        # the user hand have her choose which one to apply.
        if len( self._response[ 'fixits' ] ) > 1:
          fixit_index = vimsupport.SelectFromList(
            "Multiple FixIt suggestions are available at this location. "
            "Which one would you like to apply?",
            [ fixit[ 'text' ] for fixit in self._response[ 'fixits' ] ] )

        vimsupport.ReplaceChunks(
          self._response[ 'fixits' ][ fixit_index ][ 'chunks' ],
          silent = self._command == 'Format' )
      except RuntimeError as e:
        vimsupport.PostVimMessage( str( e ) )


  def _HandleBasicResponse( self ):
    vimsupport.PostVimMessage( self._response, warning = False )


  def _HandleMessageResponse( self ):
    vimsupport.PostVimMessage( self._response[ 'message' ], warning = False )


  def _HandleDetailedInfoResponse( self ):
    vimsupport.WriteToPreviewWindow( self._response[ 'detailed_info' ] )


def SendCommandRequest( arguments,
                        modifiers,
                        buffer_command,
                        extra_data = None ):
  request = CommandRequest( arguments, buffer_command, extra_data )
  # This is a blocking call.
  request.Start()
  request.RunPostCommandActionsIfNeeded( modifiers )
  return request.Response()


def _BuildQfListItem( goto_data_item ):
  qf_item = {}
  if 'filepath' in goto_data_item:
    qf_item[ 'filename' ] = ToUnicode( goto_data_item[ 'filepath' ] )
  if 'description' in goto_data_item:
    qf_item[ 'text' ] = ToUnicode( goto_data_item[ 'description' ] )
  if 'line_num' in goto_data_item:
    qf_item[ 'lnum' ] = goto_data_item[ 'line_num' ]
  if 'column_num' in goto_data_item:
    # ycmd returns columns 1-based, and QuickFix lists require "byte offsets".
    # See :help getqflist and equivalent comment in
    # vimsupport.ConvertDiagnosticsToQfList.
    #
    # When the Vim help says "byte index", it really means "1-based column
    # number" (which is somewhat confusing). :help getqflist states "first
    # column is 1".
    qf_item[ 'col' ] = goto_data_item[ 'column_num' ]

  return qf_item
<EOF>
<BOF>
# Copyright (C) 2013-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

import logging
import json
import vim
from future.utils import native
from base64 import b64decode, b64encode
from ycm import vimsupport
from ycmd.utils import ToBytes, urljoin, urlparse, GetCurrentDirectory
from ycmd.hmac_utils import CreateRequestHmac, CreateHmac, SecureBytesEqual
from ycmd.responses import ServerError, UnknownExtraConf

_HEADERS = { 'content-type': 'application/json' }
_CONNECT_TIMEOUT_SEC = 0.01
# Setting this to None seems to screw up the Requests/urllib3 libs.
_READ_TIMEOUT_SEC = 30
_HMAC_HEADER = 'x-ycm-hmac'
_logger = logging.getLogger( __name__ )


class BaseRequest( object ):

  def __init__( self ):
    self._should_resend = False


  def Start( self ):
    pass


  def Done( self ):
    return True


  def Response( self ):
    return {}


  def ShouldResend( self ):
    return self._should_resend


  def HandleFuture( self,
                    future,
                    display_message = True,
                    truncate_message = False ):
    """Get the server response from a |future| object and catch any exception
    while doing so. If an exception is raised because of a unknown
    .ycm_extra_conf.py file, load the file or ignore it after asking the user.
    An identical request should be sent again to the server. For other
    exceptions, log the exception and display its message to the user on the Vim
    status line. Unset the |display_message| parameter to hide the message from
    the user. Set the |truncate_message| parameter to avoid hit-enter prompts
    from this message."""
    try:
      try:
        return _JsonFromFuture( future )
      except UnknownExtraConf as e:
        if vimsupport.Confirm( str( e ) ):
          _LoadExtraConfFile( e.extra_conf_file )
        else:
          _IgnoreExtraConfFile( e.extra_conf_file )
        self._should_resend = True
    except BaseRequest.Requests().exceptions.ConnectionError as e:
      # We don't display this exception to the user since it is likely to happen
      # for each subsequent request (typically if the server crashed) and we
      # don't want to spam the user with it.
      _logger.error( e )
    except Exception as e:
      _logger.exception( 'Error while handling server response' )
      if display_message:
        DisplayServerException( e, truncate_message )

    return None


  # This method blocks
  # |timeout| is num seconds to tolerate no response from server before giving
  # up; see Requests docs for details (we just pass the param along).
  # See the HandleFuture method for the |display_message| and |truncate_message|
  # parameters.
  def GetDataFromHandler( self,
                          handler,
                          timeout = _READ_TIMEOUT_SEC,
                          display_message = True,
                          truncate_message = False ):
    return self.HandleFuture(
        BaseRequest._TalkToHandlerAsync( '', handler, 'GET', timeout ),
        display_message,
        truncate_message )


  # This is the blocking version of the method. See below for async.
  # |timeout| is num seconds to tolerate no response from server before giving
  # up; see Requests docs for details (we just pass the param along).
  # See the HandleFuture method for the |display_message| and |truncate_message|
  # parameters.
  def PostDataToHandler( self,
                         data,
                         handler,
                         timeout = _READ_TIMEOUT_SEC,
                         display_message = True,
                         truncate_message = False ):
    return self.HandleFuture(
        BaseRequest.PostDataToHandlerAsync( data, handler, timeout ),
        display_message,
        truncate_message )


  # This returns a future! Use HandleFuture to get the value.
  # |timeout| is num seconds to tolerate no response from server before giving
  # up; see Requests docs for details (we just pass the param along).
  @staticmethod
  def PostDataToHandlerAsync( data, handler, timeout = _READ_TIMEOUT_SEC ):
    return BaseRequest._TalkToHandlerAsync( data, handler, 'POST', timeout )


  # This returns a future! Use HandleFuture to get the value.
  # |method| is either 'POST' or 'GET'.
  # |timeout| is num seconds to tolerate no response from server before giving
  # up; see Requests docs for details (we just pass the param along).
  @staticmethod
  def _TalkToHandlerAsync( data,
                           handler,
                           method,
                           timeout = _READ_TIMEOUT_SEC ):
    request_uri = _BuildUri( handler )
    if method == 'POST':
      sent_data = _ToUtf8Json( data )
      return BaseRequest.Session().post(
          request_uri,
          data = sent_data,
          headers = BaseRequest._ExtraHeaders( method,
                                               request_uri,
                                               sent_data ),
          timeout = ( _CONNECT_TIMEOUT_SEC, timeout ) )
    return BaseRequest.Session().get(
        request_uri,
        headers = BaseRequest._ExtraHeaders( method, request_uri ),
        timeout = ( _CONNECT_TIMEOUT_SEC, timeout ) )


  @staticmethod
  def _ExtraHeaders( method, request_uri, request_body = None ):
    if not request_body:
      request_body = bytes( b'' )
    headers = dict( _HEADERS )
    headers[ _HMAC_HEADER ] = b64encode(
        CreateRequestHmac( ToBytes( method ),
                           ToBytes( urlparse( request_uri ).path ),
                           request_body,
                           BaseRequest.hmac_secret ) )
    return headers


  # These two methods exist to avoid importing the requests module at startup;
  # reducing loading time since this module is slow to import.
  @classmethod
  def Requests( cls ):
    try:
      return cls.requests
    except AttributeError:
      import requests
      cls.requests = requests
      return requests


  @classmethod
  def Session( cls ):
    try:
      return cls.session
    except AttributeError:
      from ycm.unsafe_thread_pool_executor import UnsafeThreadPoolExecutor
      from requests_futures.sessions import FuturesSession
      executor = UnsafeThreadPoolExecutor( max_workers = 30 )
      cls.session = FuturesSession( executor = executor )
      return cls.session


  server_location = ''
  hmac_secret = ''


def BuildRequestData( buffer_number = None ):
  """Build request for the current buffer or the buffer with number
  |buffer_number| if specified."""
  working_dir = GetCurrentDirectory()
  current_buffer = vim.current.buffer

  if buffer_number and current_buffer.number != buffer_number:
    # Cursor position is irrelevant when filepath is not the current buffer.
    buffer_object = vim.buffers[ buffer_number ]
    filepath = vimsupport.GetBufferFilepath( buffer_object )
    return {
      'filepath': filepath,
      'line_num': 1,
      'column_num': 1,
      'working_dir': working_dir,
      'file_data': vimsupport.GetUnsavedAndSpecifiedBufferData( buffer_object,
                                                                filepath )
    }

  current_filepath = vimsupport.GetBufferFilepath( current_buffer )
  line, column = vimsupport.CurrentLineAndColumn()

  return {
    'filepath': current_filepath,
    'line_num': line + 1,
    'column_num': column + 1,
    'working_dir': working_dir,
    'file_data': vimsupport.GetUnsavedAndSpecifiedBufferData( current_buffer,
                                                              current_filepath )
  }


def _JsonFromFuture( future ):
  response = future.result()
  _ValidateResponseObject( response )
  if response.status_code == BaseRequest.Requests().codes.server_error:
    raise MakeServerException( response.json() )

  # We let Requests handle the other status types, we only handle the 500
  # error code.
  response.raise_for_status()

  if response.text:
    return response.json()
  return None


def _LoadExtraConfFile( filepath ):
  BaseRequest().PostDataToHandler( { 'filepath': filepath },
                                   'load_extra_conf_file' )


def _IgnoreExtraConfFile( filepath ):
  BaseRequest().PostDataToHandler( { 'filepath': filepath },
                                   'ignore_extra_conf_file' )


def DisplayServerException( exception, truncate_message = False ):
  serialized_exception = str( exception )

  # We ignore the exception about the file already being parsed since it comes
  # up often and isn't something that's actionable by the user.
  if 'already being parsed' in serialized_exception:
    return
  vimsupport.PostVimMessage( serialized_exception, truncate = truncate_message )


def _ToUtf8Json( data ):
  return ToBytes( json.dumps( data ) if data else None )


def _ValidateResponseObject( response ):
  our_hmac = CreateHmac( response.content, BaseRequest.hmac_secret )
  their_hmac = ToBytes( b64decode( response.headers[ _HMAC_HEADER ] ) )
  if not SecureBytesEqual( our_hmac, their_hmac ):
    raise RuntimeError( 'Received invalid HMAC for response!' )
  return True


def _BuildUri( handler ):
  return native( ToBytes( urljoin( BaseRequest.server_location, handler ) ) )


def MakeServerException( data ):
  if data[ 'exception' ][ 'TYPE' ] == UnknownExtraConf.__name__:
    return UnknownExtraConf( data[ 'exception' ][ 'extra_conf_file' ] )

  return ServerError( '{0}: {1}'.format( data[ 'exception' ][ 'TYPE' ],
                                         data[ 'message' ] ) )
<EOF>
<BOF>
# Copyright (C) 2013  Google Inc.
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

import time
from threading import Thread
from ycm.client.base_request import BaseRequest


# This class can be used to keep the ycmd server alive for the duration of the
# life of the client. By default, ycmd shuts down if it doesn't see a request in
# a while.
class YcmdKeepalive( object ):
  def __init__( self, ping_interval_seconds = 60 * 10 ):
    self._keepalive_thread = Thread( target = self._ThreadMain )
    self._keepalive_thread.daemon = True
    self._ping_interval_seconds = ping_interval_seconds


  def Start( self ):
    self._keepalive_thread.start()


  def _ThreadMain( self ):
    while True:
      time.sleep( self._ping_interval_seconds )

      BaseRequest().GetDataFromHandler( 'healthy', display_message = False )
<EOF>
<BOF>
# Copyright (C) 2017 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.client.base_request import BaseRequest, BuildRequestData
from ycm.vimsupport import PostVimMessage

import logging

_logger = logging.getLogger( __name__ )

# Looooong poll
TIMEOUT_SECONDS = 60


class MessagesPoll( BaseRequest ):
  def __init__( self ):
    super( MessagesPoll, self ).__init__()
    self._request_data = BuildRequestData()
    self._response_future = None


  def _SendRequest( self ):
    self._response_future = self.PostDataToHandlerAsync(
      self._request_data,
      'receive_messages',
      timeout = TIMEOUT_SECONDS )
    return


  def Poll( self, diagnostics_handler ):
    """This should be called regularly to check for new messages in this buffer.
    Returns True if Poll should be called again in a while. Returns False when
    the completer or server indicated that further polling should not be done
    for the requested file."""

    if self._response_future is None:
      # First poll
      self._SendRequest()
      return True

    if not self._response_future.done():
      # Nothing yet...
      return True

    response = self.HandleFuture( self._response_future,
                                  display_message = False )
    if response is None:
      # Server returned an exception.
      return False

    poll_again = _HandlePollResponse( response, diagnostics_handler )
    if poll_again:
      self._SendRequest()
      return True

    return False


def _HandlePollResponse( response, diagnostics_handler ):
  if isinstance( response, list ):
    for notification in response:
      if 'message' in notification:
        PostVimMessage( notification[ 'message' ],
                        warning = False,
                        truncate = True )
      elif 'diagnostics' in notification:
        diagnostics_handler.UpdateWithNewDiagnosticsForFile(
          notification[ 'filepath' ],
          notification[ 'diagnostics' ] )
  elif response is False:
    # Don't keep polling for this file
    return False
  # else any truthy response means "nothing to see here; poll again in a
  # while"

  # Start the next poll (only if the last poll didn't raise an exception)
  return True
<EOF>
<BOF>
# Copyright (C) 2013-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

import logging
from ycmd.utils import ToUnicode
from ycm.client.base_request import ( BaseRequest, DisplayServerException,
                                      MakeServerException )
from ycm import vimsupport
from ycm.vimsupport import NO_COMPLETIONS

_logger = logging.getLogger( __name__ )


class CompletionRequest( BaseRequest ):
  def __init__( self, request_data ):
    super( CompletionRequest, self ).__init__()
    self.request_data = request_data
    self._response_future = None


  def Start( self ):
    self._response_future = self.PostDataToHandlerAsync( self.request_data,
                                                         'completions' )


  def Done( self ):
    return bool( self._response_future ) and self._response_future.done()


  def RawResponse( self ):
    if not self._response_future:
      return NO_COMPLETIONS

    response = self.HandleFuture( self._response_future,
                                  truncate_message = True )
    if not response:
      return NO_COMPLETIONS

    # Vim may not be able to convert the 'errors' entry to its internal format
    # so we remove it from the response.
    errors = response.pop( 'errors', [] )
    for e in errors:
      exception = MakeServerException( e )
      _logger.error( exception )
      DisplayServerException( exception, truncate_message = True )

    response[ 'line' ] = self.request_data[ 'line_num' ]
    response[ 'column' ] = self.request_data[ 'column_num' ]
    return response


  def Response( self ):
    response = self.RawResponse()
    response[ 'completions' ] = _ConvertCompletionDatasToVimDatas(
        response[ 'completions' ] )
    return response


  def OnCompleteDone( self ):
    if not self.Done():
      return

    if 'cs' in vimsupport.CurrentFiletypes():
      self._OnCompleteDone_Csharp()
    else:
      self._OnCompleteDone_FixIt()


  def _GetCompletionsUserMayHaveCompleted( self ):
    completed_item = vimsupport.GetVariableValue( 'v:completed_item' )

    # If Vim supports user_data (8.0.1493 or later), we actually know the
    # _exact_ element that was selected, having put its index in the
    # user_data field. Otherwise, we have to guess by matching the values in the
    # completed item and the list of completions. Sometimes this returns
    # multiple possibilities, which is essentially unresolvable.
    if 'user_data' not in completed_item:
      completions = self.RawResponse()[ 'completions' ]
      return _FilterToMatchingCompletions( completed_item, completions )

    if completed_item[ 'user_data' ]:
      completions = self.RawResponse()[ 'completions' ]
      return [ completions[ int( completed_item[ 'user_data' ] ) ] ]

    return []


  def _OnCompleteDone_Csharp( self ):
    completions = self._GetCompletionsUserMayHaveCompleted()
    namespaces = [ _GetRequiredNamespaceImport( c ) for c in completions ]
    namespaces = [ n for n in namespaces if n ]
    if not namespaces:
      return

    if len( namespaces ) > 1:
      choices = [ "{0} {1}".format( i + 1, n )
                  for i, n in enumerate( namespaces ) ]
      choice = vimsupport.PresentDialog( "Insert which namespace:", choices )
      if choice < 0:
        return
      namespace = namespaces[ choice ]
    else:
      namespace = namespaces[ 0 ]

    vimsupport.InsertNamespace( namespace )


  def _OnCompleteDone_FixIt( self ):
    completions = self._GetCompletionsUserMayHaveCompleted()
    fixit_completions = [ _GetFixItCompletion( c ) for c in completions ]
    fixit_completions = [ f for f in fixit_completions if f ]
    if not fixit_completions:
      return

    # If we have user_data in completions (8.0.1493 or later), then we would
    # only ever return max. 1 completion here. However, if we had to guess, it
    # is possible that we matched multiple completion items (e.g. for overloads,
    # or similar classes in multiple packages). In any case, rather than
    # prompting the user and disturbing her workflow, we just apply the first
    # one. This might be wrong, but the solution is to use a (very) new version
    # of Vim which supports user_data on completion items
    fixit_completion = fixit_completions[ 0 ]

    for fixit in fixit_completion:
      vimsupport.ReplaceChunks( fixit[ 'chunks' ], silent=True )


def _GetRequiredNamespaceImport( completion ):
  if ( 'extra_data' not in completion
       or 'required_namespace_import' not in completion[ 'extra_data' ] ):
    return None
  return completion[ 'extra_data' ][ 'required_namespace_import' ]


def _GetFixItCompletion( completion ):
  if ( 'extra_data' not in completion
       or 'fixits' not in completion[ 'extra_data' ] ):
    return None

  return completion[ 'extra_data' ][ 'fixits' ]


def _FilterToMatchingCompletions( completed_item, completions ):
  """Filter to completions matching the item Vim said was completed"""
  match_keys = [ 'word', 'abbr', 'menu', 'info' ]
  matched_completions = []
  for index, completion in enumerate( completions ):
    item = _ConvertCompletionDataToVimData( index, completion )

    def matcher( key ):
      return ( ToUnicode( completed_item.get( key, "" ) ) ==
               ToUnicode( item.get( key, "" ) ) )

    if all( matcher( i ) for i in match_keys ):
      matched_completions.append( completion )
  return matched_completions


def _GetCompletionInfoField( completion_data ):
  info = completion_data.get( 'detailed_info', '' )

  if 'extra_data' in completion_data:
    docstring = completion_data[ 'extra_data' ].get( 'doc_string', '' )
    if docstring:
      if info:
        info += '\n' + docstring
      else:
        info = docstring

  # This field may contain null characters e.g. \x00 in Python docstrings. Vim
  # cannot evaluate such characters so they are removed.
  return info.replace( '\x00', '' )


def _ConvertCompletionDataToVimData( completion_identifier, completion_data ):
  # See :h complete-items for a description of the dictionary fields.
  return {
    'word'     : completion_data[ 'insertion_text' ],
    'abbr'     : completion_data.get( 'menu_text', '' ),
    'menu'     : completion_data.get( 'extra_menu_info', '' ),
    'info'     : _GetCompletionInfoField( completion_data ),
    'kind'     : ToUnicode( completion_data.get( 'kind', '' ) )[ :1 ].lower(),
    'dup'      : 1,
    'empty'    : 1,
    # We store the completion item index as a string in the completion
    # user_data. This allows us to identify the _exact_ item that was completed
    # in the CompleteDone handler, by inspecting this item from v:completed_item
    #
    # We convert to string because completion user data items must be strings.
    #
    # Note: Not all versions of Vim support this (added in 8.0.1483), but adding
    # the item to the dictionary is harmless in earlier Vims.
    'user_data': str( completion_identifier )
  }


def _ConvertCompletionDatasToVimDatas( response_data ):
  return [ _ConvertCompletionDataToVimData( i, x )
           for i, x in enumerate( response_data ) ]
<EOF>
<BOF>
# Copyright (C) 2013  Google Inc.
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.client.base_request import BaseRequest, BuildRequestData


class CompleterAvailableRequest( BaseRequest ):
  def __init__( self, filetypes ):
    super( CompleterAvailableRequest, self ).__init__()
    self.filetypes = filetypes
    self._response = None


  def Start( self ):
    request_data = BuildRequestData()
    request_data.update( { 'filetypes': self.filetypes } )
    self._response = self.PostDataToHandler( request_data,
                                             'semantic_completion_available' )


  def Response( self ):
    return self._response


def SendCompleterAvailableRequest( filetypes ):
  request = CompleterAvailableRequest( filetypes )
  # This is a blocking call.
  request.Start()
  return request.Response()
<EOF>
<BOF>
# Copyright (C) 2013-2018 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.client.base_request import BaseRequest, BuildRequestData


class EventNotification( BaseRequest ):
  def __init__( self, event_name, buffer_number = None, extra_data = None ):
    super( EventNotification, self ).__init__()
    self._event_name = event_name
    self._buffer_number = buffer_number
    self._extra_data = extra_data
    self._response_future = None
    self._cached_response = None


  def Start( self ):
    request_data = BuildRequestData( self._buffer_number )
    if self._extra_data:
      request_data.update( self._extra_data )
    request_data[ 'event_name' ] = self._event_name

    self._response_future = self.PostDataToHandlerAsync( request_data,
                                                         'event_notification' )


  def Done( self ):
    return bool( self._response_future ) and self._response_future.done()


  def Response( self ):
    if self._cached_response:
      return self._cached_response

    if not self._response_future or self._event_name != 'FileReadyToParse':
      return []

    self._cached_response = self.HandleFuture( self._response_future,
                                               truncate_message = True )

    return self._cached_response if self._cached_response else []


def SendEventNotificationAsync( event_name,
                                buffer_number = None,
                                extra_data = None ):
  event = EventNotification( event_name, buffer_number, extra_data )
  event.Start()
<EOF>
<BOF>
# Copyright (C) 2016 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.client.base_request import BaseRequest

TIMEOUT_SECONDS = 0.1


class ShutdownRequest( BaseRequest ):
  def __init__( self ):
    super( ShutdownRequest, self ).__init__()


  def Start( self ):
    self.PostDataToHandler( {},
                            'shutdown',
                            TIMEOUT_SECONDS,
                            display_message = False )


def SendShutdownRequest():
  request = ShutdownRequest()
  # This is a blocking call.
  request.Start()
<EOF>
<BOF>
# Copyright (C) 2016-2017 YouCompleteMe contributors
#
# This file is part of YouCompleteMe.
#
# YouCompleteMe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# YouCompleteMe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# Not installing aliases from python-future; it's unreliable and slow.
from builtins import *  # noqa

from ycm.client.base_request import BaseRequest, BuildRequestData


class DebugInfoRequest( BaseRequest ):
  def __init__( self, extra_data = None ):
    super( DebugInfoRequest, self ).__init__()
    self._extra_data = extra_data
    self._response = None


  def Start( self ):
    request_data = BuildRequestData()
    if self._extra_data:
      request_data.update( self._extra_data )
    self._response = self.PostDataToHandler( request_data,
                                             'debug_info',
                                             display_message = False )


  def Response( self ):
    return self._response


def FormatDebugInfoResponse( response ):
  if not response:
    return 'Server errored, no debug info from server\n'
  message = _FormatYcmdDebugInfo( response )
  completer = response[ 'completer' ]
  if completer:
    message += _FormatCompleterDebugInfo( completer )
  return message


def _FormatYcmdDebugInfo( ycmd ):
  python = ycmd[ 'python' ]
  clang = ycmd[ 'clang' ]
  message = ( 'Server Python interpreter: {0}\n'
              'Server Python version: {1}\n'
              'Server has Clang support compiled in: {2}\n'
              'Clang version: {3}\n'.format( python[ 'executable' ],
                                             python[ 'version' ],
                                             clang[ 'has_support' ],
                                             clang[ 'version' ] ) )
  extra_conf = ycmd[ 'extra_conf' ]
  extra_conf_path = extra_conf[ 'path' ]
  if not extra_conf_path:
    message += 'No extra configuration file found\n'
  elif not extra_conf[ 'is_loaded' ]:
    message += ( 'Extra configuration file found but not loaded\n'
                 'Extra configuration path: {0}\n'.format( extra_conf_path ) )
  else:
    message += ( 'Extra configuration file found and loaded\n'
                 'Extra configuration path: {0}\n'.format( extra_conf_path ) )
  return message


def _FormatCompleterDebugInfo( completer ):
  message = '{0} completer debug information:\n'.format( completer[ 'name' ] )
  for server in completer[ 'servers' ]:
    name = server[ 'name' ]
    if server[ 'is_running' ]:
      address = server[ 'address' ]
      port = server[ 'port' ]
      if address and port:
        message += '  {0} running at: http://{1}:{2}\n'.format( name,
                                                                address,
                                                                port )
      else:
        message += '  {0} running\n'.format( name )
      message += '  {0} process ID: {1}\n'.format( name, server[ 'pid' ] )
    else:
      message += '  {0} not running\n'.format( name )
    message += '  {0} executable: {1}\n'.format( name, server[ 'executable' ] )
    logfiles = server[ 'logfiles' ]
    if logfiles:
      message += '  {0} logfiles:\n'.format( name )
      for logfile in logfiles:
        message += '    {0}\n'.format( logfile )
    else:
      message += '  No logfiles available\n'
    if 'extras' in server:
      for extra in server[ 'extras' ]:
        message += '  {0} {1}: {2}\n'.format( name,
                                              extra[ 'key' ],
                                              extra[ 'value' ] )
  for item in completer[ 'items' ]:
    message += '  {0}: {1}\n'.format( item[ 'key' ].capitalize(),
                                      item[ 'value' ] )
  return message


def SendDebugInfoRequest( extra_data = None ):
  request = DebugInfoRequest( extra_data )
  # This is a blocking call.
  request.Start()
  return request.Response()
<EOF>
<BOF>
#!/usr/bin/env python
import sys

extras = {}
try:
    from setuptools import setup
    extras['zip_safe'] = False
    if sys.version_info < (2, 6):
        extras['install_requires'] = ['multiprocessing']
except ImportError:
    from distutils.core import setup

setup(name='futures',
      version='2.1.4',
      description='Backport of the concurrent.futures package from Python 3.2',
      author='Brian Quinlan',
      author_email='brian@sweetapp.com',
      maintainer='Alex Gronholm',
      maintainer_email='alex.gronholm+pypi@nextday.fi',
      url='http://code.google.com/p/pythonfutures',
      download_url='http://pypi.python.org/pypi/futures/',
      packages=['futures', 'concurrent', 'concurrent.futures'],
      license='BSD',
      classifiers=['License :: OSI Approved :: BSD License',
                   'Development Status :: 5 - Production/Stable',
                   'Intended Audience :: Developers',
                   'Programming Language :: Python :: 2.5',
                   'Programming Language :: Python :: 2.6',
                   'Programming Language :: Python :: 2.7',
                   'Programming Language :: Python :: 3',
                   'Programming Language :: Python :: 3.1'],
      **extras
      )
<EOF>
<BOF>
from __future__ import with_statement
import os
import subprocess
import sys
import threading
import functools
import contextlib
import logging
import re
import time

from concurrent import futures
from concurrent.futures._base import (
    PENDING, RUNNING, CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED, Future)

try:
    import unittest2 as unittest
except ImportError:
    import unittest

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

try:
    from test import test_support
except ImportError:
    from test import support as test_support

try:
    next
except NameError:
    next = lambda x: x.next()


def reap_threads(func):
    """Use this function when threads are being used.  This will
    ensure that the threads are cleaned up even when the test fails.
    If threading is unavailable this function does nothing.
    """
    @functools.wraps(func)
    def decorator(*args): 
        key = test_support.threading_setup()
        try:
            return func(*args)
        finally:
            test_support.threading_cleanup(*key)
    return decorator


# Executing the interpreter in a subprocess
def _assert_python(expected_success, *args, **env_vars):
    cmd_line = [sys.executable]
    if not env_vars:
        cmd_line.append('-E')
    # Need to preserve the original environment, for in-place testing of
    # shared library builds.
    env = os.environ.copy()
    # But a special flag that can be set to override -- in this case, the
    # caller is responsible to pass the full environment.
    if env_vars.pop('__cleanenv', None):
        env = {}
    env.update(env_vars) 
    cmd_line.extend(args)
    p = subprocess.Popen(cmd_line, stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                         env=env)
    try:
        out, err = p.communicate()
    finally:
        subprocess._cleanup()
        p.stdout.close()
        p.stderr.close()
    rc = p.returncode
    err = strip_python_stderr(err)
    if (rc and expected_success) or (not rc and not expected_success):
        raise AssertionError(
            "Process return code is %d, "
            "stderr follows:\n%s" % (rc, err.decode('ascii', 'ignore')))
    return rc, out, err


def assert_python_ok(*args, **env_vars):
    """
    Assert that running the interpreter with `args` and optional environment
    variables `env_vars` is ok and return a (return code, stdout, stderr) tuple.
    """
    return _assert_python(True, *args, **env_vars)


def strip_python_stderr(stderr): 
    """Strip the stderr of a Python process from potential debug output
    emitted by the interpreter.

    This will typically be run on the result of the communicate() method
    of a subprocess.Popen object.
    """
    stderr = re.sub(r"\[\d+ refs\]\r?\n?$".encode(), "".encode(), stderr).strip()
    return stderr


@contextlib.contextmanager
def captured_stderr():
    """Return a context manager used by captured_stdout/stdin/stderr
    that temporarily replaces the sys stream *stream_name* with a StringIO."""
    logging_stream = StringIO()
    handler = logging.StreamHandler(logging_stream)
    logging.root.addHandler(handler)

    try:
        yield logging_stream
    finally:
        logging.root.removeHandler(handler)


def create_future(state=PENDING, exception=None, result=None):
    f = Future()
    f._state = state
    f._exception = exception
    f._result = result
    return f


PENDING_FUTURE = create_future(state=PENDING)
RUNNING_FUTURE = create_future(state=RUNNING)
CANCELLED_FUTURE = create_future(state=CANCELLED)
CANCELLED_AND_NOTIFIED_FUTURE = create_future(state=CANCELLED_AND_NOTIFIED)
EXCEPTION_FUTURE = create_future(state=FINISHED, exception=IOError())
SUCCESSFUL_FUTURE = create_future(state=FINISHED, result=42)


def mul(x, y):
    return x * y


def sleep_and_raise(t):
    time.sleep(t)
    raise Exception('this is an exception')

def sleep_and_print(t, msg):
    time.sleep(t)
    print(msg)
    sys.stdout.flush()


class ExecutorMixin:
    worker_count = 5

    def setUp(self):
        self.t1 = time.time()
        try:
            self.executor = self.executor_type(max_workers=self.worker_count)
        except NotImplementedError:
            e = sys.exc_info()[1]
            self.skipTest(str(e))
        self._prime_executor()

    def tearDown(self):
        self.executor.shutdown(wait=True)
        dt = time.time() - self.t1
        if test_support.verbose:
            print("%.2fs" % dt)
        self.assertLess(dt, 60, "synchronization issue: test lasted too long")

    def _prime_executor(self):
        # Make sure that the executor is ready to do work before running the
        # tests. This should reduce the probability of timeouts in the tests.
        futures = [self.executor.submit(time.sleep, 0.1)
                   for _ in range(self.worker_count)]

        for f in futures:
            f.result()


class ThreadPoolMixin(ExecutorMixin):
    executor_type = futures.ThreadPoolExecutor


class ProcessPoolMixin(ExecutorMixin):
    executor_type = futures.ProcessPoolExecutor


class ExecutorShutdownTest(unittest.TestCase):
    def test_run_after_shutdown(self):
        self.executor.shutdown()
        self.assertRaises(RuntimeError,
                          self.executor.submit,
                          pow, 2, 5)

    def test_interpreter_shutdown(self):
        # Test the atexit hook for shutdown of worker threads and processes
        rc, out, err = assert_python_ok('-c', """if 1:
            from concurrent.futures import %s
            from time import sleep
            from test_futures import sleep_and_print
            t = %s(5)
            t.submit(sleep_and_print, 1.0, "apple")
            """ % (self.executor_type.__name__, self.executor_type.__name__))
        # Errors in atexit hooks don't change the process exit code, check
        # stderr manually.
        self.assertFalse(err)
        self.assertEqual(out.strip(), "apple".encode())

    def test_hang_issue12364(self):
        fs = [self.executor.submit(time.sleep, 0.1) for _ in range(50)]
        self.executor.shutdown()
        for f in fs:
            f.result()


class ThreadPoolShutdownTest(ThreadPoolMixin, ExecutorShutdownTest):
    def _prime_executor(self):
        pass

    def test_threads_terminate(self):
        self.executor.submit(mul, 21, 2)
        self.executor.submit(mul, 6, 7)
        self.executor.submit(mul, 3, 14)
        self.assertEqual(len(self.executor._threads), 3)
        self.executor.shutdown()
        for t in self.executor._threads:
            t.join()

    def test_context_manager_shutdown(self):
        with futures.ThreadPoolExecutor(max_workers=5) as e:
            executor = e
            self.assertEqual(list(e.map(abs, range(-5, 5))),
                             [5, 4, 3, 2, 1, 0, 1, 2, 3, 4])

        for t in executor._threads:
            t.join()

    def test_del_shutdown(self):
        executor = futures.ThreadPoolExecutor(max_workers=5)
        executor.map(abs, range(-5, 5))
        threads = executor._threads
        del executor

        for t in threads:
            t.join()


class ProcessPoolShutdownTest(ProcessPoolMixin, ExecutorShutdownTest):
    def _prime_executor(self):
        pass

    def test_processes_terminate(self):
        self.executor.submit(mul, 21, 2)
        self.executor.submit(mul, 6, 7)
        self.executor.submit(mul, 3, 14)
        self.assertEqual(len(self.executor._processes), 5)
        processes = self.executor._processes
        self.executor.shutdown()

        for p in processes:
            p.join()

    def test_context_manager_shutdown(self):
        with futures.ProcessPoolExecutor(max_workers=5) as e:
            processes = e._processes
            self.assertEqual(list(e.map(abs, range(-5, 5))),
                             [5, 4, 3, 2, 1, 0, 1, 2, 3, 4])

        for p in processes:
            p.join()

    def test_del_shutdown(self):
        executor = futures.ProcessPoolExecutor(max_workers=5)
        list(executor.map(abs, range(-5, 5)))
        queue_management_thread = executor._queue_management_thread
        processes = executor._processes
        del executor

        queue_management_thread.join()
        for p in processes:
            p.join()


class WaitTests(unittest.TestCase):

    def test_first_completed(self):
        future1 = self.executor.submit(mul, 21, 2)
        future2 = self.executor.submit(time.sleep, 1.5)

        done, not_done = futures.wait(
                [CANCELLED_FUTURE, future1, future2],
                 return_when=futures.FIRST_COMPLETED)

        self.assertEqual(set([future1]), done)
        self.assertEqual(set([CANCELLED_FUTURE, future2]), not_done)

    def test_first_completed_some_already_completed(self):
        future1 = self.executor.submit(time.sleep, 1.5)

        finished, pending = futures.wait(
                 [CANCELLED_AND_NOTIFIED_FUTURE, SUCCESSFUL_FUTURE, future1],
                 return_when=futures.FIRST_COMPLETED)

        self.assertEqual(
                set([CANCELLED_AND_NOTIFIED_FUTURE, SUCCESSFUL_FUTURE]),
                finished)
        self.assertEqual(set([future1]), pending)

    def test_first_exception(self):
        future1 = self.executor.submit(mul, 2, 21)
        future2 = self.executor.submit(sleep_and_raise, 1.5)
        future3 = self.executor.submit(time.sleep, 3)

        finished, pending = futures.wait(
                [future1, future2, future3],
                return_when=futures.FIRST_EXCEPTION)

        self.assertEqual(set([future1, future2]), finished)
        self.assertEqual(set([future3]), pending)

    def test_first_exception_some_already_complete(self):
        future1 = self.executor.submit(divmod, 21, 0)
        future2 = self.executor.submit(time.sleep, 1.5)

        finished, pending = futures.wait(
                [SUCCESSFUL_FUTURE,
                 CANCELLED_FUTURE,
                 CANCELLED_AND_NOTIFIED_FUTURE,
                 future1, future2],
                return_when=futures.FIRST_EXCEPTION)

        self.assertEqual(set([SUCCESSFUL_FUTURE,
                              CANCELLED_AND_NOTIFIED_FUTURE,
                              future1]), finished)
        self.assertEqual(set([CANCELLED_FUTURE, future2]), pending)

    def test_first_exception_one_already_failed(self):
        future1 = self.executor.submit(time.sleep, 2)

        finished, pending = futures.wait(
                 [EXCEPTION_FUTURE, future1],
                 return_when=futures.FIRST_EXCEPTION)

        self.assertEqual(set([EXCEPTION_FUTURE]), finished)
        self.assertEqual(set([future1]), pending)

    def test_all_completed(self):
        future1 = self.executor.submit(divmod, 2, 0)
        future2 = self.executor.submit(mul, 2, 21)

        finished, pending = futures.wait(
                [SUCCESSFUL_FUTURE,
                 CANCELLED_AND_NOTIFIED_FUTURE,
                 EXCEPTION_FUTURE,
                 future1,
                 future2],
                return_when=futures.ALL_COMPLETED)

        self.assertEqual(set([SUCCESSFUL_FUTURE,
                              CANCELLED_AND_NOTIFIED_FUTURE,
                              EXCEPTION_FUTURE,
                              future1,
                              future2]), finished)
        self.assertEqual(set(), pending)

    def test_timeout(self):
        future1 = self.executor.submit(mul, 6, 7)
        future2 = self.executor.submit(time.sleep, 3)

        finished, pending = futures.wait(
                [CANCELLED_AND_NOTIFIED_FUTURE,
                 EXCEPTION_FUTURE,
                 SUCCESSFUL_FUTURE,
                 future1, future2],
                timeout=1.5,
                return_when=futures.ALL_COMPLETED)

        self.assertEqual(set([CANCELLED_AND_NOTIFIED_FUTURE,
                              EXCEPTION_FUTURE,
                              SUCCESSFUL_FUTURE,
                              future1]), finished)
        self.assertEqual(set([future2]), pending)


class ThreadPoolWaitTests(ThreadPoolMixin, WaitTests):

    def test_pending_calls_race(self):
        # Issue #14406: multi-threaded race condition when waiting on all
        # futures.
        event = threading.Event()
        def future_func():
            event.wait()
        oldswitchinterval = sys.getcheckinterval()
        sys.setcheckinterval(1)
        try:
            fs = set(self.executor.submit(future_func) for i in range(100))
            event.set()
            futures.wait(fs, return_when=futures.ALL_COMPLETED)
        finally:
            sys.setcheckinterval(oldswitchinterval)


class ProcessPoolWaitTests(ProcessPoolMixin, WaitTests):
    pass


class AsCompletedTests(unittest.TestCase):
    # TODO(brian@sweetapp.com): Should have a test with a non-zero timeout.
    def test_no_timeout(self):
        future1 = self.executor.submit(mul, 2, 21)
        future2 = self.executor.submit(mul, 7, 6)

        completed = set(futures.as_completed(
                [CANCELLED_AND_NOTIFIED_FUTURE,
                 EXCEPTION_FUTURE,
                 SUCCESSFUL_FUTURE,
                 future1, future2]))
        self.assertEqual(set(
                [CANCELLED_AND_NOTIFIED_FUTURE,
                 EXCEPTION_FUTURE,
                 SUCCESSFUL_FUTURE,
                 future1, future2]),
                completed)

    def test_zero_timeout(self):
        future1 = self.executor.submit(time.sleep, 2)
        completed_futures = set()
        try:
            for future in futures.as_completed(
                    [CANCELLED_AND_NOTIFIED_FUTURE,
                     EXCEPTION_FUTURE,
                     SUCCESSFUL_FUTURE,
                     future1],
                    timeout=0):
                completed_futures.add(future)
        except futures.TimeoutError:
            pass

        self.assertEqual(set([CANCELLED_AND_NOTIFIED_FUTURE,
                              EXCEPTION_FUTURE,
                              SUCCESSFUL_FUTURE]),
                         completed_futures)


class ThreadPoolAsCompletedTests(ThreadPoolMixin, AsCompletedTests):
    pass


class ProcessPoolAsCompletedTests(ProcessPoolMixin, AsCompletedTests):
    pass


class ExecutorTest(unittest.TestCase):
    # Executor.shutdown() and context manager usage is tested by
    # ExecutorShutdownTest.
    def test_submit(self):
        future = self.executor.submit(pow, 2, 8)
        self.assertEqual(256, future.result())

    def test_submit_keyword(self):
        future = self.executor.submit(mul, 2, y=8)
        self.assertEqual(16, future.result())

    def test_map(self):
        self.assertEqual(
                list(self.executor.map(pow, range(10), range(10))),
                list(map(pow, range(10), range(10))))

    def test_map_exception(self):
        i = self.executor.map(divmod, [1, 1, 1, 1], [2, 3, 0, 5])
        self.assertEqual(next(i), (0, 1))
        self.assertEqual(next(i), (0, 1))
        self.assertRaises(ZeroDivisionError, next, i)

    def test_map_timeout(self):
        results = []
        try:
            for i in self.executor.map(time.sleep,
                                       [0, 0, 3],
                                       timeout=1.5):
                results.append(i)
        except futures.TimeoutError:
            pass
        else:
            self.fail('expected TimeoutError')

        self.assertEqual([None, None], results)


class ThreadPoolExecutorTest(ThreadPoolMixin, ExecutorTest):
    pass


class ProcessPoolExecutorTest(ProcessPoolMixin, ExecutorTest):
    pass


class FutureTests(unittest.TestCase):
    def test_done_callback_with_result(self):
        callback_result = [None]
        def fn(callback_future):
            callback_result[0] = callback_future.result()

        f = Future()
        f.add_done_callback(fn)
        f.set_result(5)
        self.assertEqual(5, callback_result[0])

    def test_done_callback_with_exception(self):
        callback_exception = [None]
        def fn(callback_future):
            callback_exception[0] = callback_future.exception()

        f = Future()
        f.add_done_callback(fn)
        f.set_exception(Exception('test'))
        self.assertEqual(('test',), callback_exception[0].args)

    def test_done_callback_with_cancel(self):
        was_cancelled = [None]
        def fn(callback_future):
            was_cancelled[0] = callback_future.cancelled()

        f = Future()
        f.add_done_callback(fn)
        self.assertTrue(f.cancel())
        self.assertTrue(was_cancelled[0])

    def test_done_callback_raises(self):
        with captured_stderr() as stderr:
            raising_was_called = [False]
            fn_was_called = [False]

            def raising_fn(callback_future):
                raising_was_called[0] = True
                raise Exception('doh!')

            def fn(callback_future):
                fn_was_called[0] = True

            f = Future()
            f.add_done_callback(raising_fn)
            f.add_done_callback(fn)
            f.set_result(5)
            self.assertTrue(raising_was_called)
            self.assertTrue(fn_was_called)
            self.assertIn('Exception: doh!', stderr.getvalue())

    def test_done_callback_already_successful(self):
        callback_result = [None]
        def fn(callback_future):
            callback_result[0] = callback_future.result()

        f = Future()
        f.set_result(5)
        f.add_done_callback(fn)
        self.assertEqual(5, callback_result[0])

    def test_done_callback_already_failed(self):
        callback_exception = [None]
        def fn(callback_future):
            callback_exception[0] = callback_future.exception()

        f = Future()
        f.set_exception(Exception('test'))
        f.add_done_callback(fn)
        self.assertEqual(('test',), callback_exception[0].args)

    def test_done_callback_already_cancelled(self):
        was_cancelled = [None]
        def fn(callback_future):
            was_cancelled[0] = callback_future.cancelled()

        f = Future()
        self.assertTrue(f.cancel())
        f.add_done_callback(fn)
        self.assertTrue(was_cancelled[0])

    def test_repr(self):
        self.assertRegexpMatches(repr(PENDING_FUTURE),
                                 '<Future at 0x[0-9a-f]+ state=pending>')
        self.assertRegexpMatches(repr(RUNNING_FUTURE),
                                 '<Future at 0x[0-9a-f]+ state=running>')
        self.assertRegexpMatches(repr(CANCELLED_FUTURE),
                                 '<Future at 0x[0-9a-f]+ state=cancelled>')
        self.assertRegexpMatches(repr(CANCELLED_AND_NOTIFIED_FUTURE),
                                 '<Future at 0x[0-9a-f]+ state=cancelled>')
        self.assertRegexpMatches(
                repr(EXCEPTION_FUTURE),
                '<Future at 0x[0-9a-f]+ state=finished raised IOError>')
        self.assertRegexpMatches(
                repr(SUCCESSFUL_FUTURE),
                '<Future at 0x[0-9a-f]+ state=finished returned int>')

    def test_cancel(self):
        f1 = create_future(state=PENDING)
        f2 = create_future(state=RUNNING)
        f3 = create_future(state=CANCELLED)
        f4 = create_future(state=CANCELLED_AND_NOTIFIED)
        f5 = create_future(state=FINISHED, exception=IOError())
        f6 = create_future(state=FINISHED, result=5)

        self.assertTrue(f1.cancel())
        self.assertEqual(f1._state, CANCELLED)

        self.assertFalse(f2.cancel())
        self.assertEqual(f2._state, RUNNING)

        self.assertTrue(f3.cancel())
        self.assertEqual(f3._state, CANCELLED)

        self.assertTrue(f4.cancel())
        self.assertEqual(f4._state, CANCELLED_AND_NOTIFIED)

        self.assertFalse(f5.cancel())
        self.assertEqual(f5._state, FINISHED)

        self.assertFalse(f6.cancel())
        self.assertEqual(f6._state, FINISHED)

    def test_cancelled(self):
        self.assertFalse(PENDING_FUTURE.cancelled())
        self.assertFalse(RUNNING_FUTURE.cancelled())
        self.assertTrue(CANCELLED_FUTURE.cancelled())
        self.assertTrue(CANCELLED_AND_NOTIFIED_FUTURE.cancelled())
        self.assertFalse(EXCEPTION_FUTURE.cancelled())
        self.assertFalse(SUCCESSFUL_FUTURE.cancelled())

    def test_done(self):
        self.assertFalse(PENDING_FUTURE.done())
        self.assertFalse(RUNNING_FUTURE.done())
        self.assertTrue(CANCELLED_FUTURE.done())
        self.assertTrue(CANCELLED_AND_NOTIFIED_FUTURE.done())
        self.assertTrue(EXCEPTION_FUTURE.done())
        self.assertTrue(SUCCESSFUL_FUTURE.done())

    def test_running(self):
        self.assertFalse(PENDING_FUTURE.running())
        self.assertTrue(RUNNING_FUTURE.running())
        self.assertFalse(CANCELLED_FUTURE.running())
        self.assertFalse(CANCELLED_AND_NOTIFIED_FUTURE.running())
        self.assertFalse(EXCEPTION_FUTURE.running())
        self.assertFalse(SUCCESSFUL_FUTURE.running())

    def test_result_with_timeout(self):
        self.assertRaises(futures.TimeoutError,
                          PENDING_FUTURE.result, timeout=0)
        self.assertRaises(futures.TimeoutError,
                          RUNNING_FUTURE.result, timeout=0)
        self.assertRaises(futures.CancelledError,
                          CANCELLED_FUTURE.result, timeout=0)
        self.assertRaises(futures.CancelledError,
                          CANCELLED_AND_NOTIFIED_FUTURE.result, timeout=0)
        self.assertRaises(IOError, EXCEPTION_FUTURE.result, timeout=0)
        self.assertEqual(SUCCESSFUL_FUTURE.result(timeout=0), 42)

    def test_result_with_success(self):
        # TODO(brian@sweetapp.com): This test is timing dependant.
        def notification():
            # Wait until the main thread is waiting for the result.
            time.sleep(1)
            f1.set_result(42)

        f1 = create_future(state=PENDING)
        t = threading.Thread(target=notification)
        t.start()

        self.assertEqual(f1.result(timeout=5), 42)

    def test_result_with_cancel(self):
        # TODO(brian@sweetapp.com): This test is timing dependant.
        def notification():
            # Wait until the main thread is waiting for the result.
            time.sleep(1)
            f1.cancel()

        f1 = create_future(state=PENDING)
        t = threading.Thread(target=notification)
        t.start()

        self.assertRaises(futures.CancelledError, f1.result, timeout=5)

    def test_exception_with_timeout(self):
        self.assertRaises(futures.TimeoutError,
                          PENDING_FUTURE.exception, timeout=0)
        self.assertRaises(futures.TimeoutError,
                          RUNNING_FUTURE.exception, timeout=0)
        self.assertRaises(futures.CancelledError,
                          CANCELLED_FUTURE.exception, timeout=0)
        self.assertRaises(futures.CancelledError,
                          CANCELLED_AND_NOTIFIED_FUTURE.exception, timeout=0)
        self.assertTrue(isinstance(EXCEPTION_FUTURE.exception(timeout=0),
                                   IOError))
        self.assertEqual(SUCCESSFUL_FUTURE.exception(timeout=0), None)

    def test_exception_with_success(self):
        def notification():
            # Wait until the main thread is waiting for the exception.
            time.sleep(1)
            with f1._condition:
                f1._state = FINISHED
                f1._exception = IOError()
                f1._condition.notify_all()

        f1 = create_future(state=PENDING)
        t = threading.Thread(target=notification)
        t.start()

        self.assertTrue(isinstance(f1.exception(timeout=5), IOError))

@reap_threads
def test_main():
    try:
        test_support.run_unittest(ProcessPoolExecutorTest,
                                  ThreadPoolExecutorTest,
                                  ProcessPoolWaitTests,
                                  ThreadPoolWaitTests,
                                  ProcessPoolAsCompletedTests,
                                  ThreadPoolAsCompletedTests,
                                  FutureTests,
                                  ProcessPoolShutdownTest,
                                  ThreadPoolShutdownTest)
    finally:
        test_support.reap_children()

if __name__ == "__main__":
    test_main()
<EOF>
<BOF>
"""Compare the speed of downloading URLs sequentially vs. using futures."""

import functools
import time
import timeit
import sys

try:
    from urllib2 import urlopen
except ImportError:
    from urllib.request import urlopen

from concurrent.futures import (as_completed, ThreadPoolExecutor,
                                ProcessPoolExecutor)

URLS = ['http://www.google.com/',
        'http://www.apple.com/',
        'http://www.ibm.com',
        'http://www.thisurlprobablydoesnotexist.com',
        'http://www.slashdot.org/',
        'http://www.python.org/',
        'http://www.bing.com/',
        'http://www.facebook.com/',
        'http://www.yahoo.com/',
        'http://www.youtube.com/',
        'http://www.blogger.com/']

def load_url(url, timeout):
    kwargs = {'timeout': timeout} if sys.version_info >= (2, 6) else {}
    return urlopen(url, **kwargs).read()

def download_urls_sequential(urls, timeout=60):
    url_to_content = {}
    for url in urls:
        try:
            url_to_content[url] = load_url(url, timeout=timeout)
        except:
            pass
    return url_to_content

def download_urls_with_executor(urls, executor, timeout=60):
    try:
        url_to_content = {}
        future_to_url = dict((executor.submit(load_url, url, timeout), url)
                             for url in urls)

        for future in as_completed(future_to_url):
            try:
                url_to_content[future_to_url[future]] = future.result()
            except:
                pass
        return url_to_content
    finally:
        executor.shutdown()

def main():
    for name, fn in [('sequential',
                      functools.partial(download_urls_sequential, URLS)),
                     ('processes',
                      functools.partial(download_urls_with_executor,
                                        URLS,
                                        ProcessPoolExecutor(10))),
                     ('threads',
                      functools.partial(download_urls_with_executor,
                                        URLS,
                                        ThreadPoolExecutor(10)))]:
        sys.stdout.write('%s: ' % name.ljust(12))
        start = time.time()
        url_map = fn()
        sys.stdout.write('%.2f seconds (%d of %d downloaded)\n' %
                         (time.time() - start, len(url_map), len(URLS)))

if __name__ == '__main__':
    main()
<EOF>
<BOF>
from __future__ import with_statement
import math
import time
import sys

from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

PRIMES = [
    112272535095293,
    112582705942171,
    112272535095293,
    115280095190773,
    115797848077099,
    117450548693743,
    993960000099397]

def is_prime(n):
    if n % 2 == 0:
        return False

    sqrt_n = int(math.floor(math.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2):
        if n % i == 0:
            return False
    return True

def sequential():
    return list(map(is_prime, PRIMES))

def with_process_pool_executor():
    with ProcessPoolExecutor(10) as executor:
        return list(executor.map(is_prime, PRIMES))

def with_thread_pool_executor():
    with ThreadPoolExecutor(10) as executor:
        return list(executor.map(is_prime, PRIMES))

def main():
    for name, fn in [('sequential', sequential),
                     ('processes', with_process_pool_executor),
                     ('threads', with_thread_pool_executor)]:
        sys.stdout.write('%s: ' % name.ljust(12))
        start = time.time()
        if fn() != [True] * len(PRIMES):
            sys.stdout.write('failed\n')
        else:
            sys.stdout.write('%.2f seconds\n' % (time.time() - start))

if __name__ == '__main__':
    main()
<EOF>
<BOF>
# -*- coding: utf-8 -*-
#
# futures documentation build configuration file, created by
# sphinx-quickstart on Wed Jun  3 19:35:34 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'futures'
copyright = u'2009-2011, Brian Quinlan'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.1.3'
# The full version, including alpha/beta/rc tags.
release = '2.1.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'futuresdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'futures.tex', u'futures Documentation',
   u'Brian Quinlan', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True
<EOF>
<BOF>
from pkgutil import extend_path

__path__ = extend_path(__path__, __name__)
<EOF>
<BOF>
# Copyright 2009 Brian Quinlan. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

from __future__ import with_statement
import logging
import threading
import time

try:
    from collections import namedtuple
except ImportError:
    from concurrent.futures._compat import namedtuple

__author__ = 'Brian Quinlan (brian@sweetapp.com)'

FIRST_COMPLETED = 'FIRST_COMPLETED'
FIRST_EXCEPTION = 'FIRST_EXCEPTION'
ALL_COMPLETED = 'ALL_COMPLETED'
_AS_COMPLETED = '_AS_COMPLETED'

# Possible future states (for internal use by the futures package).
PENDING = 'PENDING'
RUNNING = 'RUNNING'
# The future was cancelled by the user...
CANCELLED = 'CANCELLED'
# ...and _Waiter.add_cancelled() was called by a worker.
CANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'
FINISHED = 'FINISHED'

_FUTURE_STATES = [
    PENDING,
    RUNNING,
    CANCELLED,
    CANCELLED_AND_NOTIFIED,
    FINISHED
]

_STATE_TO_DESCRIPTION_MAP = {
    PENDING: "pending",
    RUNNING: "running",
    CANCELLED: "cancelled",
    CANCELLED_AND_NOTIFIED: "cancelled",
    FINISHED: "finished"
}

# Logger for internal use by the futures package.
LOGGER = logging.getLogger("concurrent.futures")

class Error(Exception):
    """Base class for all future-related exceptions."""
    pass

class CancelledError(Error):
    """The Future was cancelled."""
    pass

class TimeoutError(Error):
    """The operation exceeded the given deadline."""
    pass

class _Waiter(object):
    """Provides the event that wait() and as_completed() block on."""
    def __init__(self):
        self.event = threading.Event()
        self.finished_futures = []

    def add_result(self, future):
        self.finished_futures.append(future)

    def add_exception(self, future):
        self.finished_futures.append(future)

    def add_cancelled(self, future):
        self.finished_futures.append(future)

class _AsCompletedWaiter(_Waiter):
    """Used by as_completed()."""

    def __init__(self):
        super(_AsCompletedWaiter, self).__init__()
        self.lock = threading.Lock()

    def add_result(self, future):
        with self.lock:
            super(_AsCompletedWaiter, self).add_result(future)
            self.event.set()

    def add_exception(self, future):
        with self.lock:
            super(_AsCompletedWaiter, self).add_exception(future)
            self.event.set()

    def add_cancelled(self, future):
        with self.lock:
            super(_AsCompletedWaiter, self).add_cancelled(future)
            self.event.set()

class _FirstCompletedWaiter(_Waiter):
    """Used by wait(return_when=FIRST_COMPLETED)."""

    def add_result(self, future):
        super(_FirstCompletedWaiter, self).add_result(future)
        self.event.set()

    def add_exception(self, future):
        super(_FirstCompletedWaiter, self).add_exception(future)
        self.event.set()

    def add_cancelled(self, future):
        super(_FirstCompletedWaiter, self).add_cancelled(future)
        self.event.set()

class _AllCompletedWaiter(_Waiter):
    """Used by wait(return_when=FIRST_EXCEPTION and ALL_COMPLETED)."""

    def __init__(self, num_pending_calls, stop_on_exception):
        self.num_pending_calls = num_pending_calls
        self.stop_on_exception = stop_on_exception
        self.lock = threading.Lock()
        super(_AllCompletedWaiter, self).__init__()

    def _decrement_pending_calls(self):
        with self.lock:
            self.num_pending_calls -= 1
            if not self.num_pending_calls:
                self.event.set()

    def add_result(self, future):
        super(_AllCompletedWaiter, self).add_result(future)
        self._decrement_pending_calls()

    def add_exception(self, future):
        super(_AllCompletedWaiter, self).add_exception(future)
        if self.stop_on_exception:
            self.event.set()
        else:
            self._decrement_pending_calls()

    def add_cancelled(self, future):
        super(_AllCompletedWaiter, self).add_cancelled(future)
        self._decrement_pending_calls()

class _AcquireFutures(object):
    """A context manager that does an ordered acquire of Future conditions."""

    def __init__(self, futures):
        self.futures = sorted(futures, key=id)

    def __enter__(self):
        for future in self.futures:
            future._condition.acquire()

    def __exit__(self, *args):
        for future in self.futures:
            future._condition.release()

def _create_and_install_waiters(fs, return_when):
    if return_when == _AS_COMPLETED:
        waiter = _AsCompletedWaiter()
    elif return_when == FIRST_COMPLETED:
        waiter = _FirstCompletedWaiter()
    else:
        pending_count = sum(
                f._state not in [CANCELLED_AND_NOTIFIED, FINISHED] for f in fs)

        if return_when == FIRST_EXCEPTION:
            waiter = _AllCompletedWaiter(pending_count, stop_on_exception=True)
        elif return_when == ALL_COMPLETED:
            waiter = _AllCompletedWaiter(pending_count, stop_on_exception=False)
        else:
            raise ValueError("Invalid return condition: %r" % return_when)

    for f in fs:
        f._waiters.append(waiter)

    return waiter

def as_completed(fs, timeout=None):
    """An iterator over the given futures that yields each as it completes.

    Args:
        fs: The sequence of Futures (possibly created by different Executors) to
            iterate over.
        timeout: The maximum number of seconds to wait. If None, then there
            is no limit on the wait time.

    Returns:
        An iterator that yields the given Futures as they complete (finished or
        cancelled).

    Raises:
        TimeoutError: If the entire result iterator could not be generated
            before the given timeout.
    """
    if timeout is not None:
        end_time = timeout + time.time()

    with _AcquireFutures(fs):
        finished = set(
                f for f in fs
                if f._state in [CANCELLED_AND_NOTIFIED, FINISHED])
        pending = set(fs) - finished
        waiter = _create_and_install_waiters(fs, _AS_COMPLETED)

    try:
        for future in finished:
            yield future

        while pending:
            if timeout is None:
                wait_timeout = None
            else:
                wait_timeout = end_time - time.time()
                if wait_timeout < 0:
                    raise TimeoutError(
                            '%d (of %d) futures unfinished' % (
                            len(pending), len(fs)))

            waiter.event.wait(wait_timeout)

            with waiter.lock:
                finished = waiter.finished_futures
                waiter.finished_futures = []
                waiter.event.clear()

            for future in finished:
                yield future
                pending.remove(future)

    finally:
        for f in fs:
            f._waiters.remove(waiter)

DoneAndNotDoneFutures = namedtuple(
        'DoneAndNotDoneFutures', 'done not_done')
def wait(fs, timeout=None, return_when=ALL_COMPLETED):
    """Wait for the futures in the given sequence to complete.

    Args:
        fs: The sequence of Futures (possibly created by different Executors) to
            wait upon.
        timeout: The maximum number of seconds to wait. If None, then there
            is no limit on the wait time.
        return_when: Indicates when this function should return. The options
            are:

            FIRST_COMPLETED - Return when any future finishes or is
                              cancelled.
            FIRST_EXCEPTION - Return when any future finishes by raising an
                              exception. If no future raises an exception
                              then it is equivalent to ALL_COMPLETED.
            ALL_COMPLETED -   Return when all futures finish or are cancelled.

    Returns:
        A named 2-tuple of sets. The first set, named 'done', contains the
        futures that completed (is finished or cancelled) before the wait
        completed. The second set, named 'not_done', contains uncompleted
        futures.
    """
    with _AcquireFutures(fs):
        done = set(f for f in fs
                   if f._state in [CANCELLED_AND_NOTIFIED, FINISHED])
        not_done = set(fs) - done

        if (return_when == FIRST_COMPLETED) and done:
            return DoneAndNotDoneFutures(done, not_done)
        elif (return_when == FIRST_EXCEPTION) and done:
            if any(f for f in done
                   if not f.cancelled() and f.exception() is not None):
                return DoneAndNotDoneFutures(done, not_done)

        if len(done) == len(fs):
            return DoneAndNotDoneFutures(done, not_done)

        waiter = _create_and_install_waiters(fs, return_when)

    waiter.event.wait(timeout)
    for f in fs:
        f._waiters.remove(waiter)

    done.update(waiter.finished_futures)
    return DoneAndNotDoneFutures(done, set(fs) - done)

class Future(object):
    """Represents the result of an asynchronous computation."""

    def __init__(self):
        """Initializes the future. Should not be called by clients."""
        self._condition = threading.Condition()
        self._state = PENDING
        self._result = None
        self._exception = None
        self._waiters = []
        self._done_callbacks = []

    def _invoke_callbacks(self):
        for callback in self._done_callbacks:
            try:
                callback(self)
            except Exception:
                LOGGER.exception('exception calling callback for %r', self)

    def __repr__(self):
        with self._condition:
            if self._state == FINISHED:
                if self._exception:
                    return '<Future at %s state=%s raised %s>' % (
                        hex(id(self)),
                        _STATE_TO_DESCRIPTION_MAP[self._state],
                        self._exception.__class__.__name__)
                else:
                    return '<Future at %s state=%s returned %s>' % (
                        hex(id(self)),
                        _STATE_TO_DESCRIPTION_MAP[self._state],
                        self._result.__class__.__name__)
            return '<Future at %s state=%s>' % (
                    hex(id(self)),
                   _STATE_TO_DESCRIPTION_MAP[self._state])

    def cancel(self):
        """Cancel the future if possible.

        Returns True if the future was cancelled, False otherwise. A future
        cannot be cancelled if it is running or has already completed.
        """
        with self._condition:
            if self._state in [RUNNING, FINISHED]:
                return False

            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                return True

            self._state = CANCELLED
            self._condition.notify_all()

        self._invoke_callbacks()
        return True

    def cancelled(self):
        """Return True if the future has cancelled."""
        with self._condition:
            return self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]

    def running(self):
        """Return True if the future is currently executing."""
        with self._condition:
            return self._state == RUNNING

    def done(self):
        """Return True of the future was cancelled or finished executing."""
        with self._condition:
            return self._state in [CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED]

    def __get_result(self):
        if self._exception:
            raise self._exception
        else:
            return self._result

    def add_done_callback(self, fn):
        """Attaches a callable that will be called when the future finishes.

        Args:
            fn: A callable that will be called with this future as its only
                argument when the future completes or is cancelled. The callable
                will always be called by a thread in the same process in which
                it was added. If the future has already completed or been
                cancelled then the callable will be called immediately. These
                callables are called in the order that they were added.
        """
        with self._condition:
            if self._state not in [CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED]:
                self._done_callbacks.append(fn)
                return
        fn(self)

    def result(self, timeout=None):
        """Return the result of the call that the future represents.

        Args:
            timeout: The number of seconds to wait for the result if the future
                isn't done. If None, then there is no limit on the wait time.

        Returns:
            The result of the call that the future represents.

        Raises:
            CancelledError: If the future was cancelled.
            TimeoutError: If the future didn't finish executing before the given
                timeout.
            Exception: If the call raised then that exception will be raised.
        """
        with self._condition:
            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                raise CancelledError()
            elif self._state == FINISHED:
                return self.__get_result()

            self._condition.wait(timeout)

            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                raise CancelledError()
            elif self._state == FINISHED:
                return self.__get_result()
            else:
                raise TimeoutError()

    def exception(self, timeout=None):
        """Return the exception raised by the call that the future represents.

        Args:
            timeout: The number of seconds to wait for the exception if the
                future isn't done. If None, then there is no limit on the wait
                time.

        Returns:
            The exception raised by the call that the future represents or None
            if the call completed without raising.

        Raises:
            CancelledError: If the future was cancelled.
            TimeoutError: If the future didn't finish executing before the given
                timeout.
        """

        with self._condition:
            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                raise CancelledError()
            elif self._state == FINISHED:
                return self._exception

            self._condition.wait(timeout)

            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                raise CancelledError()
            elif self._state == FINISHED:
                return self._exception
            else:
                raise TimeoutError()

    # The following methods should only be used by Executors and in tests.
    def set_running_or_notify_cancel(self):
        """Mark the future as running or process any cancel notifications.

        Should only be used by Executor implementations and unit tests.

        If the future has been cancelled (cancel() was called and returned
        True) then any threads waiting on the future completing (though calls
        to as_completed() or wait()) are notified and False is returned.

        If the future was not cancelled then it is put in the running state
        (future calls to running() will return True) and True is returned.

        This method should be called by Executor implementations before
        executing the work associated with this future. If this method returns
        False then the work should not be executed.

        Returns:
            False if the Future was cancelled, True otherwise.

        Raises:
            RuntimeError: if this method was already called or if set_result()
                or set_exception() was called.
        """
        with self._condition:
            if self._state == CANCELLED:
                self._state = CANCELLED_AND_NOTIFIED
                for waiter in self._waiters:
                    waiter.add_cancelled(self)
                # self._condition.notify_all() is not necessary because
                # self.cancel() triggers a notification.
                return False
            elif self._state == PENDING:
                self._state = RUNNING
                return True
            else:
                LOGGER.critical('Future %s in unexpected state: %s',
                                id(self.future),
                                self.future._state)
                raise RuntimeError('Future in unexpected state')

    def set_result(self, result):
        """Sets the return value of work associated with the future.

        Should only be used by Executor implementations and unit tests.
        """
        with self._condition:
            self._result = result
            self._state = FINISHED
            for waiter in self._waiters:
                waiter.add_result(self)
            self._condition.notify_all()
        self._invoke_callbacks()

    def set_exception(self, exception):
        """Sets the result of the future as being the given exception.

        Should only be used by Executor implementations and unit tests.
        """
        with self._condition:
            self._exception = exception
            self._state = FINISHED
            for waiter in self._waiters:
                waiter.add_exception(self)
            self._condition.notify_all()
        self._invoke_callbacks()

class Executor(object):
    """This is an abstract base class for concrete asynchronous executors."""

    def submit(self, fn, *args, **kwargs):
        """Submits a callable to be executed with the given arguments.

        Schedules the callable to be executed as fn(*args, **kwargs) and returns
        a Future instance representing the execution of the callable.

        Returns:
            A Future representing the given call.
        """
        raise NotImplementedError()

    def map(self, fn, *iterables, **kwargs):
        """Returns a iterator equivalent to map(fn, iter).

        Args:
            fn: A callable that will take as many arguments as there are
                passed iterables.
            timeout: The maximum number of seconds to wait. If None, then there
                is no limit on the wait time.

        Returns:
            An iterator equivalent to: map(func, *iterables) but the calls may
            be evaluated out-of-order.

        Raises:
            TimeoutError: If the entire result iterator could not be generated
                before the given timeout.
            Exception: If fn(*args) raises for any values.
        """
        timeout = kwargs.get('timeout')
        if timeout is not None:
            end_time = timeout + time.time()

        fs = [self.submit(fn, *args) for args in zip(*iterables)]

        try:
            for future in fs:
                if timeout is None:
                    yield future.result()
                else:
                    yield future.result(end_time - time.time())
        finally:
            for future in fs:
                future.cancel()

    def shutdown(self, wait=True):
        """Clean-up the resources associated with the Executor.

        It is safe to call this method several times. Otherwise, no other
        methods can be called after this one.

        Args:
            wait: If True then shutdown will not return until all running
                futures have finished executing and the resources used by the
                executor have been reclaimed.
        """
        pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.shutdown(wait=True)
        return False
<EOF>
<BOF>
# Copyright 2009 Brian Quinlan. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Execute computations asynchronously using threads or processes."""

__author__ = 'Brian Quinlan (brian@sweetapp.com)'

from concurrent.futures._base import (FIRST_COMPLETED,
                                      FIRST_EXCEPTION,
                                      ALL_COMPLETED,
                                      CancelledError,
                                      TimeoutError,
                                      Future,
                                      Executor,
                                      wait,
                                      as_completed)
from concurrent.futures.process import ProcessPoolExecutor
from concurrent.futures.thread import ThreadPoolExecutor
<EOF>
<BOF>
# Copyright 2009 Brian Quinlan. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Implements ProcessPoolExecutor.

The follow diagram and text describe the data-flow through the system:

|======================= In-process =====================|== Out-of-process ==|

+----------+     +----------+       +--------+     +-----------+    +---------+
|          |  => | Work Ids |    => |        |  => | Call Q    | => |         |
|          |     +----------+       |        |     +-----------+    |         |
|          |     | ...      |       |        |     | ...       |    |         |
|          |     | 6        |       |        |     | 5, call() |    |         |
|          |     | 7        |       |        |     | ...       |    |         |
| Process  |     | ...      |       | Local  |     +-----------+    | Process |
|  Pool    |     +----------+       | Worker |                      |  #1..n  |
| Executor |                        | Thread |                      |         |
|          |     +----------- +     |        |     +-----------+    |         |
|          | <=> | Work Items | <=> |        | <=  | Result Q  | <= |         |
|          |     +------------+     |        |     +-----------+    |         |
|          |     | 6: call()  |     |        |     | ...       |    |         |
|          |     |    future  |     |        |     | 4, result |    |         |
|          |     | ...        |     |        |     | 3, except |    |         |
+----------+     +------------+     +--------+     +-----------+    +---------+

Executor.submit() called:
- creates a uniquely numbered _WorkItem and adds it to the "Work Items" dict
- adds the id of the _WorkItem to the "Work Ids" queue

Local worker thread:
- reads work ids from the "Work Ids" queue and looks up the corresponding
  WorkItem from the "Work Items" dict: if the work item has been cancelled then
  it is simply removed from the dict, otherwise it is repackaged as a
  _CallItem and put in the "Call Q". New _CallItems are put in the "Call Q"
  until "Call Q" is full. NOTE: the size of the "Call Q" is kept small because
  calls placed in the "Call Q" can no longer be cancelled with Future.cancel().
- reads _ResultItems from "Result Q", updates the future stored in the
  "Work Items" dict and deletes the dict entry

Process #1..n:
- reads _CallItems from "Call Q", executes the calls, and puts the resulting
  _ResultItems in "Request Q"
"""

from __future__ import with_statement
import atexit
import multiprocessing
import threading
import weakref
import sys

from concurrent.futures import _base

try:
    import queue
except ImportError:
    import Queue as queue

__author__ = 'Brian Quinlan (brian@sweetapp.com)'

# Workers are created as daemon threads and processes. This is done to allow the
# interpreter to exit when there are still idle processes in a
# ProcessPoolExecutor's process pool (i.e. shutdown() was not called). However,
# allowing workers to die with the interpreter has two undesirable properties:
#   - The workers would still be running during interpretor shutdown,
#     meaning that they would fail in unpredictable ways.
#   - The workers could be killed while evaluating a work item, which could
#     be bad if the callable being evaluated has external side-effects e.g.
#     writing to a file.
#
# To work around this problem, an exit handler is installed which tells the
# workers to exit when their work queues are empty and then waits until the
# threads/processes finish.

_threads_queues = weakref.WeakKeyDictionary()
_shutdown = False

def _python_exit():
    global _shutdown
    _shutdown = True
    items = list(_threads_queues.items())
    for t, q in items:
        q.put(None)
    for t, q in items:
        t.join()

# Controls how many more calls than processes will be queued in the call queue.
# A smaller number will mean that processes spend more time idle waiting for
# work while a larger number will make Future.cancel() succeed less frequently
# (Futures in the call queue cannot be cancelled).
EXTRA_QUEUED_CALLS = 1

class _WorkItem(object):
    def __init__(self, future, fn, args, kwargs):
        self.future = future
        self.fn = fn
        self.args = args
        self.kwargs = kwargs

class _ResultItem(object):
    def __init__(self, work_id, exception=None, result=None):
        self.work_id = work_id
        self.exception = exception
        self.result = result

class _CallItem(object):
    def __init__(self, work_id, fn, args, kwargs):
        self.work_id = work_id
        self.fn = fn
        self.args = args
        self.kwargs = kwargs

def _process_worker(call_queue, result_queue):
    """Evaluates calls from call_queue and places the results in result_queue.

    This worker is run in a separate process.

    Args:
        call_queue: A multiprocessing.Queue of _CallItems that will be read and
            evaluated by the worker.
        result_queue: A multiprocessing.Queue of _ResultItems that will written
            to by the worker.
        shutdown: A multiprocessing.Event that will be set as a signal to the
            worker that it should exit when call_queue is empty.
    """
    while True:
        call_item = call_queue.get(block=True)
        if call_item is None:
            # Wake up queue management thread
            result_queue.put(None)
            return
        try:
            r = call_item.fn(*call_item.args, **call_item.kwargs)
        except BaseException:
            e = sys.exc_info()[1]
            result_queue.put(_ResultItem(call_item.work_id,
                                         exception=e))
        else:
            result_queue.put(_ResultItem(call_item.work_id,
                                         result=r))

def _add_call_item_to_queue(pending_work_items,
                            work_ids,
                            call_queue):
    """Fills call_queue with _WorkItems from pending_work_items.

    This function never blocks.

    Args:
        pending_work_items: A dict mapping work ids to _WorkItems e.g.
            {5: <_WorkItem...>, 6: <_WorkItem...>, ...}
        work_ids: A queue.Queue of work ids e.g. Queue([5, 6, ...]). Work ids
            are consumed and the corresponding _WorkItems from
            pending_work_items are transformed into _CallItems and put in
            call_queue.
        call_queue: A multiprocessing.Queue that will be filled with _CallItems
            derived from _WorkItems.
    """
    while True:
        if call_queue.full():
            return
        try:
            work_id = work_ids.get(block=False)
        except queue.Empty:
            return
        else:
            work_item = pending_work_items[work_id]

            if work_item.future.set_running_or_notify_cancel():
                call_queue.put(_CallItem(work_id,
                                         work_item.fn,
                                         work_item.args,
                                         work_item.kwargs),
                               block=True)
            else:
                del pending_work_items[work_id]
                continue

def _queue_management_worker(executor_reference,
                             processes,
                             pending_work_items,
                             work_ids_queue,
                             call_queue,
                             result_queue):
    """Manages the communication between this process and the worker processes.

    This function is run in a local thread.

    Args:
        executor_reference: A weakref.ref to the ProcessPoolExecutor that owns
            this thread. Used to determine if the ProcessPoolExecutor has been
            garbage collected and that this function can exit.
        process: A list of the multiprocessing.Process instances used as
            workers.
        pending_work_items: A dict mapping work ids to _WorkItems e.g.
            {5: <_WorkItem...>, 6: <_WorkItem...>, ...}
        work_ids_queue: A queue.Queue of work ids e.g. Queue([5, 6, ...]).
        call_queue: A multiprocessing.Queue that will be filled with _CallItems
            derived from _WorkItems for processing by the process workers.
        result_queue: A multiprocessing.Queue of _ResultItems generated by the
            process workers.
    """
    nb_shutdown_processes = [0]
    def shutdown_one_process():
        """Tell a worker to terminate, which will in turn wake us again"""
        call_queue.put(None)
        nb_shutdown_processes[0] += 1
    while True:
        _add_call_item_to_queue(pending_work_items,
                                work_ids_queue,
                                call_queue)

        result_item = result_queue.get(block=True)
        if result_item is not None:
            work_item = pending_work_items[result_item.work_id]
            del pending_work_items[result_item.work_id]

            if result_item.exception:
                work_item.future.set_exception(result_item.exception)
            else:
                work_item.future.set_result(result_item.result)
        # Check whether we should start shutting down.
        executor = executor_reference()
        # No more work items can be added if:
        #   - The interpreter is shutting down OR
        #   - The executor that owns this worker has been collected OR
        #   - The executor that owns this worker has been shutdown.
        if _shutdown or executor is None or executor._shutdown_thread:
            # Since no new work items can be added, it is safe to shutdown
            # this thread if there are no pending work items.
            if not pending_work_items:
                while nb_shutdown_processes[0] < len(processes):
                    shutdown_one_process()
                # If .join() is not called on the created processes then
                # some multiprocessing.Queue methods may deadlock on Mac OS
                # X.
                for p in processes:
                    p.join()
                call_queue.close()
                return
        del executor

_system_limits_checked = False
_system_limited = None
def _check_system_limits():
    global _system_limits_checked, _system_limited
    if _system_limits_checked:
        if _system_limited:
            raise NotImplementedError(_system_limited)
    _system_limits_checked = True
    try:
        import os
        nsems_max = os.sysconf("SC_SEM_NSEMS_MAX")
    except (AttributeError, ValueError):
        # sysconf not available or setting not available
        return
    if nsems_max == -1:
        # indetermine limit, assume that limit is determined
        # by available memory only
        return
    if nsems_max >= 256:
        # minimum number of semaphores available
        # according to POSIX
        return
    _system_limited = "system provides too few semaphores (%d available, 256 necessary)" % nsems_max
    raise NotImplementedError(_system_limited)

class ProcessPoolExecutor(_base.Executor):
    def __init__(self, max_workers=None):
        """Initializes a new ProcessPoolExecutor instance.

        Args:
            max_workers: The maximum number of processes that can be used to
                execute the given calls. If None or not given then as many
                worker processes will be created as the machine has processors.
        """
        _check_system_limits()

        if max_workers is None:
            self._max_workers = multiprocessing.cpu_count()
        else:
            self._max_workers = max_workers

        # Make the call queue slightly larger than the number of processes to
        # prevent the worker processes from idling. But don't make it too big
        # because futures in the call queue cannot be cancelled.
        self._call_queue = multiprocessing.Queue(self._max_workers +
                                                 EXTRA_QUEUED_CALLS)
        self._result_queue = multiprocessing.Queue()
        self._work_ids = queue.Queue()
        self._queue_management_thread = None
        self._processes = set()

        # Shutdown is a two-step process.
        self._shutdown_thread = False
        self._shutdown_lock = threading.Lock()
        self._queue_count = 0
        self._pending_work_items = {}

    def _start_queue_management_thread(self):
        # When the executor gets lost, the weakref callback will wake up
        # the queue management thread.
        def weakref_cb(_, q=self._result_queue):
            q.put(None)
        if self._queue_management_thread is None:
            self._queue_management_thread = threading.Thread(
                    target=_queue_management_worker,
                    args=(weakref.ref(self, weakref_cb),
                          self._processes,
                          self._pending_work_items,
                          self._work_ids,
                          self._call_queue,
                          self._result_queue))
            self._queue_management_thread.daemon = True
            self._queue_management_thread.start()
            _threads_queues[self._queue_management_thread] = self._result_queue

    def _adjust_process_count(self):
        for _ in range(len(self._processes), self._max_workers):
            p = multiprocessing.Process(
                    target=_process_worker,
                    args=(self._call_queue,
                          self._result_queue))
            p.start()
            self._processes.add(p)

    def submit(self, fn, *args, **kwargs):
        with self._shutdown_lock:
            if self._shutdown_thread:
                raise RuntimeError('cannot schedule new futures after shutdown')

            f = _base.Future()
            w = _WorkItem(f, fn, args, kwargs)

            self._pending_work_items[self._queue_count] = w
            self._work_ids.put(self._queue_count)
            self._queue_count += 1
            # Wake up queue management thread
            self._result_queue.put(None)

            self._start_queue_management_thread()
            self._adjust_process_count()
            return f
    submit.__doc__ = _base.Executor.submit.__doc__

    def shutdown(self, wait=True):
        with self._shutdown_lock:
            self._shutdown_thread = True
        if self._queue_management_thread:
            # Wake up queue management thread
            self._result_queue.put(None)
            if wait:
                self._queue_management_thread.join()
        # To reduce the risk of openning too many files, remove references to
        # objects that use file descriptors.
        self._queue_management_thread = None
        self._call_queue = None
        self._result_queue = None
        self._processes = None
    shutdown.__doc__ = _base.Executor.shutdown.__doc__

atexit.register(_python_exit)
<EOF>
<BOF>
from keyword import iskeyword as _iskeyword
from operator import itemgetter as _itemgetter
import sys as _sys


def namedtuple(typename, field_names):
    """Returns a new subclass of tuple with named fields.

    >>> Point = namedtuple('Point', 'x y')
    >>> Point.__doc__                   # docstring for the new class
    'Point(x, y)'
    >>> p = Point(11, y=22)             # instantiate with positional args or keywords
    >>> p[0] + p[1]                     # indexable like a plain tuple
    33
    >>> x, y = p                        # unpack like a regular tuple
    >>> x, y
    (11, 22)
    >>> p.x + p.y                       # fields also accessable by name
    33
    >>> d = p._asdict()                 # convert to a dictionary
    >>> d['x']
    11
    >>> Point(**d)                      # convert from a dictionary
    Point(x=11, y=22)
    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields
    Point(x=100, y=22)

    """

    # Parse and validate the field names.  Validation serves two purposes,
    # generating informative error messages and preventing template injection attacks.
    if isinstance(field_names, basestring):
        field_names = field_names.replace(',', ' ').split() # names separated by whitespace and/or commas
    field_names = tuple(map(str, field_names))
    for name in (typename,) + field_names:
        if not all(c.isalnum() or c=='_' for c in name):
            raise ValueError('Type names and field names can only contain alphanumeric characters and underscores: %r' % name)
        if _iskeyword(name):
            raise ValueError('Type names and field names cannot be a keyword: %r' % name)
        if name[0].isdigit():
            raise ValueError('Type names and field names cannot start with a number: %r' % name)
    seen_names = set()
    for name in field_names:
        if name.startswith('_'):
            raise ValueError('Field names cannot start with an underscore: %r' % name)
        if name in seen_names:
            raise ValueError('Encountered duplicate field name: %r' % name)
        seen_names.add(name)

    # Create and fill-in the class template
    numfields = len(field_names)
    argtxt = repr(field_names).replace("'", "")[1:-1]   # tuple repr without parens or quotes
    reprtxt = ', '.join('%s=%%r' % name for name in field_names)
    dicttxt = ', '.join('%r: t[%d]' % (name, pos) for pos, name in enumerate(field_names))
    template = '''class %(typename)s(tuple):
        '%(typename)s(%(argtxt)s)' \n
        __slots__ = () \n
        _fields = %(field_names)r \n
        def __new__(_cls, %(argtxt)s):
            return _tuple.__new__(_cls, (%(argtxt)s)) \n
        @classmethod
        def _make(cls, iterable, new=tuple.__new__, len=len):
            'Make a new %(typename)s object from a sequence or iterable'
            result = new(cls, iterable)
            if len(result) != %(numfields)d:
                raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result))
            return result \n
        def __repr__(self):
            return '%(typename)s(%(reprtxt)s)' %% self \n
        def _asdict(t):
            'Return a new dict which maps field names to their values'
            return {%(dicttxt)s} \n
        def _replace(_self, **kwds):
            'Return a new %(typename)s object replacing specified fields with new values'
            result = _self._make(map(kwds.pop, %(field_names)r, _self))
            if kwds:
                raise ValueError('Got unexpected field names: %%r' %% kwds.keys())
            return result \n
        def __getnewargs__(self):
            return tuple(self) \n\n''' % locals()
    for i, name in enumerate(field_names):
        template += '        %s = _property(_itemgetter(%d))\n' % (name, i)

    # Execute the template string in a temporary namespace and
    # support tracing utilities by setting a value for frame.f_globals['__name__']
    namespace = dict(_itemgetter=_itemgetter, __name__='namedtuple_%s' % typename,
                     _property=property, _tuple=tuple)
    try:
        exec(template, namespace)
    except SyntaxError:
        e = _sys.exc_info()[1]
        raise SyntaxError(e.message + ':\n' + template)
    result = namespace[typename]

    # For pickling to work, the __module__ variable needs to be set to the frame
    # where the named tuple is created.  Bypass this step in enviroments where
    # sys._getframe is not defined (Jython for example).
    if hasattr(_sys, '_getframe'):
        result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')

    return result
<EOF>
<BOF>
# Copyright 2009 Brian Quinlan. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Implements ThreadPoolExecutor."""

from __future__ import with_statement
import atexit
import threading
import weakref
import sys

from concurrent.futures import _base

try:
    import queue
except ImportError:
    import Queue as queue

__author__ = 'Brian Quinlan (brian@sweetapp.com)'

# Workers are created as daemon threads. This is done to allow the interpreter
# to exit when there are still idle threads in a ThreadPoolExecutor's thread
# pool (i.e. shutdown() was not called). However, allowing workers to die with
# the interpreter has two undesirable properties:
#   - The workers would still be running during interpretor shutdown,
#     meaning that they would fail in unpredictable ways.
#   - The workers could be killed while evaluating a work item, which could
#     be bad if the callable being evaluated has external side-effects e.g.
#     writing to a file.
#
# To work around this problem, an exit handler is installed which tells the
# workers to exit when their work queues are empty and then waits until the
# threads finish.

_threads_queues = weakref.WeakKeyDictionary()
_shutdown = False

def _python_exit():
    global _shutdown
    _shutdown = True
    items = list(_threads_queues.items())
    for t, q in items:
        q.put(None)
    for t, q in items:
        t.join()

atexit.register(_python_exit)

class _WorkItem(object):
    def __init__(self, future, fn, args, kwargs):
        self.future = future
        self.fn = fn
        self.args = args
        self.kwargs = kwargs

    def run(self):
        if not self.future.set_running_or_notify_cancel():
            return

        try:
            result = self.fn(*self.args, **self.kwargs)
        except BaseException:
            e = sys.exc_info()[1]
            self.future.set_exception(e)
        else:
            self.future.set_result(result)

def _worker(executor_reference, work_queue):
    try:
        while True:
            work_item = work_queue.get(block=True)
            if work_item is not None:
                work_item.run()
                continue
            executor = executor_reference()
            # Exit if:
            #   - The interpreter is shutting down OR
            #   - The executor that owns the worker has been collected OR
            #   - The executor that owns the worker has been shutdown.
            if _shutdown or executor is None or executor._shutdown:
                # Notice other workers
                work_queue.put(None)
                return
            del executor
    except BaseException:
        _base.LOGGER.critical('Exception in worker', exc_info=True)

class ThreadPoolExecutor(_base.Executor):
    def __init__(self, max_workers):
        """Initializes a new ThreadPoolExecutor instance.

        Args:
            max_workers: The maximum number of threads that can be used to
                execute the given calls.
        """
        self._max_workers = max_workers
        self._work_queue = queue.Queue()
        self._threads = set()
        self._shutdown = False
        self._shutdown_lock = threading.Lock()

    def submit(self, fn, *args, **kwargs):
        with self._shutdown_lock:
            if self._shutdown:
                raise RuntimeError('cannot schedule new futures after shutdown')

            f = _base.Future()
            w = _WorkItem(f, fn, args, kwargs)

            self._work_queue.put(w)
            self._adjust_thread_count()
            return f
    submit.__doc__ = _base.Executor.submit.__doc__

    def _adjust_thread_count(self):
        # When the executor gets lost, the weakref callback will wake up
        # the worker threads.
        def weakref_cb(_, q=self._work_queue):
            q.put(None)
        # TODO(bquinlan): Should avoid creating new threads if there are more
        # idle threads than items in the work queue.
        if len(self._threads) < self._max_workers:
            t = threading.Thread(target=_worker,
                                 args=(weakref.ref(self, weakref_cb),
                                       self._work_queue))
            t.daemon = True
            t.start()
            self._threads.add(t)
            _threads_queues[t] = self._work_queue

    def shutdown(self, wait=True):
        with self._shutdown_lock:
            self._shutdown = True
            self._work_queue.put(None)
        if wait:
            for t in self._threads:
                t.join()
    shutdown.__doc__ = _base.Executor.shutdown.__doc__
<EOF>
<BOF>
# Copyright 2009 Brian Quinlan. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Execute computations asynchronously using threads or processes."""

import warnings

from concurrent.futures import (FIRST_COMPLETED,
                                FIRST_EXCEPTION,
                                ALL_COMPLETED,
                                CancelledError,
                                TimeoutError,
                                Future,
                                Executor,
                                wait,
                                as_completed,
                                ProcessPoolExecutor,
                                ThreadPoolExecutor)

__author__ = 'Brian Quinlan (brian@sweetapp.com)'

warnings.warn('The futures package has been deprecated. '
              'Use the concurrent.futures package instead.',
              DeprecationWarning)
<EOF>
<BOF>
from concurrent.futures import ProcessPoolExecutor
<EOF>
<BOF>
from concurrent.futures import ThreadPoolExecutor
<EOF>
