<BOF>
#!/usr/bin/env python
from setuptools import setup, find_packages
import pkg_resources
import sys
import os
import fastentrypoints


try:
    if int(pkg_resources.get_distribution("pip").version.split('.')[0]) < 6:
        print('pip older than 6.0 not supported, please upgrade pip with:\n\n'
              '    pip install -U pip')
        sys.exit(-1)
except pkg_resources.DistributionNotFound:
    pass

if os.environ.get('CONVERT_README'):
    import pypandoc

    long_description = pypandoc.convert('README.md', 'rst')
else:
    long_description = ''

version = sys.version_info[:2]
if version < (2, 7):
    print('thefuck requires Python version 2.7 or later' +
          ' ({}.{} detected).'.format(*version))
    sys.exit(-1)
elif (3, 0) < version < (3, 4):
    print('thefuck requires Python version 3.4 or later' +
          ' ({}.{} detected).'.format(*version))
    sys.exit(-1)

VERSION = '3.27'

install_requires = ['psutil', 'colorama', 'six', 'decorator', 'pyte']
extras_require = {':python_version<"3.4"': ['pathlib2'],
                  ':python_version<"3.3"': ['backports.shutil_get_terminal_size'],
                  ":sys_platform=='win32'": ['win_unicode_console']}

setup(name='thefuck',
      version=VERSION,
      description="Magnificent app which corrects your previous console command",
      long_description=long_description,
      author='Vladimir Iakovlev',
      author_email='nvbn.rm@gmail.com',
      url='https://github.com/nvbn/thefuck',
      license='MIT',
      packages=find_packages(exclude=['ez_setup', 'examples',
                                      'tests', 'tests.*', 'release']),
      include_package_data=True,
      zip_safe=False,
      install_requires=install_requires,
      extras_require=extras_require,
      entry_points={'console_scripts': [
          'thefuck = thefuck.entrypoints.main:main',
          'fuck = thefuck.entrypoints.not_configured:main']})
<EOF>
<BOF>
# Copyright (c) 2016, Aaron Christianson
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
'''
Monkey patch setuptools to write faster console_scripts with this format:

    import sys
    from mymodule import entry_function
    sys.exit(entry_function())

This is better.

(c) 2016, Aaron Christianson
http://github.com/ninjaaron/fast-entry_points
'''
from setuptools.command import easy_install
import re
TEMPLATE = '''\
# -*- coding: utf-8 -*-
# EASY-INSTALL-ENTRY-SCRIPT: '{3}','{4}','{5}'
__requires__ = '{3}'
import re
import sys

from {0} import {1}

if __name__ == '__main__':
    sys.argv[0] = re.sub(r'(-script\.pyw?|\.exe)?$', '', sys.argv[0])
    sys.exit({2}())'''


@classmethod
def get_args(cls, dist, header=None):
    """
    Yield write_script() argument tuples for a distribution's
    console_scripts and gui_scripts entry points.
    """
    if header is None:
        header = cls.get_header()
    spec = str(dist.as_requirement())
    for type_ in 'console', 'gui':
        group = type_ + '_scripts'
        for name, ep in dist.get_entry_map(group).items():
            # ensure_safe_name
            if re.search(r'[\\/]', name):
                raise ValueError("Path separators not allowed in script names")
            script_text = TEMPLATE.format(
                          ep.module_name, ep.attrs[0], '.'.join(ep.attrs),
                          spec, group, name)
            args = cls._get_script_args(type_, name, header, script_text)
            for res in args:
                yield res


easy_install.ScriptWriter.get_args = get_args


def main():
    import os
    import re
    import shutil
    import sys
    dests = sys.argv[1:] or ['.']
    filename = re.sub('\.pyc$', '.py', __file__)

    for dst in dests:
        shutil.copy(filename, dst)
        manifest_path = os.path.join(dst, 'MANIFEST.in')
        setup_path = os.path.join(dst, 'setup.py')

        # Insert the include statement to MANIFEST.in if not present
        with open(manifest_path, 'a+') as manifest:
            manifest.seek(0)
            manifest_content = manifest.read()
            if not 'include fastentrypoints.py' in manifest_content:
                manifest.write(('\n' if manifest_content else '')
                               + 'include fastentrypoints.py')

        # Insert the import statement to setup.py if not present
        with open(setup_path, 'a+') as setup:
            setup.seek(0)
            setup_content = setup.read()
            if not 'import fastentrypoints' in setup_content:
                setup.seek(0)
                setup.truncate()
                setup.write('import fastentrypoints\n' + setup_content)

print(__name__)
<EOF>
<BOF>
#!/usr/bin/env python
from subprocess import call
import os
import re


version = None


def get_new_setup_py_lines():
    global version
    with open('setup.py', 'r') as sf:
        current_setup = sf.readlines()
    for line in current_setup:
        if line.startswith('VERSION = '):
            major, minor = re.findall(r"VERSION = '(\d+)\.(\d+)'", line)[0]
            version = "{}.{}".format(major, int(minor) + 1)
            yield "VERSION = '{}'\n".format(version)
        else:
            yield line


lines = list(get_new_setup_py_lines())
with open('setup.py', 'w') as sf:
    sf.writelines(lines)

call('git pull', shell=True)
call('git commit -am "Bump to {}"'.format(version), shell=True)
call('git tag {}'.format(version), shell=True)
call('git push', shell=True)
call('git push --tags', shell=True)

env = os.environ
env['CONVERT_README'] = 'true'
call('python setup.py sdist bdist_wheel', shell=True, env=env)
call('twine upload dist/*', shell=True, env=env)
<EOF>
<BOF>
import os
import pytest
from thefuck import shells
from thefuck import conf, const
from thefuck.system import Path

shells.shell = shells.Generic()


def pytest_addoption(parser):
    """Adds `--enable-functional` argument."""
    group = parser.getgroup("thefuck")
    group.addoption('--enable-functional', action="store_true", default=False,
                    help="Enable functional tests")


@pytest.fixture
def no_memoize(monkeypatch):
    monkeypatch.setattr('thefuck.utils.memoize.disabled', True)


@pytest.fixture(autouse=True)
def settings(request):
    def _reset_settings():
        conf.settings.clear()
        conf.settings.update(const.DEFAULT_SETTINGS)

    request.addfinalizer(_reset_settings)
    conf.settings.user_dir = Path('~/.thefuck')
    return conf.settings


@pytest.fixture
def no_colors(settings):
    settings.no_colors = True


@pytest.fixture(autouse=True)
def no_cache(monkeypatch):
    monkeypatch.setattr('thefuck.utils.cache.disabled', True)


@pytest.fixture(autouse=True)
def functional(request):
    if request.node.get_marker('functional') \
            and not request.config.getoption('enable_functional'):
        pytest.skip('functional tests are disabled')


@pytest.fixture
def source_root():
    return Path(__file__).parent.parent.resolve()


@pytest.fixture
def set_shell(monkeypatch):
    def _set(cls):
        shell = cls()
        monkeypatch.setattr('thefuck.shells.shell', shell)
        return shell

    return _set


@pytest.fixture(autouse=True)
def os_environ(monkeypatch):
    env = {'PATH': os.environ['PATH']}
    monkeypatch.setattr('os.environ', env)
    return env
<EOF>
<BOF>
from thefuck import types
from thefuck.const import DEFAULT_PRIORITY


class Rule(types.Rule):
    def __init__(self, name='', match=lambda *_: True,
                 get_new_command=lambda *_: '',
                 enabled_by_default=True,
                 side_effect=None,
                 priority=DEFAULT_PRIORITY,
                 requires_output=True):
        super(Rule, self).__init__(name, match, get_new_command,
                                   enabled_by_default, side_effect,
                                   priority, requires_output)


class CorrectedCommand(types.CorrectedCommand):
    def __init__(self, script='', side_effect=None, priority=DEFAULT_PRIORITY):
        super(CorrectedCommand, self).__init__(
            script, side_effect, priority)
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

import pytest
from itertools import islice
from thefuck import ui
from thefuck.types import CorrectedCommand
from thefuck import const


@pytest.fixture
def patch_get_key(monkeypatch):
    def patch(vals):
        vals = iter(vals)
        monkeypatch.setattr('thefuck.ui.get_key', lambda: next(vals))

    return patch


def test_read_actions(patch_get_key):
    patch_get_key([
        # Enter:
        '\n',
        # Enter:
        '\r',
        # Ignored:
        'x', 'y',
        # Up:
        const.KEY_UP, 'k',
        # Down:
        const.KEY_DOWN, 'j',
        # Ctrl+C:
        const.KEY_CTRL_C, 'q'])
    assert (list(islice(ui.read_actions(), 8))
            == [const.ACTION_SELECT, const.ACTION_SELECT,
                const.ACTION_PREVIOUS, const.ACTION_PREVIOUS,
                const.ACTION_NEXT, const.ACTION_NEXT,
                const.ACTION_ABORT, const.ACTION_ABORT])


def test_command_selector():
    selector = ui.CommandSelector(iter([1, 2, 3]))
    assert selector.value == 1
    selector.next()
    assert selector.value == 2
    selector.next()
    assert selector.value == 3
    selector.next()
    assert selector.value == 1
    selector.previous()
    assert selector.value == 3


@pytest.mark.usefixtures('no_colors')
class TestSelectCommand(object):
    @pytest.fixture
    def commands_with_side_effect(self):
        return [CorrectedCommand('ls', lambda *_: None, 100),
                CorrectedCommand('cd', lambda *_: None, 100)]

    @pytest.fixture
    def commands(self):
        return [CorrectedCommand('ls', None, 100),
                CorrectedCommand('cd', None, 100)]

    def test_without_commands(self, capsys):
        assert ui.select_command(iter([])) is None
        assert capsys.readouterr() == ('', 'No fucks given\n')

    def test_without_confirmation(self, capsys, commands, settings):
        settings.require_confirmation = False
        assert ui.select_command(iter(commands)) == commands[0]
        assert capsys.readouterr() == ('', const.USER_COMMAND_MARK + 'ls\n')

    def test_without_confirmation_with_side_effects(
            self, capsys, commands_with_side_effect, settings):
        settings.require_confirmation = False
        assert (ui.select_command(iter(commands_with_side_effect))
                == commands_with_side_effect[0])
        assert capsys.readouterr() == ('', const.USER_COMMAND_MARK + 'ls (+side effect)\n')

    def test_with_confirmation(self, capsys, patch_get_key, commands):
        patch_get_key(['\n'])
        assert ui.select_command(iter(commands)) == commands[0]
        assert capsys.readouterr() == (
            '', const.USER_COMMAND_MARK + u'\x1b[1K\rls [enter/↑/↓/ctrl+c]\n')

    def test_with_confirmation_abort(self, capsys, patch_get_key, commands):
        patch_get_key([const.KEY_CTRL_C])
        assert ui.select_command(iter(commands)) is None
        assert capsys.readouterr() == (
            '', const.USER_COMMAND_MARK + u'\x1b[1K\rls [enter/↑/↓/ctrl+c]\nAborted\n')

    def test_with_confirmation_with_side_effct(self, capsys, patch_get_key,
                                               commands_with_side_effect):
        patch_get_key(['\n'])
        assert (ui.select_command(iter(commands_with_side_effect))
                == commands_with_side_effect[0])
        assert capsys.readouterr() == (
            '', const.USER_COMMAND_MARK + u'\x1b[1K\rls (+side effect) [enter/↑/↓/ctrl+c]\n')

    def test_with_confirmation_select_second(self, capsys, patch_get_key, commands):
        patch_get_key([const.KEY_DOWN, '\n'])
        assert ui.select_command(iter(commands)) == commands[1]
        stderr = (
            u'{mark}\x1b[1K\rls [enter/↑/↓/ctrl+c]'
            u'{mark}\x1b[1K\rcd [enter/↑/↓/ctrl+c]\n'
        ).format(mark=const.USER_COMMAND_MARK)
        assert capsys.readouterr() == ('', stderr)
<EOF>
<BOF>
import pytest
from thefuck.argument_parser import Parser
from thefuck.const import ARGUMENT_PLACEHOLDER


def _args(**override):
    args = {'alias': None, 'command': [], 'yes': False,
            'help': False, 'version': False, 'debug': False,
            'force_command': None, 'repeat': False,
            'enable_experimental_instant_mode': False,
            'shell_logger': None}
    args.update(override)
    return args


@pytest.mark.parametrize('argv, result', [
    (['thefuck'], _args()),
    (['thefuck', '-a'], _args(alias='fuck')),
    (['thefuck', '--alias', '--enable-experimental-instant-mode'],
     _args(alias='fuck', enable_experimental_instant_mode=True)),
    (['thefuck', '-a', 'fix'], _args(alias='fix')),
    (['thefuck', 'git', 'branch', ARGUMENT_PLACEHOLDER, '-y'],
     _args(command=['git', 'branch'], yes=True)),
    (['thefuck', 'git', 'branch', '-a', ARGUMENT_PLACEHOLDER, '-y'],
     _args(command=['git', 'branch', '-a'], yes=True)),
    (['thefuck', ARGUMENT_PLACEHOLDER, '-v'], _args(version=True)),
    (['thefuck', ARGUMENT_PLACEHOLDER, '--help'], _args(help=True)),
    (['thefuck', 'git', 'branch', '-a', ARGUMENT_PLACEHOLDER, '-y', '-d'],
     _args(command=['git', 'branch', '-a'], yes=True, debug=True)),
    (['thefuck', 'git', 'branch', '-a', ARGUMENT_PLACEHOLDER, '-r', '-d'],
     _args(command=['git', 'branch', '-a'], repeat=True, debug=True)),
    (['thefuck', '-l', '/tmp/log'], _args(shell_logger='/tmp/log')),
    (['thefuck', '--shell-logger', '/tmp/log'],
     _args(shell_logger='/tmp/log'))])
def test_parse(argv, result):
    assert vars(Parser().parse(argv)) == result
<EOF>
<BOF>
def test_readme(source_root):
    with source_root.joinpath('README.md').open() as f:
        readme = f.read()

        bundled = source_root.joinpath('thefuck') \
                             .joinpath('rules') \
                             .glob('*.py')

        for rule in bundled:
            if rule.stem != '__init__':
                assert rule.stem in readme,\
                    'Missing rule "{}" in README.md'.format(rule.stem)
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import pytest
from tests.utils import Rule, CorrectedCommand
from thefuck import corrector, const
from thefuck.system import Path
from thefuck.types import Command
from thefuck.corrector import get_corrected_commands, organize_commands


class TestGetRules(object):
    @pytest.fixture
    def glob(self, mocker):
        results = {}
        mocker.patch('thefuck.system.Path.glob',
                     new_callable=lambda: lambda *_: results.pop('value', []))
        return lambda value: results.update({'value': value})

    @pytest.fixture(autouse=True)
    def load_source(self, monkeypatch):
        monkeypatch.setattr('thefuck.types.load_source',
                            lambda x, _: Rule(x))

    def _compare_names(self, rules, names):
        assert {r.name for r in rules} == set(names)

    @pytest.mark.parametrize('paths, conf_rules, exclude_rules, loaded_rules', [
        (['git.py', 'bash.py'], const.DEFAULT_RULES, [], ['git', 'bash']),
        (['git.py', 'bash.py'], ['git'], [], ['git']),
        (['git.py', 'bash.py'], const.DEFAULT_RULES, ['git'], ['bash']),
        (['git.py', 'bash.py'], ['git'], ['git'], [])])
    def test_get_rules(self, glob, settings, paths, conf_rules, exclude_rules,
                       loaded_rules):
        glob([Path(path) for path in paths])
        settings.update(rules=conf_rules,
                        priority={},
                        exclude_rules=exclude_rules)
        rules = corrector.get_rules()
        self._compare_names(rules, loaded_rules)


def test_get_corrected_commands(mocker):
    command = Command('test', 'test')
    rules = [Rule(match=lambda _: False),
             Rule(match=lambda _: True,
                  get_new_command=lambda x: x.script + '!', priority=100),
             Rule(match=lambda _: True,
                  get_new_command=lambda x: [x.script + '@', x.script + ';'],
                  priority=60)]
    mocker.patch('thefuck.corrector.get_rules', return_value=rules)
    assert ([cmd.script for cmd in get_corrected_commands(command)]
            == ['test!', 'test@', 'test;'])


def test_organize_commands():
    """Ensures that the function removes duplicates and sorts commands."""
    commands = [CorrectedCommand('ls'), CorrectedCommand('ls -la', priority=9000),
                CorrectedCommand('ls -lh', priority=100),
                CorrectedCommand(u'echo café', priority=200),
                CorrectedCommand('ls -lh', priority=9999)]
    assert list(organize_commands(iter(commands))) \
        == [CorrectedCommand('ls'), CorrectedCommand('ls -lh', priority=100),
            CorrectedCommand(u'echo café', priority=200),
            CorrectedCommand('ls -la', priority=9000)]
<EOF>
<BOF>
import pytest
from thefuck import logs


def test_color(settings):
    settings.no_colors = False
    assert logs.color('red') == 'red'
    settings.no_colors = True
    assert logs.color('red') == ''


@pytest.mark.usefixtures('no_colors')
@pytest.mark.parametrize('debug, stderr', [
    (True, 'DEBUG: test\n'),
    (False, '')])
def test_debug(capsys, settings, debug, stderr):
    settings.debug = debug
    logs.debug('test')
    assert capsys.readouterr() == ('', stderr)
<EOF>
<BOF>
import pytest
import six
import os
from mock import Mock
from thefuck import const


@pytest.fixture
def load_source(mocker):
    return mocker.patch('thefuck.conf.load_source')


def test_settings_defaults(load_source, settings):
    load_source.return_value = object()
    settings.init()
    for key, val in const.DEFAULT_SETTINGS.items():
        assert getattr(settings, key) == val


class TestSettingsFromFile(object):
    def test_from_file(self, load_source, settings):
        load_source.return_value = Mock(rules=['test'],
                                        wait_command=10,
                                        require_confirmation=True,
                                        no_colors=True,
                                        priority={'vim': 100},
                                        exclude_rules=['git'])
        settings.init()
        assert settings.rules == ['test']
        assert settings.wait_command == 10
        assert settings.require_confirmation is True
        assert settings.no_colors is True
        assert settings.priority == {'vim': 100}
        assert settings.exclude_rules == ['git']

    def test_from_file_with_DEFAULT(self, load_source, settings):
        load_source.return_value = Mock(rules=const.DEFAULT_RULES + ['test'],
                                        wait_command=10,
                                        exclude_rules=[],
                                        require_confirmation=True,
                                        no_colors=True)
        settings.init()
        assert settings.rules == const.DEFAULT_RULES + ['test']


@pytest.mark.usefixture('load_source')
class TestSettingsFromEnv(object):
    def test_from_env(self, os_environ, settings):
        os_environ.update({'THEFUCK_RULES': 'bash:lisp',
                           'THEFUCK_EXCLUDE_RULES': 'git:vim',
                           'THEFUCK_WAIT_COMMAND': '55',
                           'THEFUCK_REQUIRE_CONFIRMATION': 'true',
                           'THEFUCK_NO_COLORS': 'false',
                           'THEFUCK_PRIORITY': 'bash=10:lisp=wrong:vim=15',
                           'THEFUCK_WAIT_SLOW_COMMAND': '999',
                           'THEFUCK_SLOW_COMMANDS': 'lein:react-native:./gradlew',
                           'THEFUCK_NUM_CLOSE_MATCHES': '359'})
        settings.init()
        assert settings.rules == ['bash', 'lisp']
        assert settings.exclude_rules == ['git', 'vim']
        assert settings.wait_command == 55
        assert settings.require_confirmation is True
        assert settings.no_colors is False
        assert settings.priority == {'bash': 10, 'vim': 15}
        assert settings.wait_slow_command == 999
        assert settings.slow_commands == ['lein', 'react-native', './gradlew']
        assert settings.num_close_matches == 359

    def test_from_env_with_DEFAULT(self, os_environ, settings):
        os_environ.update({'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'})
        settings.init()
        assert settings.rules == const.DEFAULT_RULES + ['bash', 'lisp']


def test_settings_from_args(settings):
    settings.init(Mock(yes=True, debug=True, repeat=True))
    assert not settings.require_confirmation
    assert settings.debug
    assert settings.repeat


class TestInitializeSettingsFile(object):
    def test_ignore_if_exists(self, settings):
        settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())
        settings.user_dir = Mock(joinpath=Mock(return_value=settings_path_mock))
        settings._init_settings_file()
        assert settings_path_mock.is_file.call_count == 1
        assert not settings_path_mock.open.called

    def test_create_if_doesnt_exists(self, settings):
        settings_file = six.StringIO()
        settings_path_mock = Mock(
            is_file=Mock(return_value=False),
            open=Mock(return_value=Mock(
                __exit__=lambda *args: None, __enter__=lambda *args: settings_file)))
        settings.user_dir = Mock(joinpath=Mock(return_value=settings_path_mock))
        settings._init_settings_file()
        settings_file_contents = settings_file.getvalue()
        assert settings_path_mock.is_file.call_count == 1
        assert settings_path_mock.open.call_count == 1
        assert const.SETTINGS_HEADER in settings_file_contents
        for setting in const.DEFAULT_SETTINGS.items():
            assert '# {} = {}\n'.format(*setting) in settings_file_contents
        settings_file.close()


@pytest.mark.parametrize('legacy_dir_exists, xdg_config_home, result', [
    (False, '~/.config', '~/.config/thefuck'),
    (False, '/user/test/config/', '/user/test/config/thefuck'),
    (True, '~/.config', '~/.thefuck'),
    (True, '/user/test/config/', '~/.thefuck')])
def test_get_user_dir_path(mocker, os_environ, settings, legacy_dir_exists,
                           xdg_config_home, result):
    mocker.patch('thefuck.conf.Path.is_dir',
                 return_value=legacy_dir_exists)

    if xdg_config_home is not None:
        os_environ['XDG_CONFIG_HOME'] = xdg_config_home
    else:
        os_environ.pop('XDG_CONFIG_HOME', None)

    path = settings._get_user_dir_path().as_posix()
    assert path == os.path.expanduser(result)
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import pytest
import warnings
from mock import Mock, patch
from thefuck.utils import default_settings, \
    memoize, get_closest, get_all_executables, replace_argument, \
    get_all_matched_commands, is_app, for_app, cache, \
    get_valid_history_without_current, _cache, get_close_matches
from thefuck.types import Command


@pytest.mark.parametrize('override, old, new', [
    ({'key': 'val'}, {}, {'key': 'val'}),
    ({'key': 'new-val'}, {'key': 'val'}, {'key': 'val'}),
    ({'key': 'new-val', 'unset': 'unset'}, {'key': 'val'}, {'key': 'val', 'unset': 'unset'})])
def test_default_settings(settings, override, old, new):
    settings.clear()
    settings.update(old)
    default_settings(override)(lambda _: _)(None)
    assert settings == new


def test_memoize():
    fn = Mock(__name__='fn')
    memoized = memoize(fn)
    memoized()
    memoized()
    fn.assert_called_once_with()


@pytest.mark.usefixtures('no_memoize')
def test_no_memoize():
    fn = Mock(__name__='fn')
    memoized = memoize(fn)
    memoized()
    memoized()
    assert fn.call_count == 2


class TestGetClosest(object):
    def test_when_can_match(self):
        assert 'branch' == get_closest('brnch', ['branch', 'status'])

    def test_when_cant_match(self):
        assert 'status' == get_closest('st', ['status', 'reset'])

    def test_without_fallback(self):
        assert get_closest('st', ['status', 'reset'],
                           fallback_to_first=False) is None


class TestGetCloseMatches(object):
    @patch('thefuck.utils.difflib_get_close_matches')
    def test_call_with_n(self, difflib_mock):
        get_close_matches('', [], 1)
        assert difflib_mock.call_args[0][2] == 1

    @patch('thefuck.utils.difflib_get_close_matches')
    def test_call_without_n(self, difflib_mock, settings):
        get_close_matches('', [])
        assert difflib_mock.call_args[0][2] == settings.get('num_close_matches')


@pytest.fixture
def get_aliases(mocker):
    mocker.patch('thefuck.shells.shell.get_aliases',
                 return_value=['vim', 'apt-get', 'fsck', 'fuck'])


@pytest.mark.usefixtures('no_memoize', 'get_aliases')
def test_get_all_executables():
    all_callables = get_all_executables()
    assert 'vim' in all_callables
    assert 'fsck' in all_callables
    assert 'fuck' not in all_callables


@pytest.mark.parametrize('args, result', [
    (('apt-get instol vim', 'instol', 'install'), 'apt-get install vim'),
    (('git brnch', 'brnch', 'branch'), 'git branch')])
def test_replace_argument(args, result):
    assert replace_argument(*args) == result


@pytest.mark.parametrize('stderr, result', [
    (("git: 'cone' is not a git command. See 'git --help'.\n"
      '\n'
      'Did you mean one of these?\n'
      '\tclone'), ['clone']),
    (("git: 're' is not a git command. See 'git --help'.\n"
      '\n'
      'Did you mean one of these?\n'
      '\trebase\n'
      '\treset\n'
      '\tgrep\n'
      '\trm'), ['rebase', 'reset', 'grep', 'rm']),
    (('tsuru: "target" is not a tsuru command. See "tsuru help".\n'
      '\n'
      'Did you mean one of these?\n'
      '\tservice-add\n'
      '\tservice-bind\n'
      '\tservice-doc\n'
      '\tservice-info\n'
      '\tservice-list\n'
      '\tservice-remove\n'
      '\tservice-status\n'
      '\tservice-unbind'), ['service-add', 'service-bind', 'service-doc',
                            'service-info', 'service-list', 'service-remove',
                            'service-status', 'service-unbind'])])
def test_get_all_matched_commands(stderr, result):
    assert list(get_all_matched_commands(stderr)) == result


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, names, result', [
    ('git diff', ['git', 'hub'], True),
    ('hub diff', ['git', 'hub'], True),
    ('hg diff', ['git', 'hub'], False)])
def test_is_app(script, names, result):
    assert is_app(Command(script, ''), *names) == result


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, names, result', [
    ('git diff', ['git', 'hub'], True),
    ('hub diff', ['git', 'hub'], True),
    ('hg diff', ['git', 'hub'], False)])
def test_for_app(script, names, result):
    @for_app(*names)
    def match(command):
        return True

    assert match(Command(script, '')) == result


class TestCache(object):
    @pytest.fixture
    def shelve(self, mocker):
        value = {}

        class _Shelve(object):
            def __init__(self, path):
                pass

            def __setitem__(self, k, v):
                value[k] = v

            def __getitem__(self, k):
                return value[k]

            def get(self, k, v=None):
                return value.get(k, v)

            def close(self):
                return

        mocker.patch('thefuck.utils.shelve.open', new_callable=lambda: _Shelve)
        return value

    @pytest.fixture(autouse=True)
    def enable_cache(self, monkeypatch, shelve):
        monkeypatch.setattr('thefuck.utils.cache.disabled', False)
        _cache._init_db()

    @pytest.fixture(autouse=True)
    def mtime(self, mocker):
        mocker.patch('thefuck.utils.os.path.getmtime', return_value=0)

    @pytest.fixture
    def fn(self):
        @cache('~/.bashrc')
        def fn():
            return 'test'

        return fn

    @pytest.fixture
    def key(self, monkeypatch):
        monkeypatch.setattr('thefuck.utils.Cache._get_key',
                            lambda *_: 'key')
        return 'key'

    def test_with_blank_cache(self, shelve, fn, key):
        assert shelve == {}
        assert fn() == 'test'
        assert shelve == {key: {'etag': '0', 'value': 'test'}}

    def test_with_filled_cache(self, shelve, fn, key):
        cache_value = {key: {'etag': '0', 'value': 'new-value'}}
        shelve.update(cache_value)
        assert fn() == 'new-value'
        assert shelve == cache_value

    def test_when_etag_changed(self, shelve, fn, key):
        shelve.update({key: {'etag': '-1', 'value': 'old-value'}})
        assert fn() == 'test'
        assert shelve == {key: {'etag': '0', 'value': 'test'}}


class TestGetValidHistoryWithoutCurrent(object):
    @pytest.yield_fixture(autouse=True)
    def fail_on_warning(self):
        warnings.simplefilter('error')
        yield
        warnings.resetwarnings()

    @pytest.fixture(autouse=True)
    def history(self, mocker):
        return mocker.patch('thefuck.shells.shell.get_history',
                            return_value=['le cat', 'fuck', 'ls cat',
                                          'diff x', 'nocommand x', u'café ô'])

    @pytest.fixture(autouse=True)
    def alias(self, mocker):
        return mocker.patch('thefuck.utils.get_alias',
                            return_value='fuck')

    @pytest.fixture(autouse=True)
    def bins(self, mocker):
        callables = list()
        for name in ['diff', 'ls', 'café']:
            bin_mock = mocker.Mock(name=name)
            bin_mock.configure_mock(name=name, is_dir=lambda: False)
            callables.append(bin_mock)
        path_mock = mocker.Mock(iterdir=mocker.Mock(return_value=callables))
        return mocker.patch('thefuck.utils.Path', return_value=path_mock)

    @pytest.mark.parametrize('script, result', [
        ('le cat', ['ls cat', 'diff x', u'café ô']),
        ('diff x', ['ls cat', u'café ô']),
        ('fuck', ['ls cat', 'diff x', u'café ô']),
        (u'cafe ô', ['ls cat', 'diff x', u'café ô']),
    ])
    def test_get_valid_history_without_current(self, script, result):
        command = Command(script, '')
        assert get_valid_history_without_current(command) == result
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import os
from subprocess import PIPE, STDOUT
from mock import Mock
import pytest
from tests.utils import CorrectedCommand, Rule
from thefuck import const
from thefuck.exceptions import EmptyCommand
from thefuck.system import Path
from thefuck.types import Command


class TestCorrectedCommand(object):

    def test_equality(self):
        assert (CorrectedCommand('ls', None, 100) ==
                CorrectedCommand('ls', None, 200))
        assert (CorrectedCommand('ls', None, 100) !=
                CorrectedCommand('ls', lambda *_: _, 100))

    def test_hashable(self):
        assert {CorrectedCommand('ls', None, 100),
                CorrectedCommand('ls', None, 200)} == {CorrectedCommand('ls')}

    def test_representable(self):
        assert '{}'.format(CorrectedCommand('ls', None, 100)) == \
               'CorrectedCommand(script=ls, side_effect=None, priority=100)'
        assert u'{}'.format(CorrectedCommand(u'echo café', None, 100)) == \
               u'CorrectedCommand(script=echo café, side_effect=None, priority=100)'

    @pytest.mark.parametrize('script, printed, override_settings', [
        ('git branch', 'git branch', {'repeat': False, 'debug': False}),
        ('git brunch',
         "git brunch || fuck --repeat --force-command 'git brunch'",
         {'repeat': True, 'debug': False}),
        ('git brunch',
         "git brunch || fuck --repeat --debug --force-command 'git brunch'",
         {'repeat': True, 'debug': True})])
    def test_run(self, capsys, settings, script, printed, override_settings):
        settings.update(override_settings)
        CorrectedCommand(script, None, 1000).run(Command(script, ''))
        out, _ = capsys.readouterr()
        assert out[:-1] == printed


class TestRule(object):
    def test_from_path(self, mocker):
        match = object()
        get_new_command = object()
        load_source = mocker.patch(
            'thefuck.types.load_source',
            return_value=Mock(match=match,
                              get_new_command=get_new_command,
                              enabled_by_default=True,
                              priority=900,
                              requires_output=True))
        rule_path = os.path.join(os.sep, 'rules', 'bash.py')
        assert (Rule.from_path(Path(rule_path))
                == Rule('bash', match, get_new_command, priority=900))
        load_source.assert_called_once_with('bash', rule_path)

    @pytest.mark.parametrize('rules, exclude_rules, rule, is_enabled', [
        (const.DEFAULT_RULES, [], Rule('git', enabled_by_default=True), True),
        (const.DEFAULT_RULES, [], Rule('git', enabled_by_default=False), False),
        ([], [], Rule('git', enabled_by_default=False), False),
        ([], [], Rule('git', enabled_by_default=True), False),
        (const.DEFAULT_RULES + ['git'], [], Rule('git', enabled_by_default=False), True),
        (['git'], [], Rule('git', enabled_by_default=False), True),
        (const.DEFAULT_RULES, ['git'], Rule('git', enabled_by_default=True), False),
        (const.DEFAULT_RULES, ['git'], Rule('git', enabled_by_default=False), False),
        ([], ['git'], Rule('git', enabled_by_default=True), False),
        ([], ['git'], Rule('git', enabled_by_default=False), False)])
    def test_is_enabled(self, settings, rules, exclude_rules, rule, is_enabled):
        settings.update(rules=rules,
                        exclude_rules=exclude_rules)
        assert rule.is_enabled == is_enabled

    def test_isnt_match(self):
        assert not Rule('', lambda _: False).is_match(
            Command('ls', ''))

    def test_is_match(self):
        rule = Rule('', lambda x: x.script == 'cd ..')
        assert rule.is_match(Command('cd ..', ''))

    @pytest.mark.usefixtures('no_colors')
    def test_isnt_match_when_rule_failed(self, capsys):
        rule = Rule('test', Mock(side_effect=OSError('Denied')),
                    requires_output=False)
        assert not rule.is_match(Command('ls', ''))
        assert capsys.readouterr()[1].split('\n')[0] == '[WARN] Rule test:'

    def test_get_corrected_commands_with_rule_returns_list(self):
        rule = Rule(get_new_command=lambda x: [x.script + '!', x.script + '@'],
                    priority=100)
        assert (list(rule.get_corrected_commands(Command('test', '')))
                == [CorrectedCommand(script='test!', priority=100),
                    CorrectedCommand(script='test@', priority=200)])

    def test_get_corrected_commands_with_rule_returns_command(self):
        rule = Rule(get_new_command=lambda x: x.script + '!',
                    priority=100)
        assert (list(rule.get_corrected_commands(Command('test', '')))
                == [CorrectedCommand(script='test!', priority=100)])


class TestCommand(object):
    @pytest.fixture(autouse=True)
    def Popen(self, monkeypatch):
        Popen = Mock()
        Popen.return_value.stdout.read.return_value = b'output'
        monkeypatch.setattr('thefuck.output_readers.rerun.Popen', Popen)
        return Popen

    @pytest.fixture(autouse=True)
    def prepare(self, monkeypatch):
        monkeypatch.setattr('thefuck.output_readers.rerun._wait_output',
                            lambda *_: True)

    def test_from_script_calls(self, Popen, settings, os_environ):
        settings.env = {}
        assert Command.from_raw_script(
            ['apt-get', 'search', 'vim']) == Command(
            'apt-get search vim', 'output')
        Popen.assert_called_once_with('apt-get search vim',
                                      shell=True,
                                      stdin=PIPE,
                                      stdout=PIPE,
                                      stderr=STDOUT,
                                      env=os_environ)

    @pytest.mark.parametrize('script, result', [
        ([''], None),
        (['', ''], None),
        (['ls', '-la'], 'ls -la'),
        (['ls'], 'ls')])
    def test_from_script(self, script, result):
        if result:
            assert Command.from_raw_script(script).script == result
        else:
            with pytest.raises(EmptyCommand):
                Command.from_raw_script(script)
<EOF>
<BOF>
import pytest
from tests.functional.plots import with_confirmation, without_confirmation, \
    refuse_with_confirmation, select_command_with_arrows

containers = (('thefuck/python3-fish',
               u'''FROM python:3
                   # Use jessie-backports since it has the fish package. See here for details:
                   # https://github.com/tianon/docker-brew-debian/blob/88ae21052affd8a14553bb969f9d41c464032122/jessie/backports/Dockerfile
                   RUN awk '$1 ~ "^deb" { $3 = $3 "-backports"; print; exit }' /etc/apt/sources.list > /etc/apt/sources.list.d/backports.list
                   RUN apt-get update
                   RUN apt-get install -yy fish''',
               u'fish'),
              ('thefuck/python2-fish',
               u'''FROM python:2
                   # Use jessie-backports since it has the fish package. See here for details:
                   # https://github.com/tianon/docker-brew-debian/blob/88ae21052affd8a14553bb969f9d41c464032122/jessie/backports/Dockerfile
                   RUN awk '$1 ~ "^deb" { $3 = $3 "-backports"; print; exit }' /etc/apt/sources.list > /etc/apt/sources.list.d/backports.list
                   RUN apt-get update
                   RUN apt-get install -yy fish''',
               u'fish'))


@pytest.fixture(params=containers)
def proc(request, spawnu, TIMEOUT):
    proc = spawnu(*request.param)
    proc.sendline(u"pip install /src")
    assert proc.expect([TIMEOUT, u'Successfully installed'])
    proc.sendline(u'thefuck --alias > ~/.config/fish/config.fish')
    proc.sendline(u'fish')
    return proc


@pytest.mark.functional
def test_with_confirmation(proc, TIMEOUT):
    with_confirmation(proc, TIMEOUT)


@pytest.mark.functional
def test_select_command_with_arrows(proc, TIMEOUT):
    select_command_with_arrows(proc, TIMEOUT)


@pytest.mark.functional
def test_refuse_with_confirmation(proc, TIMEOUT):
    refuse_with_confirmation(proc, TIMEOUT)


@pytest.mark.functional
def test_without_confirmation(proc, TIMEOUT):
    without_confirmation(proc, TIMEOUT)

# TODO: ensure that history changes.
<EOF>
<BOF>
import pytest
from tests.functional.plots import with_confirmation, without_confirmation, \
    refuse_with_confirmation, history_changed, history_not_changed, \
    select_command_with_arrows, how_to_configure


python_3 = ('thefuck/python3-zsh',
            u'''FROM python:3
                RUN apt-get update
                RUN apt-get install -yy zsh''',
            u'sh')

python_2 = ('thefuck/python2-zsh',
            u'''FROM python:2
                RUN apt-get update
                RUN apt-get install -yy zsh''',
            u'sh')


init_zshrc = u'''echo '
export SHELL=/usr/bin/zsh
export HISTFILE=~/.zsh_history
echo > $HISTFILE
export SAVEHIST=100
export HISTSIZE=100
eval $(thefuck --alias {})
setopt INC_APPEND_HISTORY
echo "instant mode ready: $THEFUCK_INSTANT_MODE"
' > ~/.zshrc'''


@pytest.fixture(params=[(python_3, False),
                        (python_3, True),
                        (python_2, False)])
def proc(request, spawnu, TIMEOUT):
    container, instant_mode = request.param
    proc = spawnu(*container)
    proc.sendline(u'pip install /src')
    assert proc.expect([TIMEOUT, u'Successfully installed'])
    proc.sendline(init_zshrc.format(
        u'--enable-experimental-instant-mode' if instant_mode else ''))
    proc.sendline(u"zsh")
    if instant_mode:
        assert proc.expect([TIMEOUT, u'instant mode ready: True'])
    return proc


@pytest.mark.functional
def test_with_confirmation(proc, TIMEOUT):
    with_confirmation(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'echo test')


@pytest.mark.functional
def test_select_command_with_arrows(proc, TIMEOUT):
    select_command_with_arrows(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'git help')


@pytest.mark.functional
def test_refuse_with_confirmation(proc, TIMEOUT):
    refuse_with_confirmation(proc, TIMEOUT)
    history_not_changed(proc, TIMEOUT)


@pytest.mark.functional
def test_without_confirmation(proc, TIMEOUT):
    without_confirmation(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'echo test')


@pytest.mark.functional
def test_how_to_configure_alias(proc, TIMEOUT):
    proc.sendline(u'unfunction fuck')
    how_to_configure(proc, TIMEOUT)
<EOF>
<BOF>
import pytest
from tests.functional.plots import with_confirmation, without_confirmation, \
    refuse_with_confirmation, select_command_with_arrows

containers = (('thefuck/python3-tcsh',
               u'''FROM python:3
                   RUN apt-get update
                   RUN apt-get install -yy tcsh''',
               u'tcsh'),
              ('thefuck/python2-tcsh',
               u'''FROM python:2
                   RUN apt-get update
                   RUN apt-get install -yy tcsh''',
               u'tcsh'))


@pytest.fixture(params=containers)
def proc(request, spawnu, TIMEOUT):
    proc = spawnu(*request.param)
    proc.sendline(u'pip install /src')
    assert proc.expect([TIMEOUT, u'Successfully installed'])
    proc.sendline(u'tcsh')
    proc.sendline(u'setenv PYTHONIOENCODING utf8')
    proc.sendline(u'eval `thefuck --alias`')
    return proc


@pytest.mark.functional
def test_with_confirmation(proc, TIMEOUT):
    with_confirmation(proc, TIMEOUT)


@pytest.mark.functional
def test_select_command_with_arrows(proc, TIMEOUT):
    select_command_with_arrows(proc, TIMEOUT)


@pytest.mark.functional
def test_refuse_with_confirmation(proc, TIMEOUT):
    refuse_with_confirmation(proc, TIMEOUT)


@pytest.mark.functional
def test_without_confirmation(proc, TIMEOUT):
    without_confirmation(proc, TIMEOUT)

# TODO: ensure that history changes.
<EOF>
<BOF>
import pytest
from tests.functional.plots import with_confirmation, without_confirmation, \
    refuse_with_confirmation, history_changed, history_not_changed, \
    select_command_with_arrows, how_to_configure


python_3 = (u'thefuck/python3-bash',
            u'FROM python:3',
            u'sh')

python_2 = (u'thefuck/python2-bash',
            u'FROM python:2',
            u'sh')


init_bashrc = u'''echo '
export SHELL=/bin/bash
export PS1="$ "
echo > $HISTFILE
eval $(thefuck --alias {})
echo "instant mode ready: $THEFUCK_INSTANT_MODE"
' > ~/.bashrc'''


@pytest.fixture(params=[(python_3, False),
                        (python_3, True),
                        (python_2, False)])
def proc(request, spawnu, TIMEOUT):
    container, instant_mode = request.param
    proc = spawnu(*container)
    proc.sendline(u"pip install /src")
    assert proc.expect([TIMEOUT, u'Successfully installed'])
    proc.sendline(init_bashrc.format(
        u'--enable-experimental-instant-mode' if instant_mode else ''))
    proc.sendline(u"bash")
    if instant_mode:
        assert proc.expect([TIMEOUT, u'instant mode ready: True'])
    return proc


@pytest.mark.functional
def test_with_confirmation(proc, TIMEOUT):
    with_confirmation(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'echo test')


@pytest.mark.functional
def test_select_command_with_arrows(proc, TIMEOUT):
    select_command_with_arrows(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'git help')


@pytest.mark.functional
def test_refuse_with_confirmation(proc, TIMEOUT):
    refuse_with_confirmation(proc, TIMEOUT)
    history_not_changed(proc, TIMEOUT)


@pytest.mark.functional
def test_without_confirmation(proc, TIMEOUT):
    without_confirmation(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'echo test')


@pytest.mark.functional
def test_how_to_configure_alias(proc, TIMEOUT):
    proc.sendline('unset -f fuck')
    how_to_configure(proc, TIMEOUT)
<EOF>
<BOF>
def _set_confirmation(proc, require):
    proc.sendline(u'mkdir -p ~/.thefuck')
    proc.sendline(
        u'echo "require_confirmation = {}" > ~/.thefuck/settings.py'.format(
            require))


def with_confirmation(proc, TIMEOUT):
    """Ensures that command can be fixed when confirmation enabled."""
    _set_confirmation(proc, True)

    proc.sendline(u'ehco test')

    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u'echo test'])
    assert proc.expect([TIMEOUT, u'enter'])
    assert proc.expect_exact([TIMEOUT, u'ctrl+c'])
    proc.send('\n')

    assert proc.expect([TIMEOUT, u'test'])


def history_changed(proc, TIMEOUT, to):
    """Ensures that history changed."""
    proc.send('\033[A')
    assert proc.expect([TIMEOUT, to])


def history_not_changed(proc, TIMEOUT):
    """Ensures that history not changed."""
    proc.send('\033[A')
    assert proc.expect([TIMEOUT, u'fuck'])


def select_command_with_arrows(proc, TIMEOUT):
    """Ensures that command can be selected with arrow keys."""
    _set_confirmation(proc, True)

    proc.sendline(u'git h')
    assert proc.expect([TIMEOUT, u"git: 'h' is not a git command."])

    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u'git show'])
    proc.send('\033[B')
    assert proc.expect([TIMEOUT, u'git push'])
    proc.send('\033[B')
    assert proc.expect([TIMEOUT, u'git help'])
    proc.send('\033[A')
    assert proc.expect([TIMEOUT, u'git push'])
    proc.send('\033[B')
    assert proc.expect([TIMEOUT, u'git help'])
    proc.send('\n')

    assert proc.expect([TIMEOUT, u'usage'])


def refuse_with_confirmation(proc, TIMEOUT):
    """Ensures that fix can be refused when confirmation enabled."""
    _set_confirmation(proc, True)

    proc.sendline(u'ehco test')

    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u'echo test'])
    assert proc.expect([TIMEOUT, u'enter'])
    assert proc.expect_exact([TIMEOUT, u'ctrl+c'])
    proc.send('\003')

    assert proc.expect([TIMEOUT, u'Aborted'])


def without_confirmation(proc, TIMEOUT):
    """Ensures that command can be fixed when confirmation disabled."""
    _set_confirmation(proc, False)

    proc.sendline(u'ehco test')

    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u'echo test'])
    assert proc.expect([TIMEOUT, u'test'])


def how_to_configure(proc, TIMEOUT):
    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u"alias isn't configured"])
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

from thefuck.rules.fix_alt_space import match, get_new_command
from thefuck.types import Command


def test_match():
    """The character before 'grep' is Alt+Space, which happens frequently
    on the Mac when typing the pipe character (Alt+7), and holding the Alt
    key pressed for longer than necessary.

    """
    assert match(Command(u'ps -ef | grep foo',
                         u'-bash:  grep: command not found'))
    assert not match(Command('ps -ef | grep foo', ''))
    assert not match(Command('', ''))


def test_get_new_command():
    """ Replace the Alt+Space character by a simple space """
    assert (get_new_command(Command(u'ps -ef | grep foo', ''))
            == 'ps -ef | grep foo')
<EOF>
<BOF>
import pytest
from thefuck.rules.yarn_help import match, get_new_command
from thefuck.types import Command
from thefuck.system import open_command


output_clean = '''

  Usage: yarn [command] [flags]

  Options:

    -h, --help                      output usage information
    -V, --version                   output the version number
    --verbose                       output verbose messages on internal operations
    --offline                       trigger an error if any required dependencies are not available in local cache
    --prefer-offline                use network only if dependencies are not available in local cache
    --strict-semver                 
    --json                          
    --ignore-scripts                don't run lifecycle scripts
    --har                           save HAR output of network traffic
    --ignore-platform               ignore platform checks
    --ignore-engines                ignore engines check
    --ignore-optional               ignore optional dependencies
    --force                         ignore all caches
    --no-bin-links                  don't generate bin links when setting up packages
    --flat                          only allow one version of a package
    --prod, --production [prod]     
    --no-lockfile                   don't read or generate a lockfile
    --pure-lockfile                 don't generate a lockfile
    --frozen-lockfile               don't generate a lockfile and fail if an update is needed
    --link-duplicates               create hardlinks to the repeated modules in node_modules
    --global-folder <path>          
    --modules-folder <path>         rather than installing modules into the node_modules folder relative to the cwd, output them here
    --cache-folder <path>           specify a custom folder to store the yarn cache
    --mutex <type>[:specifier]      use a mutex to ensure only one yarn instance is executing
    --no-emoji                      disable emoji in output
    --proxy <host>                  
    --https-proxy <host>            
    --no-progress                   disable progress bar
    --network-concurrency <number>  maximum number of concurrent network requests

  Visit https://yarnpkg.com/en/docs/cli/clean for documentation about this command.
'''  # noqa


@pytest.mark.parametrize('command', [
    Command('yarn help clean', output_clean)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, url', [
    (Command('yarn help clean', output_clean),
     'https://yarnpkg.com/en/docs/cli/clean')])
def test_get_new_command(command, url):
    assert get_new_command(command) == open_command(url)
<EOF>
<BOF>
import pytest
from thefuck.rules.git_commit_amend import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('script, output', [
    ('git commit -m "test"', 'test output'),
    ('git commit', '')])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', [
    'git branch foo',
    'git checkout feature/test_commit',
    'git push'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script', [
    ('git commit -m "test commit"'),
    ('git commit')])
def test_get_new_command(script):
    assert get_new_command(Command(script, '')) == 'git commit --amend'
<EOF>
<BOF>
import pytest
from thefuck.rules.brew_unknown_command import match, get_new_command
from thefuck.rules.brew_unknown_command import _brew_commands
from thefuck.types import Command


@pytest.fixture
def brew_unknown_cmd():
    return '''Error: Unknown command: inst'''


@pytest.fixture
def brew_unknown_cmd2():
    return '''Error: Unknown command: instaa'''


def test_match(brew_unknown_cmd):
    assert match(Command('brew inst', brew_unknown_cmd))
    for command in _brew_commands():
        assert not match(Command('brew ' + command, ''))


def test_get_new_command(brew_unknown_cmd, brew_unknown_cmd2):
    assert (get_new_command(Command('brew inst', brew_unknown_cmd))
            == ['brew list', 'brew install', 'brew uninstall'])

    cmds = get_new_command(Command('brew instaa', brew_unknown_cmd2))
    assert 'brew install' in cmds
    assert 'brew uninstall' in cmds
<EOF>
<BOF>
# -*- coding: utf-8 -*-
import pytest
from thefuck.rules.ln_no_hard_link import match, get_new_command
from thefuck.types import Command

error = "hard link not allowed for directory"


@pytest.mark.parametrize('script, output', [
    ("ln barDir barLink", "ln: ‘barDir’: {}"),
    ("sudo ln a b", "ln: ‘a’: {}"),
    ("sudo ln -nbi a b", "ln: ‘a’: {}")])
def test_match(script, output):
    command = Command(script, output.format(error))
    assert match(command)


@pytest.mark.parametrize('script, output', [
    ('', ''),
    ("ln a b", "... hard link"),
    ("sudo ln a b", "... hard link"),
    ("a b", error)])
def test_not_match(script, output):
    command = Command(script, output)
    assert not match(command)


@pytest.mark.parametrize('script, result', [
    ("ln barDir barLink", "ln -s barDir barLink"),
    ("sudo ln barDir barLink", "sudo ln -s barDir barLink"),
    ("sudo ln -nbi a b", "sudo ln -s -nbi a b"),
    ("ln -nbi a b && ls", "ln -s -nbi a b && ls"),
    ("ln a ln", "ln -s a ln"),
    ("sudo ln a ln", "sudo ln -s a ln")])
def test_get_new_command(script, result):
    command = Command(script, '')
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from thefuck.rules.java import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('java foo.java', ''),
    Command('java bar.java', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('java foo.java', ''), 'java foo'),
    (Command('java bar.java', ''), 'java bar')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_two_dashes import match, get_new_command
from thefuck.types import Command


output = 'error: did you mean `{}` (with two dashes ?)'.format


@pytest.mark.parametrize('command', [
    Command('git add -patch', output('--patch')),
    Command('git checkout -patch', output('--patch')),
    Command('git commit -amend', output('--amend')),
    Command('git push -tags', output('--tags')),
    Command('git rebase -continue', output('--continue'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git add --patch', ''),
    Command('git checkout --patch', ''),
    Command('git commit --amend', ''),
    Command('git push --tags', ''),
    Command('git rebase --continue', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, output', [
    (Command('git add -patch', output('--patch')),
        'git add --patch'),
    (Command('git checkout -patch', output('--patch')),
        'git checkout --patch'),
    (Command('git checkout -patch', output('--patch')),
        'git checkout --patch'),
    (Command('git init -bare', output('--bare')),
        'git init --bare'),
    (Command('git commit -amend', output('--amend')),
        'git commit --amend'),
    (Command('git push -tags', output('--tags')),
        'git push --tags'),
    (Command('git rebase -continue', output('--continue')),
        'git rebase --continue')])
def test_get_new_command(command, output):
    assert get_new_command(command) == output
<EOF>
<BOF>
import pytest
from thefuck.rules.lein_not_task import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def is_not_task():
    return ''''rpl' is not a task. See 'lein help'.

Did you mean this?
         repl
         jar
'''


def test_match(is_not_task):
    assert match(Command('lein rpl', is_not_task))
    assert not match(Command('ls', is_not_task))


def test_get_new_command(is_not_task):
    assert (get_new_command(Command('lein rpl --help', is_not_task))
            == ['lein repl --help', 'lein jar --help'])
<EOF>
<BOF>
import pytest
from thefuck.rules.dry import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('cd cd foo', ''),
    Command('git git push origin/master', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('cd cd foo', ''), 'cd foo'),
    (Command('git git push origin/master', ''), 'git push origin/master')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.cd_correction import match
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('cd foo', 'cd: foo: No such file or directory'),
    Command('cd foo/bar/baz',
            'cd: foo: No such file or directory'),
    Command('cd foo/bar/baz', 'cd: can\'t cd to foo/bar/baz'),
    Command('cd /foo/bar/', 'cd: The directory "/foo/bar/" does not exist')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('cd foo', ''), Command('', '')])
def test_not_match(command):
    assert not match(command)


# Note that get_new_command uses local filesystem, so not testing it here.
# Instead, see the functional test `functional.test_cd_correction`
<EOF>
<BOF>
import pytest
from thefuck.rules.django_south_ghost import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''Traceback (most recent call last):
  File "/home/nvbn/work/.../bin/python", line 42, in <module>
    exec(compile(__file__f.read(), __file__, "exec"))
  File "/home/nvbn/work/.../app/manage.py", line 34, in <module>
    execute_from_command_line(sys.argv)
  File "/home/nvbn/work/.../lib/django/core/management/__init__.py", line 443, in execute_from_command_line
    utility.execute()
  File "/home/nvbn/work/.../lib/django/core/management/__init__.py", line 382, in execute
    self.fetch_command(subcommand).run_from_argv(self.argv)
  File "/home/nvbn/work/.../lib/django/core/management/base.py", line 196, in run_from_argv
    self.execute(*args, **options.__dict__)
  File "/home/nvbn/work/.../lib/django/core/management/base.py", line 232, in execute
    output = self.handle(*args, **options)
  File "/home/nvbn/work/.../app/lib/south/management/commands/migrate.py", line 108, in handle
    ignore_ghosts = ignore_ghosts,
  File "/home/nvbn/work/.../app/lib/south/migration/__init__.py", line 193, in migrate_app
    applied_all = check_migration_histories(applied_all, delete_ghosts, ignore_ghosts)
  File "/home/nvbn/work/.../app/lib/south/migration/__init__.py", line 88, in check_migration_histories
    raise exceptions.GhostMigrations(ghosts)
south.exceptions.GhostMigrations: 

 ! These migrations are in the database but not on disk:
    <app1: 0033_auto__...>
    <app1: 0034_fill_...>
    <app1: 0035_rename_...>
    <app2: 0003_add_...>
    <app2: 0004_denormalize_...>
    <app1: 0033_auto....>
    <app1: 0034_fill...>
 ! I'm not trusting myself; either fix this yourself by fiddling
 ! with the south_migrationhistory table, or pass --delete-ghost-migrations
 ! to South to have it delete ALL of these records (this may not be good).
'''  # noqa


def test_match(output):
    assert match(Command('./manage.py migrate', output))
    assert match(Command('python manage.py migrate', output))
    assert not match(Command('./manage.py migrate', ''))
    assert not match(Command('app migrate', output))
    assert not match(Command('./manage.py test', output))


def test_get_new_command():
    assert get_new_command(Command('./manage.py migrate auth', ''))\
        == './manage.py migrate auth --delete-ghost-migrations'
<EOF>
<BOF>

from thefuck.rules.sl_ls import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('sl', ''))
    assert not match(Command('ls', ''))


def test_get_new_command():
    assert get_new_command(Command('sl', '')) == 'ls'
<EOF>
<BOF>
import pytest
from thefuck.rules.git_rebase_merge_dir import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return ('\n\nIt seems that there is already a rebase-merge directory, and\n'
            'I wonder if you are in the middle of another rebase.  If that is the\n'
            'case, please try\n'
            '\tgit rebase (--continue | --abort | --skip)\n'
            'If that is not the case, please\n'
            '\trm -fr "/foo/bar/baz/egg/.git/rebase-merge"\n'
            'and run me again.  I am stopping in case you still have something\n'
            'valuable there.\n')


@pytest.mark.parametrize('script', [
    'git rebase master',
    'git rebase -skip',
    'git rebase'])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['git rebase master', 'git rebase -abort'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, result', [
    ('git rebase master', [
        'git rebase --abort', 'git rebase --skip', 'git rebase --continue',
        'rm -fr "/foo/bar/baz/egg/.git/rebase-merge"']),
    ('git rebase -skip', [
        'git rebase --skip', 'git rebase --abort', 'git rebase --continue',
        'rm -fr "/foo/bar/baz/egg/.git/rebase-merge"']),
    ('git rebase', [
        'git rebase --skip', 'git rebase --abort', 'git rebase --continue',
        'rm -fr "/foo/bar/baz/egg/.git/rebase-merge"'])])
def test_get_new_command(output, script, result):
    assert get_new_command(Command(script, output)) == result
<EOF>
<BOF>
import pytest
from thefuck.rules.no_such_file import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('mv foo bar/foo', "mv: cannot move 'foo' to 'bar/foo': No such file or directory"),
    Command('mv foo bar/', "mv: cannot move 'foo' to 'bar/': No such file or directory"),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('mv foo bar/', ""),
    Command('mv foo bar/foo', "mv: permission denied"),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('mv foo bar/foo', "mv: cannot move 'foo' to 'bar/foo': No such file or directory"), 'mkdir -p bar && mv foo bar/foo'),
    (Command('mv foo bar/', "mv: cannot move 'foo' to 'bar/': No such file or directory"), 'mkdir -p bar && mv foo bar/'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
# -*- coding: utf-8 -*-

from thefuck.rules.grep_recursive import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('grep blah .', 'grep: .: Is a directory'))
    assert match(Command(u'grep café .', 'grep: .: Is a directory'))
    assert not match(Command('', ''))


def test_get_new_command():
    assert get_new_command(Command('grep blah .', '')) == 'grep -r blah .'
    assert get_new_command(Command(u'grep café .', '')) == u'grep -r café .'
<EOF>
<BOF>
import pytest
from thefuck.rules.remove_trailing_cedilla import match, get_new_command, CEDILLA
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('wrong' + CEDILLA, ''),
    Command('wrong with args' + CEDILLA, '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('wrong' + CEDILLA, ''), 'wrong'),
    (Command('wrong with args' + CEDILLA, ''), 'wrong with args')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_push_force import match, get_new_command
from thefuck.types import Command


git_err = '''
To /tmp/foo
 ! [rejected]        master -> master (non-fast-forward)
 error: failed to push some refs to '/tmp/bar'
 hint: Updates were rejected because the tip of your current branch is behind
 hint: its remote counterpart. Integrate the remote changes (e.g.
 hint: 'git pull ...') before pushing again.
 hint: See the 'Note about fast-forwards' in 'git push --help' for details.
'''

git_uptodate = 'Everything up-to-date'
git_ok = '''
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To /tmp/bar
   514eed3..f269c79  master -> master
'''


@pytest.mark.parametrize('command', [
    Command('git push', git_err),
    Command('git push nvbn', git_err),
    Command('git push nvbn master', git_err)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git push', git_ok),
    Command('git push', git_uptodate),
    Command('git push nvbn', git_ok),
    Command('git push nvbn master', git_uptodate),
    Command('git push nvbn', git_ok),
    Command('git push nvbn master', git_uptodate)])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, output', [
    (Command('git push', git_err), 'git push --force-with-lease'),
    (Command('git push nvbn', git_err), 'git push --force-with-lease nvbn'),
    (Command('git push nvbn master', git_err), 'git push --force-with-lease nvbn master')])
def test_get_new_command(command, output):
    assert get_new_command(command) == output
<EOF>
<BOF>
import pytest
from thefuck.rules.git_fix_stash import match, get_new_command
from thefuck.types import Command


git_stash_err = '''
usage: git stash list [<options>]
   or: git stash show [<stash>]
   or: git stash drop [-q|--quiet] [<stash>]
   or: git stash ( pop | apply ) [--index] [-q|--quiet] [<stash>]
   or: git stash branch <branchname> [<stash>]
   or: git stash [save [--patch] [-k|--[no-]keep-index] [-q|--quiet]
\t\t       [-u|--include-untracked] [-a|--all] [<message>]]
   or: git stash clear
'''


@pytest.mark.parametrize('wrong', [
    'git stash opp',
    'git stash Some message',
    'git stash saev Some message'])
def test_match(wrong):
    assert match(Command(wrong, git_stash_err))


def test_not_match():
    assert not match(Command("git", git_stash_err))


@pytest.mark.parametrize('wrong,fixed', [
    ('git stash opp', 'git stash pop'),
    ('git stash Some message', 'git stash save Some message'),
    ('git stash saev Some message', 'git stash save Some message')])
def test_get_new_command(wrong, fixed):
    assert get_new_command(Command(wrong, git_stash_err)) == fixed
<EOF>
<BOF>
import pytest
from thefuck.rules.git_stash_pop import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''error: Your local changes to the following files would be overwritten by merge:'''


def test_match(output):
    assert match(Command('git stash pop', output))
    assert not match(Command('git stash', ''))


def test_get_new_command(output):
    assert (get_new_command(Command('git stash pop', output))
            == "git add --update && git stash pop && git reset .")
<EOF>
<BOF>
import pytest
from thefuck.rules.history import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def history_without_current(mocker):
    return mocker.patch(
        'thefuck.rules.history.get_valid_history_without_current',
        return_value=['ls cat', 'diff x'])


@pytest.mark.parametrize('script', ['ls cet', 'daff x'])
def test_match(script):
    assert match(Command(script, ''))


@pytest.mark.parametrize('script', ['apt-get', 'nocommand y'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, result', [
    ('ls cet', 'ls cat'),
    ('daff x', 'diff x')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, '')) == result
<EOF>
<BOF>
import pytest
from io import BytesIO
from thefuck.types import Command
from thefuck.rules.npm_missing_script import match, get_new_command

output = '''
npm ERR! Linux 4.4.0-31-generic
npm ERR! argv "/opt/node/bin/node" "/opt/node/bin/npm" "run" "dvelop"
npm ERR! node v4.4.7
npm ERR! npm  v2.15.8

npm ERR! missing script: {}
npm ERR!
npm ERR! If you need help, you may report this error at:
npm ERR!     <https://github.com/npm/npm/issues>

npm ERR! Please include the following file with any support request:
npm ERR!     /home/nvbn/exp/code_view/client_web/npm-debug.log
'''.format

run_script_stdout = b'''
Lifecycle scripts included in code-view-web:
  test
    jest

available via `npm run-script`:
  build
    cp node_modules/ace-builds/src-min/ -a resources/ace/ && webpack --progress --colors -p --config ./webpack.production.config.js
  develop
    cp node_modules/ace-builds/src/ -a resources/ace/ && webpack-dev-server --progress --colors
  watch-test
    jest --verbose --watch

'''


@pytest.fixture(autouse=True)
def run_script(mocker):
    patch = mocker.patch('thefuck.specific.npm.Popen')
    patch.return_value.stdout = BytesIO(run_script_stdout)
    return patch.return_value


@pytest.mark.parametrize('command', [
    Command('npm ru wach', output('wach')),
    Command('npm run live-tes', output('live-tes')),
    Command('npm run-script sahare', output('sahare'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('npm wach', output('wach')),
    Command('vim live-tes', output('live-tes')),
    Command('npm run-script sahare', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('script, output, result', [
    ('npm ru wach-tests', output('wach-tests'), 'npm ru watch-test'),
    ('npm -i run-script dvelop', output('dvelop'),
     'npm -i run-script develop'),
    ('npm -i run-script buld -X POST', output('buld'),
     'npm -i run-script build -X POST')])
def test_get_new_command(script, output, result):
    command = Command(script, output)

    assert get_new_command(command)[0] == result
<EOF>
<BOF>
import pytest
from thefuck.rules.git_tag_force import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''fatal: tag 'alert' already exists'''


def test_match(output):
    assert match(Command('git tag alert', output))
    assert not match(Command('git tag alert', ''))


def test_get_new_command(output):
    assert (get_new_command(Command('git tag alert', output))
            == "git tag --force alert")
<EOF>
<BOF>
import pytest
from thefuck.rules.git_branch_exists import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(src_branch_name):
    return "fatal: A branch named '{}' already exists.".format(src_branch_name)


@pytest.fixture
def new_command(branch_name):
    return [cmd.format(branch_name) for cmd in [
        'git branch -d {0} && git branch {0}',
        'git branch -d {0} && git checkout -b {0}',
        'git branch -D {0} && git branch {0}',
        'git branch -D {0} && git checkout -b {0}', 'git checkout {0}']]


@pytest.mark.parametrize('script, src_branch_name, branch_name', [
    ('git branch foo', 'foo', 'foo'),
    ('git checkout bar', 'bar', 'bar'),
    ('git checkout -b "let\'s-push-this"', '"let\'s-push-this"', '"let\'s-push-this"')])
def test_match(output, script, branch_name):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', [
    'git branch foo',
    'git checkout bar',
    'git checkout -b "let\'s-push-this"'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, src_branch_name, branch_name', [
    ('git branch foo', 'foo', 'foo'),
    ('git checkout bar', 'bar', 'bar'),
    ('git checkout -b "let\'s-push-this"', "let's-push-this", "let\\'s-push-this")])
def test_get_new_command(output, new_command, script, src_branch_name, branch_name):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.cd_mkdir import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('cd foo', 'cd: foo: No such file or directory'),
    Command('cd foo/bar/baz',
            'cd: foo: No such file or directory'),
    Command('cd foo/bar/baz', 'cd: can\'t cd to foo/bar/baz'),
    Command('cd /foo/bar/', 'cd: The directory "/foo/bar/" does not exist')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('cd foo', ''), Command('', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('cd foo', ''), 'mkdir -p foo && cd foo'),
    (Command('cd foo/bar/baz', ''), 'mkdir -p foo/bar/baz && cd foo/bar/baz')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from io import BytesIO
from thefuck.rules.npm_run_script import match, get_new_command
from thefuck.types import Command

output = '''
Usage: npm <command>

where <command> is one of:
    access, add-user, adduser, apihelp, author, bin, bugs, c,
    cache, completion, config, ddp, dedupe, deprecate, dist-tag,
    dist-tags, docs, edit, explore, faq, find, find-dupes, get,
    help, help-search, home, i, info, init, install, issues, la,
    link, list, ll, ln, login, logout, ls, outdated, owner,
    pack, ping, prefix, prune, publish, r, rb, rebuild, remove,
    repo, restart, rm, root, run-script, s, se, search, set,
    show, shrinkwrap, star, stars, start, stop, t, tag, team,
    test, tst, un, uninstall, unlink, unpublish, unstar, up,
    update, upgrade, v, version, view, whoami

npm <cmd> -h     quick help on <cmd>
npm -l           display full usage info
npm faq          commonly asked questions
npm help <term>  search for help on <term>
npm help npm     involved overview

Specify configs in the ini-formatted file:
    /home/nvbn/.npmrc
or on the command line via: npm <command> --key value
Config info can be viewed via: npm help config

'''

run_script_stdout = b'''
Lifecycle scripts included in code-view-web:
  test
    jest

available via `npm run-script`:
  build
    cp node_modules/ace-builds/src-min/ -a resources/ace/ && webpack --progress --colors -p --config ./webpack.production.config.js
  develop
    cp node_modules/ace-builds/src/ -a resources/ace/ && webpack-dev-server --progress --colors
  watch-test
    jest --verbose --watch

'''


@pytest.fixture(autouse=True)
def run_script(mocker):
    patch = mocker.patch('thefuck.specific.npm.Popen')
    patch.return_value.stdout = BytesIO(run_script_stdout)
    return patch.return_value


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script', [
    'npm watch-test', 'npm develop'])
def test_match(script):
    command = Command(script, output)
    assert match(command)


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('command, run_script_out', [
    (Command('npm test', 'TEST FAIL'), run_script_stdout),
    (Command('npm watch-test', 'TEST FAIL'), run_script_stdout),
    (Command('npm test', output), run_script_stdout),
    (Command('vim watch-test', output), run_script_stdout)])
def test_not_match(run_script, command, run_script_out):
    run_script.stdout = BytesIO(run_script_out)
    assert not match(command)


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, result', [
    ('npm watch-test', 'npm run-script watch-test'),
    ('npm -i develop', 'npm run-script -i develop'),
    ('npm -i watch-script --path ..',
     'npm run-script -i watch-script --path ..')])
def test_get_new_command(script, result):
    command = Command(script, output)
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from thefuck.rules.rm_root import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('rm -rf /', 'add --no-preserve-root'))


@pytest.mark.parametrize('command', [
    Command('ls', 'add --no-preserve-root'),
    Command('rm --no-preserve-root /', 'add --no-preserve-root'),
    Command('rm -rf /', '')])
def test_not_match(command):
    assert not match(command)


def test_get_new_command():
    assert (get_new_command(Command('rm -rf /', ''))
            == 'rm -rf / --no-preserve-root')
<EOF>
<BOF>
import pytest
from thefuck.rules.git_pull_uncommitted_changes import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''error: Cannot pull with rebase: Your index contains uncommitted changes.'''


def test_match(output):
    assert match(Command('git pull', output))
    assert not match(Command('git pull', ''))
    assert not match(Command('ls', output))


def test_get_new_command(output):
    assert (get_new_command(Command('git pull', output))
            == "git stash && git pull && git stash pop")
<EOF>
<BOF>
import pytest
from thefuck.types import Command
from thefuck.rules.yarn_command_replaced import match, get_new_command


output = ('error `install` has been replaced with `add` to add new '
          'dependencies. Run "yarn add {}" instead.').format


@pytest.mark.parametrize('command', [
    Command('yarn install redux', output('redux')),
    Command('yarn install moment', output('moment')),
    Command('yarn install lodash', output('lodash'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('yarn install', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('yarn install redux', output('redux')),
     'yarn add redux'),
    (Command('yarn install moment', output('moment')),
     'yarn add moment'),
    (Command('yarn install lodash', output('lodash')),
     'yarn add lodash')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.php_s import get_new_command, match
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('php -s localhost:8000', ''),
    Command('php -t pub -s 0.0.0.0:8080', '')
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('php -S localhost:8000', ''),
    Command('vim php -s', '')
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('php -s localhost:8000', ''), 'php -S localhost:8000'),
    (Command('php -t pub -s 0.0.0.0:8080', ''), 'php -t pub -S 0.0.0.0:8080')
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest

from thefuck.rules.az_cli import match, get_new_command
from thefuck.types import Command


no_suggestions = '''\
az provider: error: the following arguments are required: _subcommand
usage: az provider [-h] {list,show,register,unregister,operation} ...
'''


misspelled_command = '''\
az: 'providers' is not in the 'az' command group. See 'az --help'.

The most similar choice to 'providers' is:
    provider
'''

misspelled_subcommand = '''\
az provider: 'lis' is not in the 'az provider' command group. See 'az provider --help'.

The most similar choice to 'lis' is:
    list
'''


@pytest.mark.parametrize('command', [
    Command('az providers', misspelled_command),
    Command('az provider lis', misspelled_subcommand)])
def test_match(command):
    assert match(command)


def test_not_match():
    assert not match(Command('az provider', no_suggestions))


@pytest.mark.parametrize('command, result', [
    (Command('az providers list', misspelled_command), ['az provider list']),
    (Command('az provider lis', misspelled_subcommand), ['az provider list'])
])
def test_get_new_command(command, result):
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from thefuck.rules.quotation_marks import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command("git commit -m \'My Message\"", ''),
    Command("git commit -am \"Mismatched Quotation Marks\'", ''),
    Command("echo \"hello\'", '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command("git commit -m \'My Message\"", ''), "git commit -m \"My Message\""),
    (Command("git commit -am \"Mismatched Quotation Marks\'", ''), "git commit -am \"Mismatched Quotation Marks\""),
    (Command("echo \"hello\'", ''), "echo \"hello\"")])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import pytest
import os
from thefuck.rules.fix_file import match, get_new_command
from thefuck.types import Command


# (script, file, line, col (or None), output)
tests = (
('gcc a.c', 'a.c', 3, 1,
"""
a.c: In function 'main':
a.c:3:1: error: expected expression before '}' token
 }
  ^
"""),

('clang a.c', 'a.c', 3, 1,
"""
a.c:3:1: error: expected expression
}
^
"""),

('perl a.pl', 'a.pl', 3, None,
"""
syntax error at a.pl line 3, at EOF
Execution of a.pl aborted due to compilation errors.
"""),

('perl a.pl', 'a.pl', 2, None,
"""
Search pattern not terminated at a.pl line 2.
"""),

('sh a.sh', 'a.sh', 2, None,
"""
a.sh: line 2: foo: command not found
"""),

('zsh a.sh', 'a.sh', 2, None,
"""
a.sh:2: command not found: foo
"""),

('bash a.sh', 'a.sh', 2, None,
"""
a.sh: line 2: foo: command not found
"""),

('rustc a.rs', 'a.rs', 2, 5,
"""
a.rs:2:5: 2:6 error: unexpected token: `+`
a.rs:2     +
           ^
"""),

('cargo build', 'src/lib.rs', 3, 5,
"""
   Compiling test v0.1.0 (file:///tmp/fix-error/test)
   src/lib.rs:3:5: 3:6 error: unexpected token: `+`
   src/lib.rs:3     +
                    ^
Could not compile `test`.

To learn more, run the command again with --verbose.
"""),

('python a.py', 'a.py', 2, None,
"""
  File "a.py", line 2
      +
          ^
SyntaxError: invalid syntax
"""),

('python a.py', 'a.py', 8, None,
"""
Traceback (most recent call last):
  File "a.py", line 8, in <module>
    match("foo")
  File "a.py", line 5, in match
    m = re.search(None, command)
  File "/usr/lib/python3.4/re.py", line 170, in search
    return _compile(pattern, flags).search(string)
  File "/usr/lib/python3.4/re.py", line 293, in _compile
    raise TypeError("first argument must be string or compiled pattern")
TypeError: first argument must be string or compiled pattern
"""),

(u'python café.py', u'café.py', 8, None,
u"""
Traceback (most recent call last):
  File "café.py", line 8, in <module>
    match("foo")
  File "café.py", line 5, in match
    m = re.search(None, command)
  File "/usr/lib/python3.4/re.py", line 170, in search
    return _compile(pattern, flags).search(string)
  File "/usr/lib/python3.4/re.py", line 293, in _compile
    raise TypeError("first argument must be string or compiled pattern")
TypeError: first argument must be string or compiled pattern
"""),

('ruby a.rb', 'a.rb', 3, None,
"""
a.rb:3: syntax error, unexpected keyword_end
"""),

('lua a.lua', 'a.lua', 2, None,
"""
lua: a.lua:2: unexpected symbol near '+'
"""),

('fish a.sh', '/tmp/fix-error/a.sh', 2, None,
"""
fish: Unknown command 'foo'
/tmp/fix-error/a.sh (line 2): foo
                              ^
"""),

('./a', './a', 2, None,
"""
awk: ./a:2: BEGIN { print "Hello, world!" + }
awk: ./a:2:                                 ^ syntax error
"""),

('llc a.ll', 'a.ll', 1, 2,
"""
llc: a.ll:1:2: error: expected top-level entity
+
^
"""),

('go build a.go', 'a.go', 1, 2,
"""
can't load package:
a.go:1:2: expected 'package', found '+'
"""),

('make', 'Makefile', 2, None,
"""
bidule
make: bidule: Command not found
Makefile:2: recipe for target 'target' failed
make: *** [target] Error 127
"""),

('git st', '/home/martin/.config/git/config', 1, None,
"""
fatal: bad config file line 1 in /home/martin/.config/git/config
"""),

('node fuck.js asdf qwer', '/Users/pablo/Workspace/barebones/fuck.js', '2', 5,
"""
/Users/pablo/Workspace/barebones/fuck.js:2
conole.log(arg);  // this should read console.log(arg);
^
ReferenceError: conole is not defined
    at /Users/pablo/Workspace/barebones/fuck.js:2:5
    at Array.forEach (native)
    at Object.<anonymous> (/Users/pablo/Workspace/barebones/fuck.js:1:85)
    at Module._compile (module.js:460:26)
    at Object.Module._extensions..js (module.js:478:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:501:10)
    at startup (node.js:129:16)
    at node.js:814:3
"""),

('pep8', './tests/rules/test_systemctl.py', 17, 80,
"""
./tests/rules/test_systemctl.py:17:80: E501 line too long (93 > 79 characters)
./tests/rules/test_systemctl.py:18:80: E501 line too long (103 > 79 characters)
./tests/rules/test_whois.py:20:80: E501 line too long (89 > 79 characters)
./tests/rules/test_whois.py:22:80: E501 line too long (83 > 79 characters)
"""),

('py.test', '/home/thefuck/tests/rules/test_fix_file.py', 218, None,
"""
monkeypatch = <_pytest.monkeypatch.monkeypatch object at 0x7fdb76a25b38>
test = ('fish a.sh', '/tmp/fix-error/a.sh', 2, None, '', "\\nfish: Unknown command 'foo'\\n/tmp/fix-error/a.sh (line 2): foo\\n                              ^\\n")

    @pytest.mark.parametrize('test', tests)
    @pytest.mark.usefixtures('no_memoize')
    def test_get_new_command(monkeypatch, test):
>       mocker.patch('os.path.isfile', return_value=True)
E       NameError: name 'mocker' is not defined

/home/thefuck/tests/rules/test_fix_file.py:218: NameError
"""),
)  # noqa


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_match(mocker, monkeypatch, test):
    mocker.patch('os.path.isfile', return_value=True)
    monkeypatch.setenv('EDITOR', 'dummy_editor')
    assert match(Command('', test[4]))


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_no_editor(mocker, monkeypatch, test):
    mocker.patch('os.path.isfile', return_value=True)
    if 'EDITOR' in os.environ:
        monkeypatch.delenv('EDITOR')

    assert not match(Command('', test[4]))


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_not_file(mocker, monkeypatch, test):
    mocker.patch('os.path.isfile', return_value=False)
    monkeypatch.setenv('EDITOR', 'dummy_editor')

    assert not match(Command('', test[4]))


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_get_new_command(mocker, monkeypatch, test):
    mocker.patch('os.path.isfile', return_value=True)
    monkeypatch.setenv('EDITOR', 'dummy_editor')


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_get_new_command_with_settings(mocker, monkeypatch, test, settings):
    mocker.patch('os.path.isfile', return_value=True)
    monkeypatch.setenv('EDITOR', 'dummy_editor')

    cmd = Command(test[0], test[4])
    settings.fixcolcmd = '{editor} {file} +{line}:{col}'

    if test[3]:
        assert (get_new_command(cmd) ==
                u'dummy_editor {} +{}:{} && {}'.format(test[1], test[2], test[3], test[0]))
    else:
        assert (get_new_command(cmd) ==
                u'dummy_editor {} +{} && {}'.format(test[1], test[2], test[0]))
<EOF>
<BOF>
import pytest
from thefuck.rules.git_remote_seturl_add import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('git remote set-url origin url', "fatal: No such remote")])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git remote set-url origin url', ""),
    Command('git remote add origin url', ''),
    Command('git remote remove origin', ''),
    Command('git remote prune origin', ''),
    Command('git remote set-branches origin branch', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git remote set-url origin git@github.com:nvbn/thefuck.git', ''),
     'git remote add origin git@github.com:nvbn/thefuck.git')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.go_run import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('go run foo', ''),
    Command('go run bar', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('go run foo', ''), 'go run foo.go'),
    (Command('go run bar', ''), 'go run bar.go')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.brew_cask_dependency import match, get_new_command
from thefuck.types import Command


output = '''sshfs: OsxfuseRequirement unsatisfied!

You can install with Homebrew-Cask:
  brew cask install osxfuse

You can download from:
  https://osxfuse.github.io/
Error: An unsatisfied requirement failed this build.'''


def test_match():
    command = Command('brew install sshfs', output)
    assert match(command)


@pytest.mark.parametrize('script, output', [
    ('brew link sshfs', output),
    ('cat output', output),
    ('brew install sshfs', '')])
def test_not_match(script, output):
    command = Command(script, output)
    assert not match(command)


@pytest.mark.parametrize('before, after', [
    ('brew install sshfs',
     'brew cask install osxfuse && brew install sshfs')])
def test_get_new_command(before, after):
    command = Command(before, output)
    assert get_new_command(command) == after
<EOF>
<BOF>
from thefuck.rules.systemctl import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('systemctl nginx start', 'Unknown operation \'nginx\'.'))
    assert match(Command('sudo systemctl nginx start', 'Unknown operation \'nginx\'.'))
    assert not match(Command('systemctl start nginx', ''))
    assert not match(Command('systemctl start nginx', ''))
    assert not match(Command('sudo systemctl nginx', 'Unknown operation \'nginx\'.'))
    assert not match(Command('systemctl nginx', 'Unknown operation \'nginx\'.'))
    assert not match(Command('systemctl start wtf', 'Failed to start wtf.service: Unit wtf.service failed to load: No such file or directory.'))


def test_get_new_command():
    assert get_new_command(Command('systemctl nginx start', '')) == "systemctl start nginx"
    assert get_new_command(Command('sudo systemctl nginx start', '')) == "sudo systemctl start nginx"
<EOF>
<BOF>
import pytest
from io import BytesIO
from thefuck.types import Command
from thefuck.rules.gulp_not_task import match, get_new_command


def output(task):
    return '''[00:41:11] Using gulpfile gulpfile.js
[00:41:11] Task '{}' is not in your gulpfile
[00:41:11] Please check the documentation for proper gulpfile formatting
'''.format(task)


def test_match():
    assert match(Command('gulp srve', output('srve')))


@pytest.mark.parametrize('script, stdout', [
    ('gulp serve', ''),
    ('cat srve', output('srve'))])
def test_not_march(script, stdout):
    assert not match(Command(script, stdout))


def test_get_new_command(mocker):
    mock = mocker.patch('subprocess.Popen')
    mock.return_value.stdout = BytesIO(b'serve \nbuild \ndefault \n')
    command = Command('gulp srve', output('srve'))
    assert get_new_command(command) == ['gulp serve', 'gulp default']
<EOF>
<BOF>
import pytest
from thefuck.rules.no_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def get_all_executables(mocker):
    mocker.patch('thefuck.rules.no_command.get_all_executables',
                 return_value=['vim', 'fsck', 'git', 'go'])


@pytest.fixture(autouse=True)
def history_without_current(mocker):
    return mocker.patch(
        'thefuck.rules.no_command.get_valid_history_without_current',
        return_value=['git commit'])


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, output', [
    ('vom file.py', 'vom: not found'),
    ('fucck', 'fucck: not found'),
    ('got commit', 'got: command not found')])
def test_match(mocker, script, output):
    mocker.patch('thefuck.rules.no_command.which', return_value=None)

    assert match(Command(script, output))


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, output, which', [
    ('qweqwe', 'qweqwe: not found', None),
    ('vom file.py', 'some text', None),
    ('vim file.py', 'vim: not found', 'vim')])
def test_not_match(mocker, script, output, which):
    mocker.patch('thefuck.rules.no_command.which', return_value=which)

    assert not match(Command(script, output))


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, result', [
    ('vom file.py', ['vim file.py']),
    ('fucck', ['fsck']),
    ('got commit', ['git commit', 'go commit'])])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, '')) == result
<EOF>
<BOF>
import pytest
from thefuck.types import Command
from thefuck.rules.chmod_x import match, get_new_command


@pytest.fixture
def file_exists(mocker):
    return mocker.patch('os.path.exists', return_value=True)


@pytest.fixture
def file_access(mocker):
    return mocker.patch('os.access', return_value=False)


@pytest.mark.usefixtures('file_exists', 'file_access')
@pytest.mark.parametrize('script, output', [
    ('./gradlew build', 'gradlew: Permission denied'),
    ('./install.sh --help', 'install.sh: permission denied')])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output, exists, callable', [
    ('./gradlew build', 'gradlew: Permission denied', True, True),
    ('./gradlew build', 'gradlew: Permission denied', False, False),
    ('./gradlew build', 'gradlew: error', True, False),
    ('gradlew build', 'gradlew: Permission denied', True, False)])
def test_not_match(file_exists, file_access, script, output, exists, callable):
    file_exists.return_value = exists
    file_access.return_value = callable
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, result', [
    ('./gradlew build', 'chmod +x gradlew && ./gradlew build'),
    ('./install.sh --help', 'chmod +x install.sh && ./install.sh --help')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, '')) == result
<EOF>
<BOF>
import pytest
from thefuck.rules.open import is_arg_url, match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(script):
    return 'The file {} does not exist.\n'.format(script.split(' ', 1)[1])


@pytest.mark.parametrize('script', [
    'open foo.com',
    'open foo.edu',
    'open foo.info',
    'open foo.io',
    'open foo.ly',
    'open foo.me',
    'open foo.net',
    'open foo.org',
    'open foo.se',
    'open www.foo.ru'])
def test_is_arg_url(script):
    assert is_arg_url(Command(script, ''))


@pytest.mark.parametrize('script', ['open foo', 'open bar.txt', 'open egg.doc'])
def test_not_is_arg_url(script):
    assert not is_arg_url(Command(script, ''))


@pytest.mark.parametrize('script', [
    'open foo.com',
    'xdg-open foo.com',
    'gnome-open foo.com',
    'kde-open foo.com',
    'open nonest'])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, new_command', [
    ('open foo.io', ['open http://foo.io']),
    ('xdg-open foo.io', ['xdg-open http://foo.io']),
    ('gnome-open foo.io', ['gnome-open http://foo.io']),
    ('kde-open foo.io', ['kde-open http://foo.io']),
    ('open nonest', ['touch nonest && open nonest',
                     'mkdir nonest && open nonest'])])
def test_get_new_command(script, new_command, output):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_push_pull import match, get_new_command
from thefuck.types import Command


git_err = '''
To /tmp/foo
 ! [rejected]        master -> master (non-fast-forward)
 error: failed to push some refs to '/tmp/bar'
 hint: Updates were rejected because the tip of your current branch is behind
 hint: its remote counterpart. Integrate the remote changes (e.g.
 hint: 'git pull ...') before pushing again.
 hint: See the 'Note about fast-forwards' in 'git push --help' for details.
'''

git_err2 = '''
To /tmp/foo
 ! [rejected]        master -> master (non-fast-forward)
 error: failed to push some refs to '/tmp/bar'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
'''

git_uptodate = 'Everything up-to-date'
git_ok = '''
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To /tmp/bar
   514eed3..f269c79  master -> master
'''


@pytest.mark.parametrize('command', [
    Command('git push', git_err),
    Command('git push nvbn', git_err),
    Command('git push nvbn master', git_err),
    Command('git push', git_err2),
    Command('git push nvbn', git_err2),
    Command('git push nvbn master', git_err2)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git push', git_ok),
    Command('git push', git_uptodate),
    Command('git push nvbn', git_ok),
    Command('git push nvbn master', git_uptodate),
    Command('git push nvbn', git_ok),
    Command('git push nvbn master', git_uptodate)])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, output', [
    (Command('git push', git_err), 'git pull && git push'),
    (Command('git push nvbn', git_err),
     'git pull nvbn && git push nvbn'),
    (Command('git push nvbn master', git_err),
     'git pull nvbn master && git push nvbn master'),
    (Command('git push', git_err2), 'git pull && git push'),
    (Command('git push nvbn', git_err2),
     'git pull nvbn && git push nvbn'),
    (Command('git push nvbn master', git_err2),
     'git pull nvbn master && git push nvbn master')])
def test_get_new_command(command, output):
    assert get_new_command(command) == output
<EOF>
<BOF>
from thefuck.rules.cd_parent import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('cd..', 'cd..: command not found'))
    assert not match(Command('', ''))


def test_get_new_command():
    assert get_new_command(Command('cd..', '')) == 'cd ..'
<EOF>
<BOF>
import pytest
from thefuck.rules.scm_correction import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def get_actual_scm_mock(mocker):
    return mocker.patch('thefuck.rules.scm_correction._get_actual_scm',
                        return_value=None)


@pytest.mark.parametrize('script, output, actual_scm', [
    ('git log', 'fatal: Not a git repository '
                '(or any of the parent directories): .git',
     'hg'),
    ('hg log', "abort: no repository found in '/home/nvbn/exp/thefuck' "
               "(.hg not found)!",
     'git')])
def test_match(get_actual_scm_mock, script, output, actual_scm):
    get_actual_scm_mock.return_value = actual_scm
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output, actual_scm', [
    ('git log', '', 'hg'),
    ('git log', 'fatal: Not a git repository '
                '(or any of the parent directories): .git',
     None),
    ('hg log', "abort: no repository found in '/home/nvbn/exp/thefuck' "
               "(.hg not found)!",
     None),
    ('not-scm log', "abort: no repository found in '/home/nvbn/exp/thefuck' "
                    "(.hg not found)!",
     'git')])
def test_not_match(get_actual_scm_mock, script, output, actual_scm):
    get_actual_scm_mock.return_value = actual_scm
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, actual_scm, result', [
    ('git log', 'hg', 'hg log'),
    ('hg log', 'git', 'git log')])
def test_get_new_command(get_actual_scm_mock, script, actual_scm, result):
    get_actual_scm_mock.return_value = actual_scm
    new_command = get_new_command(Command(script, ''))
    assert new_command == result
<EOF>
<BOF>
import pytest
from thefuck.rules.git_diff_staged import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('git diff foo', ''),
    Command('git diff', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git diff --staged', ''),
    Command('git tag', ''),
    Command('git branch', ''),
    Command('git log', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git diff', ''), 'git diff --staged'),
    (Command('git diff foo', ''), 'git diff --staged foo')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_pull_uncommitted_changes import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''error: Cannot pull with rebase: You have unstaged changes.'''


def test_match(output):
    assert match(Command('git pull', output))
    assert not match(Command('git pull', ''))
    assert not match(Command('ls', output))


def test_get_new_command(output):
    assert (get_new_command(Command('git pull', output))
            == "git stash && git pull && git stash pop")
<EOF>
<BOF>
import pytest
from thefuck.rules.git_diff_no_index import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('git diff foo bar', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git diff --no-index foo bar', ''),
    Command('git diff foo', ''),
    Command('git diff foo bar baz', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git diff foo bar', ''), 'git diff --no-index foo bar')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_push import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(branch_name):
    if not branch_name:
        return ''
    return '''fatal: The current branch {} has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin {}

'''.format(branch_name, branch_name)


@pytest.fixture
def output_bitbucket():
    return '''Total 0 (delta 0), reused 0 (delta 0)
remote:
remote: Create pull request for feature/set-upstream:
remote:   https://bitbucket.org/set-upstream
remote:
To git@bitbucket.org:test.git
   e5e7fbb..700d998  feature/set-upstream -> feature/set-upstream
Branch feature/set-upstream set up to track remote branch feature/set-upstream from origin.
'''


@pytest.mark.parametrize('script, branch_name', [
    ('git push', 'master'),
    ('git push origin', 'master')])
def test_match(output, script, branch_name):
    assert match(Command(script, output))


def test_match_bitbucket(output_bitbucket):
    assert not match(Command('git push origin', output_bitbucket))


@pytest.mark.parametrize('script, branch_name', [
    ('git push master', None),
    ('ls', 'master')])
def test_not_match(output, script, branch_name):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, branch_name, new_command', [
    ('git push', 'master',
     'git push --set-upstream origin master'),
    ('git push master', 'master',
     'git push --set-upstream origin master'),
    ('git push -u', 'master',
     'git push --set-upstream origin master'),
    ('git push -u origin', 'master',
     'git push --set-upstream origin master'),
    ('git push origin', 'master',
     'git push --set-upstream origin master'),
    ('git push --set-upstream origin', 'master',
     'git push --set-upstream origin master'),
    ('git push --quiet', 'master',
     'git push --set-upstream origin master --quiet'),
    ('git push --quiet origin', 'master',
     'git push --set-upstream origin master --quiet'),
    ('git -c test=test push --quiet origin', 'master',
     'git -c test=test push --set-upstream origin master --quiet'),
    ('git push', "test's",
     "git push --set-upstream origin test\\'s"),
    ('git push --force', 'master',
     'git push --set-upstream origin master --force'),
    ('git push --force-with-lease', 'master',
     'git push --set-upstream origin master --force-with-lease')])
def test_get_new_command(output, script, branch_name, new_command):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from io import BytesIO
from thefuck.rules.gradle_no_task import match, get_new_command
from thefuck.types import Command

gradle_tasks = b'''
:tasks

------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Android tasks
-------------
androidDependencies - Displays the Android dependencies of the project.
signingReport - Displays the signing info for each variant.
sourceSets - Prints out all the source sets defined in this project.

Build tasks
-----------
assemble - Assembles all variants of all applications and secondary packages.
assembleAndroidTest - Assembles all the Test applications.
assembleDebug - Assembles all Debug builds.
assembleRelease - Assembles all Release builds.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
compileDebugAndroidTestSources
compileDebugSources
compileDebugUnitTestSources
compileReleaseSources
compileReleaseUnitTestSources
extractDebugAnnotations - Extracts Android annotations for the debug variant into the archive file
extractReleaseAnnotations - Extracts Android annotations for the release variant into the archive file
mockableAndroidJar - Creates a version of android.jar that's suitable for unit tests.

Build Setup tasks
-----------------
init - Initializes a new Gradle build. [incubating]
wrapper - Generates Gradle wrapper files. [incubating]

Help tasks
----------
components - Displays the components produced by root project 'org.rerenderer_example.snake'. [incubating]
dependencies - Displays all dependencies declared in root project 'org.rerenderer_example.snake'.
dependencyInsight - Displays the insight into a specific dependency in root project 'org.rerenderer_example.snake'.
help - Displays a help message.
model - Displays the configuration model of root project 'org.rerenderer_example.snake'. [incubating]
projects - Displays the sub-projects of root project 'org.rerenderer_example.snake'.
properties - Displays the properties of root project 'org.rerenderer_example.snake'.
tasks - Displays the tasks runnable from root project 'org.rerenderer_example.snake' (some of the displayed tasks may belong to subprojects).

Install tasks
-------------
installDebug - Installs the Debug build.
installDebugAndroidTest - Installs the android (on device) tests for the Debug build.
installRelease - Installs the Release build.
uninstallAll - Uninstall all applications.
uninstallDebug - Uninstalls the Debug build.
uninstallDebugAndroidTest - Uninstalls the android (on device) tests for the Debug build.
uninstallRelease - Uninstalls the Release build.

React tasks
-----------
bundleDebugJsAndAssets - bundle JS and assets for Debug.
bundleReleaseJsAndAssets - bundle JS and assets for Release.

Verification tasks
------------------
check - Runs all checks.
clean - Deletes the build directory.
connectedAndroidTest - Installs and runs instrumentation tests for all flavors on connected devices.
connectedCheck - Runs all device checks on currently connected devices.
connectedDebugAndroidTest - Installs and runs the tests for debug on connected devices.
deviceAndroidTest - Installs and runs instrumentation tests using all Device Providers.
deviceCheck - Runs all device checks using Device Providers and Test Servers.
lint - Runs lint on all variants.
lintDebug - Runs lint on the Debug build.
lintRelease - Runs lint on the Release build.
test - Run unit tests for all variants.
testDebugUnitTest - Run unit tests for the debug build.
testReleaseUnitTest - Run unit tests for the release build.

Other tasks
-----------
assembleDefault
copyDownloadableDepsToLibs
jarDebugClasses
jarReleaseClasses

To see all tasks and more detail, run gradlew tasks --all

To see more detail about a task, run gradlew help --task <task>

BUILD SUCCESSFUL

Total time: 1.936 secs
'''

output_not_found = '''

FAILURE: Build failed with an exception.

* What went wrong:
Task '{}' not found in root project 'org.rerenderer_example.snake'.

* Try:
Run gradlew tasks to get a list of available tasks. Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.
'''.format

output_ambiguous = '''

FAILURE: Build failed with an exception.

* What went wrong:
Task '{}' is ambiguous in root project 'org.rerenderer_example.snake'. Candidates are: 'assembleRelease', 'assembleReleaseUnitTest'.

* Try:
Run gradlew tasks to get a list of available tasks. Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.
'''.format


@pytest.fixture(autouse=True)
def tasks(mocker):
    patch = mocker.patch('thefuck.rules.gradle_no_task.Popen')
    patch.return_value.stdout = BytesIO(gradle_tasks)
    return patch


@pytest.mark.parametrize('command', [
    Command('./gradlew assembler', output_ambiguous('assembler')),
    Command('./gradlew instar', output_not_found('instar')),
    Command('gradle assembler', output_ambiguous('assembler')),
    Command('gradle instar', output_not_found('instar'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('./gradlew assemble', ''),
    Command('gradle assemble', ''),
    Command('npm assembler', output_ambiguous('assembler')),
    Command('npm instar', output_not_found('instar'))])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (Command('./gradlew assembler', output_ambiguous('assembler')),
     './gradlew assemble'),
    (Command('./gradlew instardebug', output_not_found('instardebug')),
     './gradlew installDebug'),
    (Command('gradle assembler', output_ambiguous('assembler')),
     'gradle assemble'),
    (Command('gradle instardebug', output_not_found('instardebug')),
     'gradle installDebug')])
def test_get_new_command(command, result):
    assert get_new_command(command)[0] == result
<EOF>
<BOF>
import pytest
from thefuck.rules.git_add import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def path_exists(mocker):
    return mocker.patch('thefuck.rules.git_add.Path.exists',
                        return_value=True)


@pytest.fixture
def output(target):
    return ("error: pathspec '{}' did not match any "
            'file(s) known to git.'.format(target))


@pytest.mark.parametrize('script, target', [
    ('git submodule update unknown', 'unknown'),
    ('git commit unknown', 'unknown')])
def test_match(output, script, target):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, target, exists', [
    ('git submodule update known', '', True),
    ('git commit known', '', True),
    ('git submodule update known', output, False)])
def test_not_match(path_exists, output, script, target, exists):
    path_exists.return_value = exists
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, target, new_command', [
    ('git submodule update unknown', 'unknown',
     'git add -- unknown && git submodule update unknown'),
    ('git commit unknown', 'unknown',
     'git add -- unknown && git commit unknown')])
def test_get_new_command(output, script, target, new_command):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.cargo_no_command import match, get_new_command
from thefuck.types import Command


no_such_subcommand_old = """No such subcommand

        Did you mean `build`?
"""

no_such_subcommand = """error: no such subcommand

\tDid you mean `build`?
"""


@pytest.mark.parametrize('command', [
    Command('cargo buid', no_such_subcommand_old),
    Command('cargo buils', no_such_subcommand)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('cargo buid', no_such_subcommand_old), 'cargo build'),
    (Command('cargo buils', no_such_subcommand), 'cargo build')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from io import BytesIO
from thefuck.rules.react_native_command_unrecognized import match, \
    get_new_command
from thefuck.types import Command

output = "Unrecognized command '{}'".format

stdout = b'''
Scanning 615 folders for symlinks in /home/nvbn/work/zcho/BookkaWebView/node_modules (6ms)

  Usage: react-native [options] [command]


  Options:

    -V, --version  output the version number
    -h, --help     output usage information


  Commands:

    start [options]                    starts the webserver
    run-ios [options]                  builds your app and starts it on iOS simulator
    run-android [options]              builds your app and starts it on a connected Android emulator or device
    new-library [options]              generates a native library bridge
    bundle [options]                   builds the javascript bundle for offline use
    unbundle [options]                 builds javascript as "unbundle" for offline use
    eject [options]                    Re-create the iOS and Android folders and native code
    link [options] [packageName]       links all native dependencies (updates native build files)
    unlink [options] <packageName>     unlink native dependency
    install [options] <packageName>    install and link native dependencies
    uninstall [options] <packageName>  uninstall and unlink native dependencies
    upgrade [options]                  upgrade your app's template files to the latest version; run this after updating the react-native version in your package.json and running npm install
    log-android [options]              starts adb logcat
    log-ios [options]                  starts iOS device syslog tail
'''


@pytest.mark.parametrize('command', [
    Command('react-native star', output('star')),
    Command('react-native android-logs', output('android-logs'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('gradle star', output('star')),
    Command('react-native start', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (Command('react-native star', output('star')),
     'react-native start'),
    (Command('react-native logsandroid -f', output('logsandroid')),
     'react-native log-android -f')])
def test_get_new_command(mocker, command, result):
    patch = mocker.patch(
        'thefuck.rules.react_native_command_unrecognized.Popen')
    patch.return_value.stdout = BytesIO(stdout)
    assert get_new_command(command)[0] == result
<EOF>
<BOF>
import pytest
from thefuck.rules.apt_get_search import get_new_command, match
from thefuck.types import Command


def test_match():
    assert match(Command('apt-get search foo', ''))


@pytest.mark.parametrize('command', [
    Command('apt-cache search foo', ''),
    Command('aptitude search foo', ''),
    Command('apt search foo', ''),
    Command('apt-get install foo', ''),
    Command('apt-get source foo', ''),
    Command('apt-get clean', ''),
    Command('apt-get remove', ''),
    Command('apt-get update', '')
])
def test_not_match(command):
    assert not match(command)


def test_get_new_command():
    new_command = get_new_command(Command('apt-get search foo', ''))
    assert new_command == 'apt-cache search foo'
<EOF>
<BOF>
import pytest
from thefuck.rules.whois import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('whois https://en.wikipedia.org/wiki/Main_Page', ''),
    Command('whois https://en.wikipedia.org/', ''),
    Command('whois meta.unix.stackexchange.com', '')])
def test_match(command):
    assert match(command)


def test_not_match():
    assert not match(Command('whois', ''))


# `whois com` actually makes sense
@pytest.mark.parametrize('command, new_command', [
    (Command('whois https://en.wikipedia.org/wiki/Main_Page', ''),
     'whois en.wikipedia.org'),
    (Command('whois https://en.wikipedia.org/', ''),
     'whois en.wikipedia.org'),
    (Command('whois meta.unix.stackexchange.com', ''),
     ['whois unix.stackexchange.com',
      'whois stackexchange.com',
      'whois com'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.python_execute import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('python foo', ''),
    Command('python bar', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('python foo', ''), 'python foo.py'),
    (Command('python bar', ''), 'python bar.py')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
from thefuck.rules.python_command import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('temp.py', 'Permission denied'))
    assert not match(Command('', ''))


def test_get_new_command():
    assert (get_new_command(Command('./test_sudo.py', ''))
            == 'python ./test_sudo.py')
<EOF>
<BOF>
import pytest
from thefuck.rules.rm_dir import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('rm foo', 'rm: foo: is a directory'),
    Command('rm foo', 'rm: foo: Is a directory'),
    Command('hdfs dfs -rm foo', 'rm: `foo`: Is a directory'),
    Command('./bin/hdfs dfs -rm foo', 'rm: `foo`: Is a directory'),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('rm foo', ''),
    Command('hdfs dfs -rm foo', ''),
    Command('./bin/hdfs dfs -rm foo', ''),
    Command('', ''),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('rm foo', ''), 'rm -rf foo'),
    (Command('hdfs dfs -rm foo', ''), 'hdfs dfs -rm -r foo'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.hostscli import no_website, get_new_command, match
from thefuck.types import Command

no_website_long = '''
{}:

No Domain list found for website: a_website_that_does_not_exist

Please raise a Issue here: https://github.com/dhilipsiva/hostscli/issues/new
if you think we should add domains for this website.

type `hostscli websites` to see a list of websites that you can block/unblock
'''.format(no_website)


@pytest.mark.parametrize('command', [
    Command('hostscli block a_website_that_does_not_exist', no_website_long)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, result', [(
    Command('hostscli block a_website_that_does_not_exist', no_website_long),
    ['hostscli websites'])])
def test_get_new_command(command, result):
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from mock import patch
from thefuck.rules import pacman
from thefuck.rules.pacman import match, get_new_command
from thefuck.types import Command


pacman_cmd = getattr(pacman, 'pacman', 'pacman')

PKGFILE_OUTPUT_SUDO = 'core/sudo 1.8.13-13/usr/bin/sudo'
PKGFILE_OUTPUT_CONVERT = 'extra/imagemagick 6.9.1.0-1\t/usr/bin/convert'

PKGFILE_OUTPUT_VIM = '''extra/gvim 7.4.712-1        \t/usr/bin/vim
extra/gvim-python3 7.4.712-1\t/usr/bin/vim
extra/vim 7.4.712-1         \t/usr/bin/vim
extra/vim-minimal 7.4.712-1 \t/usr/bin/vim
extra/vim-python3 7.4.712-1 \t/usr/bin/vim'''


@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),
                    reason='Skip if pacman is not available')
@pytest.mark.parametrize('command', [
    Command('vim', 'vim: command not found'),
    Command('sudo vim', 'sudo: vim: command not found')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, return_value', [
    (Command('vim', 'vim: command not found'), PKGFILE_OUTPUT_VIM),
    (Command('sudo vim', 'sudo: vim: command not found'), PKGFILE_OUTPUT_VIM)])
@patch('thefuck.specific.archlinux.subprocess')
@patch.multiple(pacman, create=True, pacman=pacman_cmd)
def test_match_mocked(subp_mock, command, return_value):
    subp_mock.check_output.return_value = return_value
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('vim', ''), Command('', ''),
    Command('sudo vim', ''), Command('', '')])
def test_not_match(command):
    assert not match(command)


sudo_vim_possibilities = ['{} -S extra/gvim && sudo vim',
                          '{} -S extra/gvim-python3 && sudo vim',
                          '{} -S extra/vim && sudo vim',
                          '{} -S extra/vim-minimal && sudo vim',
                          '{} -S extra/vim-python3 && sudo vim']
sudo_vim_possibilities = [s.format(pacman_cmd) for s in sudo_vim_possibilities]

vim_possibilities = ['{} -S extra/gvim && vim',
                     '{} -S extra/gvim-python3 && vim',
                     '{} -S extra/vim && vim',
                     '{} -S extra/vim-minimal && vim',
                     '{} -S extra/vim-python3 && vim']
vim_possibilities = [s.format(pacman_cmd) for s in vim_possibilities]


@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),
                    reason='Skip if pacman is not available')
@pytest.mark.parametrize('command, new_command', [
    (Command('vim', ''), vim_possibilities),
    (Command('sudo vim', ''), sudo_vim_possibilities),
    (Command('convert', ''), ['{} -S extra/imagemagick && convert'.format(pacman_cmd)]),
    (Command('sudo convert', ''), ['{} -S extra/imagemagick && sudo convert'.format(pacman_cmd)])])
def test_get_new_command(command, new_command, mocker):
    assert get_new_command(command) == new_command


@pytest.mark.parametrize('command, new_command, return_value', [
    (Command('vim', ''), vim_possibilities, PKGFILE_OUTPUT_VIM),
    (Command('sudo vim', ''), sudo_vim_possibilities, PKGFILE_OUTPUT_VIM),
    (Command('convert', ''), ['{} -S extra/imagemagick && convert'.format(pacman_cmd)], PKGFILE_OUTPUT_CONVERT),
    (Command('sudo', ''), ['{} -S core/sudo && sudo'.format(pacman_cmd)], PKGFILE_OUTPUT_SUDO),
    (Command('sudo convert', ''), ['{} -S extra/imagemagick && sudo convert'.format(pacman_cmd)], PKGFILE_OUTPUT_CONVERT)])
@patch('thefuck.specific.archlinux.subprocess')
@patch.multiple(pacman, create=True, pacman=pacman_cmd)
def test_get_new_command_mocked(subp_mock, command, new_command, return_value):
    subp_mock.check_output.return_value = return_value
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.cp_omitting_directory import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('script, output', [
    ('cp dir', 'cp: dor: is a directory'),
    ('cp dir', "cp: omitting directory 'dir'")])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('some dir', 'cp: dor: is a directory'),
    ('some dir', "cp: omitting directory 'dir'"),
    ('cp dir', '')])
def test_not_match(script, output):
    assert not match(Command(script, output))


def test_get_new_command():
    assert get_new_command(Command('cp dir', '')) == 'cp -a dir'
<EOF>
<BOF>
from io import BytesIO
import pytest
from thefuck.types import Command
from thefuck.rules.dnf_no_such_command import match, get_new_command, _get_operations


help_text = b'''usage: dnf [options] COMMAND

List of Main Commands:

autoremove                remove all unneeded packages that were originally installed as dependencies
check                     check for problems in the packagedb
check-update              check for available package upgrades
clean                     remove cached data
deplist                   List package's dependencies and what packages provide them
distro-sync               synchronize installed packages to the latest available versions
downgrade                 Downgrade a package
group                     display, or use, the groups information
help                      display a helpful usage message
history                   display, or use, the transaction history
info                      display details about a package or group of packages
install                   install a package or packages on your system
list                      list a package or groups of packages
makecache                 generate the metadata cache
mark                      mark or unmark installed packages as installed by user.
provides                  find what package provides the given value
reinstall                 reinstall a package
remove                    remove a package or packages from your system
repolist                  display the configured software repositories
repoquery                 search for packages matching keyword
repository-packages       run commands on top of all packages in given repository
search                    search package details for the given string
shell                     run an interactive DNF shell
swap                      run an interactive dnf mod for remove and install one spec
updateinfo                display advisories about packages
upgrade                   upgrade a package or packages on your system
upgrade-minimal           upgrade, but only 'newest' package match which fixes a problem that affects your system

List of Plugin Commands:

builddep                  Install build dependencies for package or spec file
config-manager            manage dnf configuration options and repositories
copr                      Interact with Copr repositories.
debug-dump                dump information about installed rpm packages to file
debug-restore             restore packages recorded in debug-dump file
debuginfo-install         install debuginfo packages
download                  Download package to current directory
needs-restarting          determine updated binaries that need restarting
playground                Interact with Playground repository.
repoclosure               Display a list of unresolved dependencies for repositories
repograph                 Output a full package dependency graph in dot format
repomanage                Manage a directory of rpm packages
reposync                  download all packages from remote repo

Optional arguments:
  -c [config file], --config [config file]
                        config file location
  -q, --quiet           quiet operation
  -v, --verbose         verbose operation
  --version             show DNF version and exit
  --installroot [path]  set install root
  --nodocs              do not install documentations
  --noplugins           disable all plugins
  --enableplugin [plugin]
                        enable plugins by name
  --disableplugin [plugin]
                        disable plugins by name
  --releasever RELEASEVER
                        override the value of $releasever in config and repo
                        files
  --setopt SETOPTS      set arbitrary config and repo options
  --skip-broken         resolve depsolve problems by skipping packages
  -h, --help, --help-cmd
                        show command help
  --allowerasing        allow erasing of installed packages to resolve
                        dependencies
  -b, --best            try the best available package versions in
                        transactions.
  -C, --cacheonly       run entirely from system cache, don't update cache
  -R [minutes], --randomwait [minutes]
                        maximum command wait time
  -d [debug level], --debuglevel [debug level]
                        debugging output level
  --debugsolver         dumps detailed solving results into files
  --showduplicates      show duplicates, in repos, in list/search commands
  -e ERRORLEVEL, --errorlevel ERRORLEVEL
                        error output level
  --obsoletes           enables dnf's obsoletes processing logic for upgrade
                        or display capabilities that the package obsoletes for
                        info, list and repoquery
  --rpmverbosity [debug level name]
                        debugging output level for rpm
  -y, --assumeyes       automatically answer yes for all questions
  --assumeno            automatically answer no for all questions
  --enablerepo [repo]
  --disablerepo [repo]
  --repo [repo], --repoid [repo]
                        enable just specific repositories by an id or a glob,
                        can be specified multiple times
  -x [package], --exclude [package], --excludepkgs [package]
                        exclude packages by name or glob
  --disableexcludes [repo], --disableexcludepkgs [repo]
                        disable excludepkgs
  --repofrompath [repo,path]
                        label and path to additional repository, can be
                        specified multiple times.
  --noautoremove        disable removal of dependencies that are no longer
                        used
  --nogpgcheck          disable gpg signature checking
  --color COLOR         control whether colour is used
  --refresh             set metadata as expired before running the command
  -4                    resolve to IPv4 addresses only
  -6                    resolve to IPv6 addresses only
  --destdir DESTDIR, --downloaddir DESTDIR
                        set directory to copy packages to
  --downloadonly        only download packages
  --bugfix              Include bugfix relevant packages, in updates
  --enhancement         Include enhancement relevant packages, in updates
  --newpackage          Include newpackage relevant packages, in updates
  --security            Include security relevant packages, in updates
  --advisory ADVISORY, --advisories ADVISORY
                        Include packages needed to fix the given advisory, in
                        updates
  --bzs BUGZILLA        Include packages needed to fix the given BZ, in
                        updates
  --cves CVES           Include packages needed to fix the given CVE, in
                        updates
  --sec-severity {Critical,Important,Moderate,Low}, --secseverity {Critical,Important,Moderate,Low}
                        Include security relevant packages matching the
                        severity, in updates
  --forcearch ARCH      Force the use of an architecture
'''

dnf_operations = ['autoremove', 'check', 'check-update', 'clean', 'deplist',
                  'distro-sync', 'downgrade', 'group', 'help', 'history',
                  'info', 'install', 'list', 'makecache', 'mark', 'provides',
                  'reinstall', 'remove', 'repolist', 'repoquery',
                  'repository-packages', 'search', 'shell', 'swap', 'updateinfo',
                  'upgrade', 'upgrade-minimal', 'builddep', 'config-manager',
                  'copr', 'debug-dump', 'debug-restore', 'debuginfo-install',
                  'download', 'needs-restarting', 'playground', 'repoclosure',
                  'repograph', 'repomanage', 'reposync']


def invalid_command(command):
    return """No such command: %s. Please use /usr/bin/dnf --help
It could be a DNF plugin command, try: "dnf install 'dnf-command(%s)'"
""" % (command, command)


@pytest.mark.parametrize('output', [
    (invalid_command('saerch')),
    (invalid_command('isntall'))
])
def test_match(output):
    assert match(Command('dnf', output))


@pytest.mark.parametrize('script, output', [
    ('pip', invalid_command('isntall')),
    ('vim', "")
])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.fixture
def set_help(mocker):
    mock = mocker.patch('subprocess.Popen')

    def _set_text(text):
        mock.return_value.stdout = BytesIO(text)

    return _set_text


def test_get_operations(set_help):
    set_help(help_text)
    assert _get_operations() == dnf_operations


@pytest.mark.parametrize('script, output, result', [
    ('dnf isntall vim', invalid_command('isntall'),
     'dnf install vim'),
    ('dnf saerch vim', invalid_command('saerch'),
     'dnf search vim'),
])
def test_get_new_command(set_help, output, script, result):
    set_help(help_text)
    assert result in get_new_command(Command(script, output))
<EOF>
<BOF>
import pytest
from thefuck.rules.sudo_command_from_user_path import match, get_new_command
from thefuck.types import Command


output = 'sudo: {}: command not found'


@pytest.fixture(autouse=True)
def which(mocker):
    return mocker.patch('thefuck.rules.sudo_command_from_user_path.which',
                        return_value='/usr/bin/app')


@pytest.mark.parametrize('script, output', [
    ('sudo npm install -g react-native-cli', output.format('npm')),
    ('sudo -u app appcfg update .', output.format('appcfg'))])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output, which_result', [
    ('npm --version', output.format('npm'), '/usr/bin/npm'),
    ('sudo npm --version', '', '/usr/bin/npm'),
    ('sudo npm --version', output.format('npm'), None)])
def test_not_match(which, script, output, which_result):
    which.return_value = which_result
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, result', [
    ('sudo npm install -g react-native-cli',
     output.format('npm'),
     'sudo env "PATH=$PATH" npm install -g react-native-cli'),
    ('sudo -u app appcfg update .',
     output.format('appcfg'),
     'sudo -u app env "PATH=$PATH" appcfg update .')])
def test_get_new_command(script, output, result):
    assert get_new_command(Command(script, output)) == result
<EOF>
<BOF>
from io import BytesIO
import pytest
from thefuck.types import Command
from thefuck.rules.apt_invalid_operation import match, get_new_command, \
    _get_operations

invalid_operation = 'E: Invalid operation {}'.format
apt_help = b'''apt 1.0.10.2ubuntu1 for amd64 compiled on Oct  5 2015 15:55:05
Usage: apt [options] command

CLI for apt.
Basic commands:
 list - list packages based on package names
 search - search in package descriptions
 show - show package details

 update - update list of available packages

 install - install packages
 remove  - remove packages

 upgrade - upgrade the system by installing/upgrading packages
 full-upgrade - upgrade the system by removing/installing/upgrading packages

 edit-sources - edit the source information file
'''
apt_operations = ['list', 'search', 'show', 'update', 'install', 'remove',
                  'upgrade', 'full-upgrade', 'edit-sources']

apt_get_help = b'''apt 1.0.10.2ubuntu1 for amd64 compiled on Oct  5 2015 15:55:05
Usage: apt-get [options] command
       apt-get [options] install|remove pkg1 [pkg2 ...]
       apt-get [options] source pkg1 [pkg2 ...]

apt-get is a simple command line interface for downloading and
installing packages. The most frequently used commands are update
and install.

Commands:
   update - Retrieve new lists of packages
   upgrade - Perform an upgrade
   install - Install new packages (pkg is libc6 not libc6.deb)
   remove - Remove packages
   autoremove - Remove automatically all unused packages
   purge - Remove packages and config files
   source - Download source archives
   build-dep - Configure build-dependencies for source packages
   dist-upgrade - Distribution upgrade, see apt-get(8)
   dselect-upgrade - Follow dselect selections
   clean - Erase downloaded archive files
   autoclean - Erase old downloaded archive files
   check - Verify that there are no broken dependencies
   changelog - Download and display the changelog for the given package
   download - Download the binary package into the current directory

Options:
  -h  This help text.
  -q  Loggable output - no progress indicator
  -qq No output except for errors
  -d  Download only - do NOT install or unpack archives
  -s  No-act. Perform ordering simulation
  -y  Assume Yes to all queries and do not prompt
  -f  Attempt to correct a system with broken dependencies in place
  -m  Attempt to continue if archives are unlocatable
  -u  Show a list of upgraded packages as well
  -b  Build the source package after fetching it
  -V  Show verbose version numbers
  -c=? Read this configuration file
  -o=? Set an arbitrary configuration option, eg -o dir::cache=/tmp
See the apt-get(8), sources.list(5) and apt.conf(5) manual
pages for more information and options.
                       This APT has Super Cow Powers.
'''
apt_get_operations = ['update', 'upgrade', 'install', 'remove', 'autoremove',
                      'purge', 'source', 'build-dep', 'dist-upgrade',
                      'dselect-upgrade', 'clean', 'autoclean', 'check',
                      'changelog', 'download']


@pytest.mark.parametrize('script, output', [
    ('apt', invalid_operation('saerch')),
    ('apt-get', invalid_operation('isntall')),
    ('apt-cache', invalid_operation('rumove'))])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('vim', invalid_operation('vim')),
    ('apt-get', "")])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.fixture
def set_help(mocker):
    mock = mocker.patch('subprocess.Popen')

    def _set_text(text):
        mock.return_value.stdout = BytesIO(text)

    return _set_text


@pytest.mark.parametrize('app, help_text, operations', [
    ('apt', apt_help, apt_operations),
    ('apt-get', apt_get_help, apt_get_operations)
])
def test_get_operations(set_help, app, help_text, operations):
    set_help(help_text)
    assert _get_operations(app) == operations


@pytest.mark.parametrize('script, output, help_text, result', [
    ('apt-get isntall vim', invalid_operation('isntall'),
     apt_get_help, 'apt-get install vim'),
    ('apt saerch vim', invalid_operation('saerch'),
     apt_help, 'apt search vim'),
])
def test_get_new_command(set_help, output, script, help_text, result):
    set_help(help_text)
    assert get_new_command(Command(script, output))[0] == result
<EOF>
<BOF>
import pytest
from thefuck.rules.workon_doesnt_exists import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def envs(mocker):
    return mocker.patch(
        'thefuck.rules.workon_doesnt_exists._get_all_environments',
        return_value=['thefuck', 'code_view'])


@pytest.mark.parametrize('script', [
    'workon tehfuck', 'workon code-view', 'workon new-env'])
def test_match(script):
    assert match(Command(script, ''))


@pytest.mark.parametrize('script', [
    'workon thefuck', 'workon code_view', 'work on tehfuck'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, result', [
    ('workon tehfuck', 'workon thefuck'),
    ('workon code-view', 'workon code_view'),
    ('workon zzzz', 'mkvirtualenv zzzz')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, ''))[0] == result
<EOF>
<BOF>
import pytest
from thefuck.rules.git_remote_delete import get_new_command, match
from thefuck.types import Command


def test_match():
    assert match(Command('git remote delete foo', ''))


@pytest.mark.parametrize('command', [
    Command('git remote remove foo', ''),
    Command('git remote add foo', ''),
    Command('git commit', '')
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git remote delete foo', ''), 'git remote remove foo'),
    (Command('git remote delete delete', ''), 'git remote remove delete'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import pytest
from thefuck.types import Command
from thefuck.rules.heroku_multiple_apps import match, get_new_command


suggest_output = '''
 ▸    Multiple apps in git remotes
 ▸    Usage: --remote heroku-dev
 ▸    or: --app myapp-dev
 ▸    Your local git repository has more than 1 app referenced in git remotes.
 ▸    Because of this, we can't determine which app you want to run this command against.
 ▸    Specify the app you want with --app or --remote.
 ▸    Heroku remotes in repo:
 ▸    myapp (heroku)
 ▸    myapp-dev (heroku-dev)
 ▸
 ▸    https://devcenter.heroku.com/articles/multiple-environments
'''

not_match_output = '''
=== HEROKU_POSTGRESQL_TEAL_URL, DATABASE_URL
Plan:                  Hobby-basic
Status:                Available
Connections:           20/20
PG Version:            9.6.4
Created:               2017-01-01 00:00 UTC
Data Size:             99.9 MB
Tables:                99
Rows:                  12345/10000000 (In compliance)
Fork/Follow:           Unsupported
Rollback:              Unsupported
Continuous Protection: Off
Add-on:                postgresql-round-12345
'''


@pytest.mark.parametrize('cmd', ['pg'])
def test_match(cmd):
    assert match(
        Command('heroku {}'.format(cmd), suggest_output))


@pytest.mark.parametrize('script, output', [
    ('heroku pg', not_match_output)])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('cmd, result', [
    ('pg', ['heroku pg --app myapp', 'heroku pg --app myapp-dev'])])
def test_get_new_command(cmd, result):
    command = Command('heroku {}'.format(cmd), suggest_output)
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from thefuck.types import Command
from thefuck.rules.brew_update_formula import get_new_command, match


output = ("Error: This command updates brew itself, and does not take formula"
          " names.\nUse 'brew upgrade thefuck'.")


def test_match():
    command = Command('brew update thefuck', output)
    assert match(command)


@pytest.mark.parametrize('script', [
    'brew upgrade foo',
    'brew update'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, formula, ', [
    ('brew update foo', 'foo'),
    ('brew update bar zap', 'bar zap')])
def test_get_new_command(script, formula):
    command = Command(script, output)
    new_command = 'brew upgrade {}'.format(formula)
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.adb_unknown_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''Android Debug Bridge version 1.0.31

 -d                            - directs command to the only connected USB device
                                 returns an error if more than one USB device is present.
 -e                            - directs command to the only running emulator.
                                 returns an error if more than one emulator is running.
 -s <specific device>          - directs command to the device or emulator with the given
                                 serial number or qualifier. Overrides ANDROID_SERIAL
                                 environment variable.
'''


@pytest.mark.parametrize('script', [
    ('adb lgcat'),
    ('adb puhs')])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', [
    'git branch foo',
    'abd push'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, new_command', [
    ('adb puhs test.bin /sdcard/test.bin', 'adb push test.bin /sdcard/test.bin'),
    ('adb -s 1111 logcta', 'adb -s 1111 logcat'),
    ('adb -P 666 pulll /sdcard/test.bin', 'adb -P 666 pull /sdcard/test.bin'),
    ('adb -d logcatt', 'adb -d logcat'),
    ('adb -e reboott', 'adb -e reboot')])
def test_get_new_command(script, output, new_command):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_rm_recursive import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(target):
    return "fatal: not removing '{}' recursively without -r".format(target)


@pytest.mark.parametrize('script, target', [
    ('git rm foo', 'foo'),
    ('git rm foo bar', 'foo bar')])
def test_match(output, script, target):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['git rm foo', 'git rm foo bar'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, target, new_command', [
    ('git rm foo', 'foo', 'git rm -r foo'),
    ('git rm foo bar', 'foo bar', 'git rm -r foo bar')])
def test_get_new_command(output, script, target, new_command):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_stash import match, get_new_command
from thefuck.types import Command


cherry_pick_error = (
    'error: Your local changes would be overwritten by cherry-pick.\n'
    'hint: Commit your changes or stash them to proceed.\n'
    'fatal: cherry-pick failed')


rebase_error = (
    'Cannot rebase: Your index contains uncommitted changes.\n'
    'Please commit or stash them.')


@pytest.mark.parametrize('command', [
    Command('git cherry-pick a1b2c3d', cherry_pick_error),
    Command('git rebase -i HEAD~7', rebase_error)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git cherry-pick a1b2c3d', ''),
    Command('git rebase -i HEAD~7', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git cherry-pick a1b2c3d', cherry_pick_error),
     'git stash && git cherry-pick a1b2c3d'),
    (Command('git rebase -i HEAD~7', rebase_error),
     'git stash && git rebase -i HEAD~7')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import pytest
from thefuck.types import Command
from thefuck.rules.heroku_not_command import match, get_new_command


suggest_output = '''
 ▸    log is not a heroku command.
 ▸    Perhaps you meant logs?
 ▸    Run heroku _ to run heroku logs.
 ▸    Run heroku help for a list of available commands.'''


@pytest.mark.parametrize('cmd', ['log'])
def test_match(cmd):
    assert match(
        Command('heroku {}'.format(cmd), suggest_output))


@pytest.mark.parametrize('script, output', [
    ('cat log', suggest_output)])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('cmd, result', [
    ('log', 'heroku logs')])
def test_get_new_command(cmd, result):
    command = Command('heroku {}'.format(cmd), suggest_output)
    assert get_new_command(command) == result
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import os
import pytest
import zipfile
from thefuck.rules.dirty_unzip import match, get_new_command, side_effect
from thefuck.types import Command
from unicodedata import normalize


@pytest.fixture
def zip_error(tmpdir):
    def zip_error_inner(filename):
        path = os.path.join(str(tmpdir), filename)

        def reset(path):
            with zipfile.ZipFile(path, 'w') as archive:
                archive.writestr('a', '1')
                archive.writestr('b', '2')
                archive.writestr('c', '3')

                archive.writestr('d/e', '4')

                archive.extractall()

        os.chdir(str(tmpdir))
        reset(path)

        dir_list = os.listdir(u'.')
        if filename not in dir_list:
            filename = normalize('NFD', filename)

        assert set(dir_list) == {filename, 'a', 'b', 'c', 'd'}
        assert set(os.listdir('./d')) == {'e'}
    return zip_error_inner


@pytest.mark.parametrize('script,filename', [
    (u'unzip café', u'café.zip'),
    (u'unzip café.zip', u'café.zip'),
    (u'unzip foo', u'foo.zip'),
    (u'unzip foo.zip', u'foo.zip')])
def test_match(zip_error, script, filename):
    zip_error(filename)
    assert match(Command(script, ''))


@pytest.mark.parametrize('script,filename', [
    (u'unzip café', u'café.zip'),
    (u'unzip café.zip', u'café.zip'),
    (u'unzip foo', u'foo.zip'),
    (u'unzip foo.zip', u'foo.zip')])
def test_side_effect(zip_error, script, filename):
    zip_error(filename)
    side_effect(Command(script, ''), None)

    dir_list = os.listdir(u'.')
    if filename not in set(dir_list):
        filename = normalize('NFD', filename)

    assert set(dir_list) == {filename, 'd'}


@pytest.mark.parametrize('script,fixed,filename', [
    (u'unzip café', u"unzip café -d 'café'", u'café.zip'),
    (u'unzip foo', u'unzip foo -d foo', u'foo.zip'),
    (u"unzip 'foo bar.zip'", u"unzip 'foo bar.zip' -d 'foo bar'", u'foo.zip'),
    (u'unzip foo.zip', u'unzip foo.zip -d foo', u'foo.zip')])
def test_get_new_command(zip_error, script, fixed, filename):
    zip_error(filename)
    assert get_new_command(Command(script, '')) == fixed
<EOF>
<BOF>
import pytest
from thefuck.types import Command
from thefuck.rules.git_bisect_usage import match, get_new_command


@pytest.fixture
def output():
    return ("usage: git bisect [help|start|bad|good|new|old"
            "|terms|skip|next|reset|visualize|replay|log|run]")


@pytest.mark.parametrize('script', [
    'git bisect strt', 'git bisect rset', 'git bisect goood'])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', [
    'git bisect', 'git bisect start', 'git bisect good'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, new_cmd, ', [
    ('git bisect goood', ['good', 'old', 'log']),
    ('git bisect strt', ['start', 'terms', 'reset']),
    ('git bisect rset', ['reset', 'next', 'start'])])
def test_get_new_command(output, script, new_cmd):
    new_cmd = ['git bisect %s' % cmd for cmd in new_cmd]
    assert get_new_command(Command(script, output)) == new_cmd
<EOF>
<BOF>
import pytest
from thefuck.rules.mvn_no_command import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('mvn', '[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('mvn clean', """
[INFO] Scanning for projects...[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building test 0.2
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ test ---
[INFO] Deleting /home/mlk/code/test/target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.477s
[INFO] Finished at: Wed Aug 26 13:05:47 BST 2015
[INFO] Final Memory: 6M/240M
[INFO] ------------------------------------------------------------------------
"""),  # noqa
    Command('mvn --help', ''),
    Command('mvn -v', '')
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('mvn', '[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]'), ['mvn clean package', 'mvn clean install']),
    (Command('mvn -N', '[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]'), ['mvn -N clean package', 'mvn -N clean install'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.tsuru_login import match, get_new_command
from thefuck.types import Command


error_msg = (
    "Error: you're not authenticated or your session has expired.",
    ("You're not authenticated or your session has expired. "
     "Please use \"login\" command for authentication."),
)


@pytest.mark.parametrize('command', [
    Command('tsuru app-shell', error_msg[0]),
    Command('tsuru app-log -f', error_msg[1]),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('tsuru', ''),
    Command('tsuru app-restart', 'Error: unauthorized'),
    Command('tsuru app-log -f', 'Error: unparseable data'),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('tsuru app-shell', error_msg[0]),
     'tsuru login && tsuru app-shell'),
    (Command('tsuru app-log -f', error_msg[1]),
     'tsuru login && tsuru app-log -f'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.sed_unterminated_s import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def sed_unterminated_s():
    return "sed: -e expression #1, char 9: unterminated `s' command"


def test_match(sed_unterminated_s):
    assert match(Command('sed -e s/foo/bar', sed_unterminated_s))
    assert match(Command('sed -es/foo/bar', sed_unterminated_s))
    assert match(Command('sed -e s/foo/bar -e s/baz/quz', sed_unterminated_s))
    assert not match(Command('sed -e s/foo/bar', ''))
    assert not match(Command('sed -es/foo/bar', ''))
    assert not match(Command('sed -e s/foo/bar -e s/baz/quz', ''))


def test_get_new_command(sed_unterminated_s):
    assert (get_new_command(Command('sed -e s/foo/bar', sed_unterminated_s))
            == 'sed -e s/foo/bar/')
    assert (get_new_command(Command('sed -es/foo/bar', sed_unterminated_s))
            == 'sed -es/foo/bar/')
    assert (get_new_command(Command(r"sed -e 's/\/foo/bar'", sed_unterminated_s))
            == r"sed -e 's/\/foo/bar/'")
    assert (get_new_command(Command(r"sed -e s/foo/bar -es/baz/quz", sed_unterminated_s))
            == r"sed -e s/foo/bar/ -es/baz/quz/")
<EOF>
<BOF>
import pytest
from thefuck.rules.cat_dir import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def isdir(mocker):
    return mocker.patch('thefuck.rules.cat_dir'
                        '.os.path.isdir')


@pytest.mark.parametrize('command', [
    Command('cat foo', 'cat: foo: Is a directory\n'),
    Command('cat /foo/bar/', 'cat: /foo/bar/: Is a directory\n'),
    Command('cat cat/', 'cat: cat/: Is a directory\n'),
])
def test_match(command, isdir):
    isdir.return_value = True
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('cat foo', 'foo bar baz'),
    Command('cat foo bar', 'foo bar baz'),
    Command('notcat foo bar', 'some output'),
])
def test_not_match(command, isdir):
    isdir.return_value = False
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('cat foo', 'cat: foo: Is a directory\n'), 'ls foo'),
    (Command('cat /foo/bar/', 'cat: /foo/bar/: Is a directory\n'), 'ls /foo/bar/'),
    (Command('cat cat', 'cat: cat: Is a directory\n'), 'ls cat'),
])
def test_get_new_command(command, new_command):
    isdir.return_value = True
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.pip_unknown_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def pip_unknown_cmd():
    return '''ERROR: unknown command "instatl" - maybe you meant "install"'''


@pytest.fixture
def pip_unknown_cmd_without_recommend():
    return '''ERROR: unknown command "i"'''


def test_match(pip_unknown_cmd, pip_unknown_cmd_without_recommend):
    assert match(Command('pip instatl', pip_unknown_cmd))
    assert not match(Command('pip i',
                             pip_unknown_cmd_without_recommend))


def test_get_new_command(pip_unknown_cmd):
    assert get_new_command(Command('pip instatl',
                                   pip_unknown_cmd)) == 'pip install'
<EOF>
<BOF>
import pytest
from thefuck.rules.git_pull_clone import match, get_new_command
from thefuck.types import Command


git_err = '''
fatal: Not a git repository (or any parent up to mount point /home)
Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set).
'''


@pytest.mark.parametrize('command', [
    Command('git pull git@github.com:mcarton/thefuck.git', git_err)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, output', [
    (Command('git pull git@github.com:mcarton/thefuck.git', git_err), 'git clone git@github.com:mcarton/thefuck.git')])
def test_get_new_command(command, output):
    assert get_new_command(command) == output
<EOF>
<BOF>
import pytest
from thefuck.rules.long_form_help import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('output', [
    'Try \'grep --help\' for more information.'])
def test_match(output):
    assert match(Command('grep -h', output))


def test_not_match():
    assert not match(Command('', ''))


@pytest.mark.parametrize('before, after', [
    ('grep -h', 'grep --help'),
    ('tar -h', 'tar --help'),
    ('docker run -h', 'docker run --help'),
    ('cut -h', 'cut --help')])
def test_get_new_command(before, after):
    assert get_new_command(Command(before, '')) == after
<EOF>
<BOF>
import pytest

from thefuck.rules.aws_cli import match, get_new_command
from thefuck.types import Command


no_suggestions = '''\
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument command: Invalid choice, valid choices are:

dynamodb                                 | dynamodbstreams
ec2                                      | ecr
'''


misspelled_command = '''\
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument command: Invalid choice, valid choices are:

dynamodb                                 | dynamodbstreams
ec2                                      | ecr


Invalid choice: 'dynamdb', maybe you meant:

  * dynamodb
'''


misspelled_subcommand = '''\
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument operation: Invalid choice, valid choices are:

query                                    | scan
update-item                              | update-table


Invalid choice: 'scn', maybe you meant:

  * scan
'''


misspelled_subcommand_with_multiple_options = '''\
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument operation: Invalid choice, valid choices are:

describe-table                           | get-item
list-tables                              | put-item


Invalid choice: 't-item', maybe you meant:

  * put-item
  * get-item
'''


@pytest.mark.parametrize('command', [
    Command('aws dynamdb scan', misspelled_command),
    Command('aws dynamodb scn', misspelled_subcommand),
    Command('aws dynamodb t-item',
            misspelled_subcommand_with_multiple_options)])
def test_match(command):
    assert match(command)


def test_not_match():
    assert not match(Command('aws dynamodb invalid', no_suggestions))


@pytest.mark.parametrize('command, result', [
    (Command('aws dynamdb scan', misspelled_command),
     ['aws dynamodb scan']),
    (Command('aws dynamodb scn', misspelled_subcommand),
     ['aws dynamodb scan']),
    (Command('aws dynamodb t-item',
             misspelled_subcommand_with_multiple_options),
     ['aws dynamodb put-item', 'aws dynamodb get-item'])])
def test_get_new_command(command, result):
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from thefuck.rules.gradle_wrapper import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def exists(mocker):
    return mocker.patch('thefuck.rules.gradle_wrapper.os.path.isfile',
                        return_value=True)


@pytest.mark.parametrize('command', [
    Command('gradle tasks', 'gradle: not found'),
    Command('gradle build', 'gradle: not found')])
def test_match(mocker, command):
    mocker.patch('thefuck.rules.gradle_wrapper.which', return_value=None)

    assert match(command)


@pytest.mark.parametrize('command, gradlew, which', [
    (Command('gradle tasks', 'gradle: not found'), False, None),
    (Command('gradle tasks', 'command not found'), True, '/usr/bin/gradle'),
    (Command('npm tasks', 'npm: not found'), True, None)])
def test_not_match(mocker, exists, command, gradlew, which):
    mocker.patch('thefuck.rules.gradle_wrapper.which', return_value=which)
    exists.return_value = gradlew

    assert not match(command)


@pytest.mark.parametrize('script, result', [
    ('gradle assemble', './gradlew assemble'),
    ('gradle --help', './gradlew --help'),
    ('gradle build -c', './gradlew build -c')])
def test_get_new_command(script, result):
    command = Command(script, '')
    assert get_new_command(command) == result
<EOF>
<BOF>
import os
import pytest
import tarfile
from thefuck.rules.dirty_untar import match, get_new_command, side_effect, \
                                      tar_extensions  # noqa: E126
from thefuck.types import Command


@pytest.fixture
def tar_error(tmpdir):
    def fixture(filename):
        path = os.path.join(str(tmpdir), filename)

        def reset(path):
            os.mkdir('d')
            with tarfile.TarFile(path, 'w') as archive:
                for file in ('a', 'b', 'c', 'd/e'):
                    with open(file, 'w') as f:
                        f.write('*')

                    archive.add(file)

                    os.remove(file)

            with tarfile.TarFile(path, 'r') as archive:
                archive.extractall()

        os.chdir(str(tmpdir))
        reset(path)

        assert set(os.listdir('.')) == {filename, 'a', 'b', 'c', 'd'}
        assert set(os.listdir('./d')) == {'e'}

    return fixture


parametrize_extensions = pytest.mark.parametrize('ext', tar_extensions)

# (filename as typed by the user, unquoted filename, quoted filename as per shells.quote)
parametrize_filename = pytest.mark.parametrize('filename, unquoted, quoted', [
    ('foo{}', 'foo{}', 'foo{}'),
    ('"foo bar{}"', 'foo bar{}', "'foo bar{}'")])

parametrize_script = pytest.mark.parametrize('script, fixed', [
    ('tar xvf {}', 'mkdir -p {dir} && tar xvf {filename} -C {dir}'),
    ('tar -xvf {}', 'mkdir -p {dir} && tar -xvf {filename} -C {dir}'),
    ('tar --extract -f {}', 'mkdir -p {dir} && tar --extract -f {filename} -C {dir}')])


@parametrize_extensions
@parametrize_filename
@parametrize_script
def test_match(ext, tar_error, filename, unquoted, quoted, script, fixed):
    tar_error(unquoted.format(ext))
    assert match(Command(script.format(filename.format(ext)), ''))


@parametrize_extensions
@parametrize_filename
@parametrize_script
def test_side_effect(ext, tar_error, filename, unquoted, quoted, script, fixed):
    tar_error(unquoted.format(ext))
    side_effect(Command(script.format(filename.format(ext)), ''), None)
    assert set(os.listdir('.')) == {unquoted.format(ext), 'd'}


@parametrize_extensions
@parametrize_filename
@parametrize_script
def test_get_new_command(ext, tar_error, filename, unquoted, quoted, script, fixed):
    tar_error(unquoted.format(ext))
    assert (get_new_command(Command(script.format(filename.format(ext)), ''))
            == fixed.format(dir=quoted.format(''), filename=filename.format(ext)))
<EOF>
<BOF>
import pytest

from thefuck.types import Command
from thefuck.rules.mercurial import (
    extract_possibilities, match, get_new_command
)


@pytest.mark.parametrize('command', [
    Command('hg base', (
        "hg: unknown command 'base'"
        '\n(did you mean one of blame, phase, rebase?)'
    )),
    Command('hg branchch', (
        "hg: unknown command 'branchch'"
        '\n(did you mean one of branch, branches?)'
    )),
    Command('hg vert', (
        "hg: unknown command 'vert'"
        '\n(did you mean one of revert?)'
    )),
    Command('hg lgo -r tip', (
        "hg: command 're' is ambiguous:"
        '\n(did you mean one of log?)'
    )),
    Command('hg rerere', (
        "hg: unknown command 'rerere'"
        '\n(did you mean one of revert?)'
    )),
    Command('hg re', (
        "hg: command 're' is ambiguous:"
        '\n    rebase recover remove rename resolve revert'
    )),
    Command('hg re re', (
        "hg: command 're' is ambiguous:"
        '\n    rebase recover remove rename resolve revert'
    )),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('hg', (
        '\nMercurial Distributed SCM\n\nbasic commands:'
    )),
    Command('hg asdf', (
        "hg: unknown command 'asdf'"
        '\nMercurial Distributed SCM\n\nbasic commands:'
    )),
    Command('hg qwer', (
        "hg: unknown command 'qwer'"
        '\nMercurial Distributed SCM\n\nbasic commands:'
    )),
    Command('hg me', (
        "\nabort: no repository found in './thefuck' (.hg not found)!"
    )),
    Command('hg reb', (
        "\nabort: no repository found in './thefuck' (.hg not found)!"
    )),
    Command('hg co', (
        "\nabort: no repository found in './thefuck' (.hg not found)!"
    )),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, possibilities', [
    (Command('hg base', (
        "hg: unknown command 'base'"
        '\n(did you mean one of blame, phase, rebase?)'
    )), ['blame', 'phase', 'rebase']),
    (Command('hg branchch', (
        "hg: unknown command 'branchch'"
        '\n(did you mean one of branch, branches?)'
    )), ['branch', 'branches']),
    (Command('hg vert', (
        "hg: unknown command 'vert'"
        '\n(did you mean one of revert?)'
    )), ['revert']),
    (Command('hg lgo -r tip', (
        "hg: command 're' is ambiguous:"
        '\n(did you mean one of log?)'
    )), ['log']),
    (Command('hg rerere', (
        "hg: unknown command 'rerere'"
        '\n(did you mean one of revert?)'
    )), ['revert']),
    (Command('hg re', (
        "hg: command 're' is ambiguous:"
        '\n    rebase recover remove rename resolve revert'
    )), ['rebase', 'recover', 'remove', 'rename', 'resolve', 'revert']),
    (Command('hg re re', (
        "hg: command 're' is ambiguous:"
        '\n    rebase recover remove rename resolve revert'
    )), ['rebase', 'recover', 'remove', 'rename', 'resolve', 'revert']),
])
def test_extract_possibilities(command, possibilities):
    assert extract_possibilities(command) == possibilities


@pytest.mark.parametrize('command, new_command', [
    (Command('hg base', (
        "hg: unknown command 'base'"
        '\n(did you mean one of blame, phase, rebase?)'
    )), 'hg rebase'),
    (Command('hg branchch', (
        "hg: unknown command 'branchch'"
        '\n(did you mean one of branch, branches?)'
    )), 'hg branch'),
    (Command('hg vert', (
        "hg: unknown command 'vert'"
        '\n(did you mean one of revert?)'
    )), 'hg revert'),
    (Command('hg lgo -r tip', (
        "hg: command 're' is ambiguous:"
        '\n(did you mean one of log?)'
    )), 'hg log -r tip'),
    (Command('hg rerere', (
        "hg: unknown command 'rerere'"
        '\n(did you mean one of revert?)'
    )), 'hg revert'),
    (Command('hg re', (
        "hg: command 're' is ambiguous:"
        '\n    rebase recover remove rename resolve revert'
    )), 'hg rebase'),
    (Command('hg re re', (
        "hg: command 're' is ambiguous:"
        '\n    rebase recover remove rename resolve revert'
    )), 'hg rebase re'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import os
import pytest
from thefuck.rules.ssh_known_hosts import match, get_new_command,\
    side_effect
from thefuck.types import Command


@pytest.fixture
def ssh_error(tmpdir):
    path = os.path.join(str(tmpdir), 'known_hosts')

    def reset(path):
        with open(path, 'w') as fh:
            lines = [
                '123.234.567.890 asdjkasjdakjsd\n'
                '98.765.432.321 ejioweojwejrosj\n'
                '111.222.333.444 qwepoiwqepoiss\n'
            ]
            fh.writelines(lines)

    def known_hosts(path):
        with open(path, 'r') as fh:
            return fh.readlines()

    reset(path)

    errormsg = u"""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
b6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.
Please contact your system administrator.
Add correct host key in {0} to get rid of this message.
Offending RSA key in {0}:2
RSA host key for {1} has changed and you have requested strict checking.
Host key verification failed.""".format(path, '98.765.432.321')

    return errormsg, path, reset, known_hosts


def test_match(ssh_error):
    errormsg, _, _, _ = ssh_error
    assert match(Command('ssh', errormsg))
    assert match(Command('ssh', errormsg))
    assert match(Command('scp something something', errormsg))
    assert match(Command('scp something something', errormsg))
    assert not match(Command(errormsg, ''))
    assert not match(Command('notssh', errormsg))
    assert not match(Command('ssh', ''))


@pytest.mark.skipif(os.name == 'nt', reason='Skip if testing on Windows')
def test_side_effect(ssh_error):
    errormsg, path, reset, known_hosts = ssh_error
    command = Command('ssh user@host', errormsg)
    side_effect(command, None)
    expected = ['123.234.567.890 asdjkasjdakjsd\n', '111.222.333.444 qwepoiwqepoiss\n']
    assert known_hosts(path) == expected


def test_get_new_command(ssh_error, monkeypatch):
    errormsg, _, _, _ = ssh_error
    assert get_new_command(Command('ssh user@host', errormsg)) == 'ssh user@host'
<EOF>
<BOF>
from io import BytesIO

import pytest
from thefuck.rules.port_already_in_use import match, get_new_command
from thefuck.types import Command

outputs = [
    '''

DE 70% 1/1 build modulesevents.js:141
      throw er; // Unhandled 'error' event
      ^

Error: listen EADDRINUSE 127.0.0.1:8080
    at Object.exports._errnoException (util.js:873:11)
    at exports._exceptionWithHostPort (util.js:896:20)
    at Server._listen2 (net.js:1250:14)
    at listen (net.js:1286:10)
    at net.js:1395:9
    at GetAddrInfoReqWrap.asyncCallback [as callback] (dns.js:64:16)
    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:83:10)

    ''',
    '''
[6:40:01 AM] <START> Building Dependency Graph
[6:40:01 AM] <START> Crawling File System
 ERROR  Packager can't listen on port 8080
Most likely another process is already using this port
Run the following command to find out which process:

   lsof -n -i4TCP:8080

You can either shut down the other process:

   kill -9 <PID>

or run packager on different port.

    ''',
    '''
Traceback (most recent call last):
  File "/usr/lib/python3.5/runpy.py", line 184, in _run_module_as_main
    "__main__", mod_spec)
  File "/usr/lib/python3.5/runpy.py", line 85, in _run_code
    exec(code, run_globals)
  File "/home/nvbn/exp/code_view/server/code_view/main.py", line 14, in <module>
    web.run_app(app)
  File "/home/nvbn/.virtualenvs/code_view/lib/python3.5/site-packages/aiohttp/web.py", line 310, in run_app
    backlog=backlog))
  File "/usr/lib/python3.5/asyncio/base_events.py", line 373, in run_until_complete
    return future.result()
  File "/usr/lib/python3.5/asyncio/futures.py", line 274, in result
    raise self._exception
  File "/usr/lib/python3.5/asyncio/tasks.py", line 240, in _step
    result = coro.send(None)
  File "/usr/lib/python3.5/asyncio/base_events.py", line 953, in create_server
    % (sa, err.strerror.lower()))
OSError: [Errno 98] error while attempting to bind on address ('0.0.0.0', 8080): address already in use
Task was destroyed but it is pending!
task: <Task pending coro=<RedisProtocol._reader_coroutine() running at /home/nvbn/.virtualenvs/code_view/lib/python3.5/site-packages/asyncio_redis/protocol.py:921> wait_for=<Future pending cb=[Task._wakeup()]>>
    '''
]

lsof_stdout = b'''COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
node    18233 nvbn   16u  IPv4 557134      0t0  TCP localhost:http-alt (LISTEN)
'''


@pytest.fixture(autouse=True)
def lsof(mocker):
    patch = mocker.patch('thefuck.rules.port_already_in_use.Popen')
    patch.return_value.stdout = BytesIO(lsof_stdout)
    return patch


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize(
    'command',
    [Command('./app', output) for output in outputs]
    + [Command('./app', output) for output in outputs])
def test_match(command):
    assert match(command)


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('command, lsof_output', [
    (Command('./app', ''), lsof_stdout),
    (Command('./app', outputs[1]), b''),
    (Command('./app', outputs[2]), b'')])
def test_not_match(lsof, command, lsof_output):
    lsof.return_value.stdout = BytesIO(lsof_output)

    assert not match(command)


@pytest.mark.parametrize(
    'command',
    [Command('./app', output) for output in outputs]
    + [Command('./app', output) for output in outputs])
def test_get_new_command(command):
    assert get_new_command(command) == 'kill 18233 && ./app'
<EOF>
<BOF>
import pytest
from thefuck.rules.npm_wrong_command import match, get_new_command
from thefuck.types import Command

output = '''
Usage: npm <command>

where <command> is one of:
    access, add-user, adduser, apihelp, author, bin, bugs, c,
    cache, completion, config, ddp, dedupe, deprecate, dist-tag,
    dist-tags, docs, edit, explore, faq, find, find-dupes, get,
    help, help-search, home, i, info, init, install, issues, la,
    link, list, ll, ln, login, logout, ls, outdated, owner,
    pack, ping, prefix, prune, publish, r, rb, rebuild, remove,
    repo, restart, rm, root, run-script, s, se, search, set,
    show, shrinkwrap, star, stars, start, stop, t, tag, team,
    test, tst, un, uninstall, unlink, unpublish, unstar, up,
    update, upgrade, v, verison, version, view, whoami

npm <cmd> -h     quick help on <cmd>
npm -l           display full usage info
npm faq          commonly asked questions
npm help <term>  search for help on <term>
npm help npm     involved overview

Specify configs in the ini-formatted file:
    /home/nvbn/.npmrc
or on the command line via: npm <command> --key value
Config info can be viewed via: npm help config

npm@2.14.7 /opt/node/lib/node_modules/npm
'''


@pytest.mark.parametrize('script', [
    'npm urgrdae',
    'npm urgrade -g',
    'npm -f urgrade -g',
    'npm urg'])
def test_match(script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('npm urgrade', ''),
    ('npm', output),
    ('test urgrade', output),
    ('npm -e', output)])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, result', [
    ('npm urgrade', 'npm upgrade'),
    ('npm -g isntall gulp', 'npm -g install gulp'),
    ('npm isntall -g gulp', 'npm install -g gulp')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, output)) == result
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

from io import BytesIO
import pytest
from thefuck.types import Command
from thefuck.rules.grunt_task_not_found import match, get_new_command

output = '''
Warning: Task "{}" not found. Use --force to continue.

Aborted due to warnings.


Execution Time (2016-08-13 21:01:40 UTC+3)
loading tasks  11ms  ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 92%
Total 12ms

'''.format

grunt_help_stdout = b'''
Grunt: The JavaScript Task Runner (v0.4.5)

Usage
 grunt [options] [task [task ...]]

Options
    --help, -h  Display this help text.
        --base  Specify an alternate base path. By default, all file paths are
                relative to the Gruntfile. (grunt.file.setBase) *
    --no-color  Disable colored output.
   --gruntfile  Specify an alternate Gruntfile. By default, grunt looks in the
                current or parent directories for the nearest Gruntfile.js or
                Gruntfile.coffee file.
   --debug, -d  Enable debugging mode for tasks that support it.
       --stack  Print a stack trace when exiting with a warning or fatal error.
   --force, -f  A way to force your way past warnings. Want a suggestion? Don't
                use this option, fix your code.
       --tasks  Additional directory paths to scan for task and "extra" files.
                (grunt.loadTasks) *
         --npm  Npm-installed grunt plugins to scan for task and "extra" files.
                (grunt.loadNpmTasks) *
    --no-write  Disable writing files (dry run).
 --verbose, -v  Verbose mode. A lot more information output.
 --version, -V  Print the grunt version. Combine with --verbose for more info.
  --completion  Output shell auto-completion rules. See the grunt-cli
                documentation for more information.

Options marked with * have methods exposed via the grunt API and should instead
be specified inside the Gruntfile wherever possible.

Available tasks
  autoprefixer  Prefix CSS files. *
    concurrent  Run grunt tasks concurrently *
         clean  Clean files and folders. *
       compass  Compile Sass to CSS using Compass *
        concat  Concatenate files. *
       connect  Start a connect web server. *
          copy  Copy files. *
        cssmin  Minify CSS *
       htmlmin  Minify HTML *
      imagemin  Minify PNG, JPEG, GIF and SVG images *
        jshint  Validate files with JSHint. *
        uglify  Minify files with UglifyJS. *
         watch  Run predefined tasks whenever watched files change.
       filerev  File revisioning based on content hashing *
        cdnify  Replace scripts with refs to the Google CDN *
         karma  run karma. *
         newer  Run a task with only those source files that have been modified
                since the last successful run.
     any-newer  DEPRECATED TASK.  Use the "newer" task instead
 newer-postrun  Internal task.
   newer-clean  Remove cached timestamps.
    ngAnnotate  Add, remove and rebuild AngularJS dependency injection
                annotations *
    ngconstant  Dynamic angular constant generator task. *
        svgmin  Minify SVG *
        usemin  Replaces references to non-minified scripts / stylesheets *
 useminPrepare  Using HTML markup as the primary source of information *
       wiredep  Inject Bower components into your source code. *
         serve  Compile then start a connect web server
        server  DEPRECATED TASK. Use the "serve" task instead
          test  Alias for "clean:server", "ngconstant:test", "wiredep",
                "concurrent:test", "autoprefixer", "connect:test", "karma"
                tasks.
         build  Alias for "ngconstant:production", "clean:dist", "wiredep",
                "useminPrepare", "concurrent:dist", "autoprefixer", "concat",
                "ngAnnotate", "copy:dist", "cdnify", "cssmin", "uglify",
                "filerev", "usemin", "htmlmin" tasks.
       default  Alias for "newer:jshint", "test", "build" tasks.

Tasks run in the order specified. Arguments may be passed to tasks that accept
them by using colons, like "lint:files". Tasks marked with * are "multi tasks"
and will iterate over all sub-targets if no argument is specified.

The list of available tasks may change based on tasks directories or grunt
plugins specified in the Gruntfile or via command-line options.

For more information, see http://gruntjs.com/
'''


@pytest.fixture(autouse=True)
def grunt_help(mocker):
    patch = mocker.patch('thefuck.rules.grunt_task_not_found.Popen')
    patch.return_value.stdout = BytesIO(grunt_help_stdout)
    return patch


@pytest.mark.parametrize('command', [
    Command('grunt defualt', output('defualt')),
    Command('grunt buld:css', output('buld:css'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('npm nuild', output('nuild')),
    Command('grunt rm', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (Command('grunt defualt', output('defualt')), 'grunt default'),
    (Command('grunt cmpass:all', output('cmpass:all')), 'grunt compass:all'),
    (Command('grunt cmpass:all --color', output('cmpass:all')),
     'grunt compass:all --color')])
def test_get_new_command(command, result):
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from thefuck.types import Command
from thefuck.rules.brew_uninstall import get_new_command, match


@pytest.fixture
def output():
    return ("Uninstalling /usr/local/Cellar/tbb/4.4-20160916... (118 files, 1.9M)\n"
            "tbb 4.4-20160526, 4.4-20160722 are still installed.\n"
            "Remove all versions with `brew uninstall --force tbb`.\n")


@pytest.fixture
def new_command(formula):
    return 'brew uninstall --force {}'.format(formula)


@pytest.mark.parametrize('script', ['brew uninstall tbb', 'brew rm tbb', 'brew remove tbb'])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['brew remove gnuplot'])
def test_not_match(script):
    output = 'Uninstalling /usr/local/Cellar/gnuplot/5.0.4_1... (44 files, 2.3M)\n'
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, formula, ', [('brew uninstall tbb', 'tbb')])
def test_get_new_command(output, new_command, script, formula):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.apt_upgrade import get_new_command, match
from thefuck.types import Command

match_output = '''
Listing... Done
heroku/stable 6.15.2-1 amd64 [upgradable from: 6.14.43-1]
resolvconf/zesty-updates,zesty-updates 1.79ubuntu4.1 all [upgradable from: 1.79ubuntu4]
squashfs-tools/zesty-updates 1:4.3-3ubuntu2.17.04.1 amd64 [upgradable from: 1:4.3-3ubuntu2]
unattended-upgrades/zesty-updates,zesty-updates 0.93.1ubuntu2.4 all [upgradable from: 0.93.1ubuntu2.3]
'''

no_match_output = '''
Listing... Done
'''


def test_match():
    assert match(Command('apt list --upgradable', match_output))
    assert match(Command('sudo apt list --upgradable', match_output))


@pytest.mark.parametrize('command', [
    Command('apt list --upgradable', no_match_output),
    Command('sudo apt list --upgradable', no_match_output)
])
def test_not_match(command):
    assert not match(command)


def test_get_new_command():
    new_command = get_new_command(Command('apt list --upgradable', match_output))
    assert new_command == 'apt upgrade'

    new_command = get_new_command(Command('sudo apt list --upgradable', match_output))
    assert new_command == 'sudo apt upgrade'
<EOF>
<BOF>
import pytest
from thefuck.types import Command
from thefuck.rules.brew_reinstall import get_new_command, match


output = ("Warning: thefuck 9.9 is already installed and up-to-date\nTo "
          "reinstall 9.9, run `brew reinstall thefuck`")


def test_match():
    command = Command('brew install thefuck', output)
    assert match(command)


@pytest.mark.parametrize('script', [
    'brew reinstall thefuck',
    'brew install foo'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, formula, ', [
    ('brew install foo', 'foo'),
    ('brew install bar zap', 'bar zap')])
def test_get_new_command(script, formula):
    command = Command(script, output)
    new_command = 'brew reinstall {}'.format(formula)
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.apt_get import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command, packages', [
    (Command('vim', 'vim: command not found'),
     [('vim', 'main'), ('vim-tiny', 'main')]),
    (Command('sudo vim', 'vim: command not found'),
     [('vim', 'main'), ('vim-tiny', 'main')]),
    (Command('vim', "The program 'vim' is currently not installed. You can install it by typing: sudo apt install vim"),
     [('vim', 'main'), ('vim-tiny', 'main')])])
def test_match(mocker, command, packages):
    mocker.patch('thefuck.rules.apt_get.which', return_value=None)
    mocker.patch('thefuck.rules.apt_get._get_packages',
                 create=True, return_value=packages)

    assert match(command)


@pytest.mark.parametrize('command, packages, which', [
    (Command('a_bad_cmd', 'a_bad_cmd: command not found'),
     [], None),
    (Command('vim', ''), [], None),
    (Command('', ''), [], None),
    (Command('vim', 'vim: command not found'),
     ['vim'], '/usr/bin/vim'),
    (Command('sudo vim', 'vim: command not found'),
     ['vim'], '/usr/bin/vim')])
def test_not_match(mocker, command, packages, which):
    mocker.patch('thefuck.rules.apt_get.which', return_value=which)
    mocker.patch('thefuck.rules.apt_get._get_packages',
                 create=True, return_value=packages)

    assert not match(command)


@pytest.mark.parametrize('command, new_command, packages', [
    (Command('vim', ''), 'sudo apt-get install vim && vim',
     [('vim', 'main'), ('vim-tiny', 'main')]),
    (Command('convert', ''), 'sudo apt-get install imagemagick && convert',
     [('imagemagick', 'main'),
      ('graphicsmagick-imagemagick-compat', 'universe')]),
    (Command('sudo vim', ''), 'sudo apt-get install vim && sudo vim',
     [('vim', 'main'), ('vim-tiny', 'main')]),
    (Command('sudo convert', ''), 'sudo apt-get install imagemagick && sudo convert',
     [('imagemagick', 'main'),
      ('graphicsmagick-imagemagick-compat', 'universe')])])
def test_get_new_command(mocker, command, new_command, packages):
    mocker.patch('thefuck.rules.apt_get._get_packages',
                 create=True, return_value=packages)

    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.composer_not_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def composer_not_command():
    # that weird spacing is part of the actual command output
    return (
        '\n'
        '\n'
        '                                    \n'
        '  [InvalidArgumentException]        \n'
        '  Command "udpate" is not defined.  \n'
        '  Did you mean this?                \n'
        '      update                        \n'
        '                                    \n'
        '\n'
        '\n'
    )


@pytest.fixture
def composer_not_command_one_of_this():
    # that weird spacing is part of the actual command output
    return (
        '\n'
        '\n'
        '                                   \n'
        '  [InvalidArgumentException]       \n'
        '  Command "pdate" is not defined.  \n'
        '  Did you mean one of these?       \n'
        '      selfupdate                   \n'
        '      self-update                  \n'
        '      update                       \n'
        '                                   \n'
        '\n'
        '\n'
    )


def test_match(composer_not_command, composer_not_command_one_of_this):
    assert match(Command('composer udpate',
                         composer_not_command))
    assert match(Command('composer pdate',
                         composer_not_command_one_of_this))
    assert not match(Command('ls update', composer_not_command))


def test_get_new_command(composer_not_command, composer_not_command_one_of_this):
    assert (get_new_command(Command('composer udpate',
                                    composer_not_command))
            == 'composer update')
    assert (get_new_command(Command('composer pdate',
                                    composer_not_command_one_of_this))
            == 'composer selfupdate')
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

import pytest
from thefuck.rules import switch_lang
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command(u'фзе-пуе', 'command not found: фзе-пуе'),
    Command(u'λσ', 'command not found: λσ'),
    Command(u'שפא-עקא', 'command not found: שפא-עקא'),
    Command(u'ךד', 'command not found: ךד')])
def test_match(command):
    assert switch_lang.match(command)


@pytest.mark.parametrize('command', [
    Command(u'pat-get', 'command not found: pat-get'),
    Command(u'ls', 'command not found: ls'),
    Command(u'агсл', 'command not found: агсл'),
    Command(u'фзе-пуе', 'some info'),
    Command(u'שפא-עקא', 'some info')])
def test_not_match(command):
    assert not switch_lang.match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command(u'фзе-пуе штыефдд мшь', ''), 'apt-get install vim'),
    (Command(u'λσ -λα', ''), 'ls -la'),
    (Command(u'שפא-עקא ןמדאשךך הןצ', ''), 'apt-get install vim'),
    (Command(u'ךד -ךש', ''), 'ls -la')])
def test_get_new_command(command, new_command):
    assert switch_lang.get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.tmux import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def tmux_ambiguous():
    return "ambiguous command: list, could be: " \
           "list-buffers, list-clients, list-commands, list-keys, " \
           "list-panes, list-sessions, list-windows"


def test_match(tmux_ambiguous):
    assert match(Command('tmux list', tmux_ambiguous))


def test_get_new_command(tmux_ambiguous):
    assert get_new_command(Command('tmux list', tmux_ambiguous))\
        == ['tmux list-keys', 'tmux list-panes', 'tmux list-windows']
<EOF>
<BOF>
import pytest

from thefuck.types import Command
from thefuck.rules.git_push_without_commits import (
    fix,
    get_new_command,
    match,
)

command = 'git push -u origin master'
expected_error = '''
error: src refspec master does not match any.
error: failed to push some refs to 'git@github.com:User/repo.git'
'''


@pytest.mark.parametrize('command', [Command(command, expected_error)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, result', [(
    Command(command, expected_error),
    fix.format(command=command),
)])
def test_get_new_command(command, result):
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from thefuck.rules.apt_list_upgradable import get_new_command, match
from thefuck.types import Command

match_output = '''
Hit:1 http://us.archive.ubuntu.com/ubuntu zesty InRelease
Hit:2 http://us.archive.ubuntu.com/ubuntu zesty-updates InRelease
Get:3 http://us.archive.ubuntu.com/ubuntu zesty-backports InRelease [89.2 kB]
Hit:4 http://security.ubuntu.com/ubuntu zesty-security InRelease
Hit:5 http://ppa.launchpad.net/ubuntu-mozilla-daily/ppa/ubuntu zesty InRelease
Hit:6 https://download.docker.com/linux/ubuntu zesty InRelease
Hit:7 https://cli-assets.heroku.com/branches/stable/apt ./ InRelease
Fetched 89.2 kB in 0s (122 kB/s)
Reading package lists... Done
Building dependency tree
Reading state information... Done
8 packages can be upgraded. Run 'apt list --upgradable' to see them.
'''

no_match_output = '''
Hit:1 http://us.archive.ubuntu.com/ubuntu zesty InRelease
Get:2 http://us.archive.ubuntu.com/ubuntu zesty-updates InRelease [89.2 kB]
Get:3 http://us.archive.ubuntu.com/ubuntu zesty-backports InRelease [89.2 kB]
Get:4 http://security.ubuntu.com/ubuntu zesty-security InRelease [89.2 kB]
Hit:5 https://cli-assets.heroku.com/branches/stable/apt ./ InRelease
Hit:6 http://ppa.launchpad.net/ubuntu-mozilla-daily/ppa/ubuntu zesty InRelease
Hit:7 https://download.docker.com/linux/ubuntu zesty InRelease
Get:8 http://us.archive.ubuntu.com/ubuntu zesty-updates/main i386 Packages [232 kB]
Get:9 http://us.archive.ubuntu.com/ubuntu zesty-updates/main amd64 Packages [235 kB]
Get:10 http://us.archive.ubuntu.com/ubuntu zesty-updates/main amd64 DEP-11 Metadata [55.2 kB]
Get:11 http://us.archive.ubuntu.com/ubuntu zesty-updates/main DEP-11 64x64 Icons [32.3 kB]
Get:12 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe amd64 Packages [156 kB]
Get:13 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe i386 Packages [156 kB]
Get:14 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe amd64 DEP-11 Metadata [175 kB]
Get:15 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe DEP-11 64x64 Icons [253 kB]
Get:16 http://us.archive.ubuntu.com/ubuntu zesty-updates/multiverse amd64 DEP-11 Metadata [5,840 B]
Get:17 http://us.archive.ubuntu.com/ubuntu zesty-backports/universe amd64 DEP-11 Metadata [4,588 B]
Get:18 http://security.ubuntu.com/ubuntu zesty-security/main amd64 DEP-11 Metadata [12.7 kB]
Get:19 http://security.ubuntu.com/ubuntu zesty-security/main DEP-11 64x64 Icons [17.6 kB]
Get:20 http://security.ubuntu.com/ubuntu zesty-security/universe amd64 DEP-11 Metadata [21.6 kB]
Get:21 http://security.ubuntu.com/ubuntu zesty-security/universe DEP-11 64x64 Icons [47.7 kB]
Get:22 http://security.ubuntu.com/ubuntu zesty-security/multiverse amd64 DEP-11 Metadata [208 B]
Fetched 1,673 kB in 0s (1,716 kB/s)
Reading package lists... Done
Building dependency tree
Reading state information... Done
All packages are up to date.
'''


def test_match():
    assert match(Command('sudo apt update', match_output))


@pytest.mark.parametrize('command', [
    Command('apt-cache search foo', ''),
    Command('aptitude search foo', ''),
    Command('apt search foo', ''),
    Command('apt-get install foo', ''),
    Command('apt-get source foo', ''),
    Command('apt-get clean', ''),
    Command('apt-get remove', ''),
    Command('apt-get update', ''),
    Command('sudo apt update', no_match_output)
])
def test_not_match(command):
    assert not match(command)


def test_get_new_command():
    new_command = get_new_command(Command('sudo apt update', match_output))
    assert new_command == 'sudo apt list --upgradable'

    new_command = get_new_command(Command('apt update', match_output))
    assert new_command == 'apt list --upgradable'
<EOF>
<BOF>
import pytest
from thefuck.rules.yarn_alias import match, get_new_command
from thefuck.types import Command


output_remove = 'error Did you mean `yarn remove`?'
output_etl = 'error Command "etil" not found. Did you mean "etl"?'
output_list = 'error Did you mean `yarn list`?'


@pytest.mark.parametrize('command', [
    Command('yarn rm', output_remove),
    Command('yarn etil', output_etl),
    Command('yarn ls', output_list)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('yarn rm', output_remove), 'yarn remove'),
    (Command('yarn etil', output_etl), 'yarn etl'),
    (Command('yarn ls', output_list), 'yarn list')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_merge_unrelated import match, get_new_command
from thefuck.types import Command


output = 'fatal: refusing to merge unrelated histories'


def test_match():
    assert match(Command('git merge test', output))
    assert not match(Command('git merge master', ''))
    assert not match(Command('ls', output))


@pytest.mark.parametrize('command, new_command', [
    (Command('git merge local', output),
     'git merge local --allow-unrelated-histories'),
    (Command('git merge -m "test" local', output),
     'git merge -m "test" local --allow-unrelated-histories'),
    (Command('git merge -m "test local" local', output),
     'git merge -m "test local" local --allow-unrelated-histories')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
from thefuck.rules.man_no_space import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('mandiff', 'mandiff: command not found'))
    assert not match(Command('', ''))


def test_get_new_command():
    assert get_new_command(Command('mandiff', '')) == 'man diff'
<EOF>
<BOF>
import pytest
from thefuck.rules.git_pull import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=<remote>/<branch> master

'''


def test_match(output):
    assert match(Command('git pull', output))
    assert not match(Command('git pull', ''))
    assert not match(Command('ls', output))


def test_get_new_command(output):
    assert (get_new_command(Command('git pull', output))
            == "git branch --set-upstream-to=origin/master master && git pull")
<EOF>
<BOF>
import pytest
from six import BytesIO
from thefuck.rules.ifconfig_device_not_found import match, get_new_command
from thefuck.types import Command


output = '{}: error fetching interface information: Device not found'

stdout = b'''
wlp2s0    Link encap:Ethernet  HWaddr 5c:51:4f:7c:58:5d
          inet addr:192.168.0.103  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::be23:69b9:96d2:6d39/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:23581604 errors:0 dropped:0 overruns:0 frame:0
          TX packets:17017655 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:16148429061 (16.1 GB)  TX bytes:7067533695 (7.0 GB)
'''


@pytest.fixture(autouse=True)
def ifconfig(mocker):
    mock = mocker.patch(
        'thefuck.rules.ifconfig_device_not_found.subprocess.Popen')
    mock.return_value.stdout = BytesIO(stdout)
    return mock


@pytest.mark.parametrize('script, output', [
    ('ifconfig wlan0', output.format('wlan0')),
    ('ifconfig -s eth0', output.format('eth0')),
])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('config wlan0',
     'wlan0: error fetching interface information: Device not found'),
    ('ifconfig eth0', ''),
])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, result', [
    ('ifconfig wlan0', ['ifconfig wlp2s0']),
    ('ifconfig -s wlan0', ['ifconfig -s wlp2s0']),
])
def test_get_new_comman(script, result):
    new_command = get_new_command(
        Command(script, output.format('wlan0')))
    assert new_command == result
<EOF>
<BOF>
import pytest
from thefuck.rules.mkdir_p import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('mkdir foo/bar/baz', 'mkdir: foo/bar: No such file or directory'),
    Command('./bin/hdfs dfs -mkdir foo/bar/baz', 'mkdir: `foo/bar/baz\': No such file or directory'),
    Command('hdfs dfs -mkdir foo/bar/baz', 'mkdir: `foo/bar/baz\': No such file or directory')
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('mkdir foo/bar/baz', ''),
    Command('mkdir foo/bar/baz', 'foo bar baz'),
    Command('hdfs dfs -mkdir foo/bar/baz', ''),
    Command('./bin/hdfs dfs -mkdir foo/bar/baz', ''),
    Command('', ''),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('mkdir foo/bar/baz', ''), 'mkdir -p foo/bar/baz'),
    (Command('hdfs dfs -mkdir foo/bar/baz', ''), 'hdfs dfs -mkdir -p foo/bar/baz'),
    (Command('./bin/hdfs dfs -mkdir foo/bar/baz', ''), './bin/hdfs dfs -mkdir -p foo/bar/baz'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_push_different_branch_names import get_new_command, match
from thefuck.types import Command


output = """fatal: The upstream branch of your current branch does not match
the name of your current branch.  To push to the upstream branch
on the remote, use

    git push origin HEAD:%s

To push to the branch of the same name on the remote, use

    git push origin %s

To choose either option permanently, see push.default in 'git help config'.
"""


def error_msg(localbranch, remotebranch):
    return output % (remotebranch, localbranch)


def test_match():
    assert match(Command('git push', error_msg('foo', 'bar')))


@pytest.mark.parametrize('command', [
    Command('vim', ''),
    Command('git status', error_msg('foo', 'bar')),
    Command('git push', '')
])
def test_not_match(command):
    assert not match(command)


def test_get_new_command():
    new_command = get_new_command(Command('git push', error_msg('foo', 'bar')))
    assert new_command == 'git push origin HEAD:bar'
<EOF>
<BOF>
import pytest
from thefuck.rules.git_rebase_no_changes import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''Applying: Test commit
No changes - did you forget to use 'git add'?
If there is nothing left to stage, chances are that something else
already introduced the same changes; you might want to skip this patch.

When you have resolved this problem, run "git rebase --continue".
If you prefer to skip this patch, run "git rebase --skip" instead.
To check out the original branch and stop rebasing, run "git rebase --abort".

'''


def test_match(output):
    assert match(Command('git rebase --continue', output))
    assert not match(Command('git rebase --continue', ''))
    assert not match(Command('git rebase --skip', ''))


def test_get_new_command(output):
    assert (get_new_command(Command('git rebase --continue', output)) ==
            'git rebase --skip')
<EOF>
<BOF>
import pytest
from thefuck.rules.vagrant_up import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('vagrant ssh', 'VM must be running to open SSH connection. Run `vagrant up`\nto start the virtual machine.'),
    Command('vagrant ssh devbox', 'VM must be running to open SSH connection. Run `vagrant up`\nto start the virtual machine.'),
    Command('vagrant rdp',
            'VM must be created before running this command. Run `vagrant up` first.'),
    Command('vagrant rdp devbox',
            'VM must be created before running this command. Run `vagrant up` first.')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('vagrant ssh', ''),
    Command('vagrant ssh jeff', 'The machine with the name \'jeff\' was not found configured for this Vagrant environment.'),
    Command('vagrant ssh', 'A Vagrant environment or target machine is required to run this command. Run `vagrant init` to create a new Vagrant environment. Or, get an ID of a target machine from `vagrant global-status` to run this command on. A final option is to change to a directory with a Vagrantfile and to try again.'),
    Command('', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('vagrant ssh', 'VM must be running to open SSH connection. Run `vagrant up`\nto start the virtual machine.'), 'vagrant up && vagrant ssh'),
    (Command('vagrant ssh devbox', 'VM must be running to open SSH connection. Run `vagrant up`\nto start the virtual machine.'), ['vagrant up devbox && vagrant ssh devbox', 'vagrant up && vagrant ssh devbox']),
    (Command('vagrant rdp',
             'VM must be created before running this command. Run `vagrant up` first.'), 'vagrant up && vagrant rdp'),
    (Command('vagrant rdp devbox',
             'VM must be created before running this command. Run `vagrant up` first.'), ['vagrant up devbox && vagrant rdp devbox', 'vagrant up && vagrant rdp devbox'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.mvn_unknown_lifecycle_phase import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('mvn cle', '[ERROR] Unknown lifecycle phase "cle". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('mvn clean', """
[INFO] Scanning for projects...[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building test 0.2
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ test ---
[INFO] Deleting /home/mlk/code/test/target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.477s
[INFO] Finished at: Wed Aug 26 13:05:47 BST 2015
[INFO] Final Memory: 6M/240M
[INFO] ------------------------------------------------------------------------
"""),  # noqa
    Command('mvn --help', ''),
    Command('mvn -v', '')
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('mvn cle', '[ERROR] Unknown lifecycle phase "cle". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]'), ['mvn clean', 'mvn compile']),
    (Command('mvn claen package', '[ERROR] Unknown lifecycle phase "claen". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]'), ['mvn clean package'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from io import BytesIO
from thefuck.types import Command
from thefuck.rules.docker_not_command import get_new_command, match


@pytest.fixture
def docker_help(mocker):
    help = b'''Usage: docker [OPTIONS] COMMAND [arg...]

A self-sufficient runtime for linux containers.

Options:

  --api-cors-header=                   Set CORS headers in the remote API
  -b, --bridge=                        Attach containers to a network bridge
  --bip=                               Specify network bridge IP
  -D, --debug=false                    Enable debug mode
  -d, --daemon=false                   Enable daemon mode
  --default-gateway=                   Container default gateway IPv4 address
  --default-gateway-v6=                Container default gateway IPv6 address
  --default-ulimit=[]                  Set default ulimits for containers
  --dns=[]                             DNS server to use
  --dns-search=[]                      DNS search domains to use
  -e, --exec-driver=native             Exec driver to use
  --exec-opt=[]                        Set exec driver options
  --exec-root=/var/run/docker          Root of the Docker execdriver
  --fixed-cidr=                        IPv4 subnet for fixed IPs
  --fixed-cidr-v6=                     IPv6 subnet for fixed IPs
  -G, --group=docker                   Group for the unix socket
  -g, --graph=/var/lib/docker          Root of the Docker runtime
  -H, --host=[]                        Daemon socket(s) to connect to
  -h, --help=false                     Print usage
  --icc=true                           Enable inter-container communication
  --insecure-registry=[]               Enable insecure registry communication
  --ip=0.0.0.0                         Default IP when binding container ports
  --ip-forward=true                    Enable net.ipv4.ip_forward
  --ip-masq=true                       Enable IP masquerading
  --iptables=true                      Enable addition of iptables rules
  --ipv6=false                         Enable IPv6 networking
  -l, --log-level=info                 Set the logging level
  --label=[]                           Set key=value labels to the daemon
  --log-driver=json-file               Default driver for container logs
  --log-opt=map[]                      Set log driver options
  --mtu=0                              Set the containers network MTU
  -p, --pidfile=/var/run/docker.pid    Path to use for daemon PID file
  --registry-mirror=[]                 Preferred Docker registry mirror
  -s, --storage-driver=                Storage driver to use
  --selinux-enabled=false              Enable selinux support
  --storage-opt=[]                     Set storage driver options
  --tls=false                          Use TLS; implied by --tlsverify
  --tlscacert=~/.docker/ca.pem         Trust certs signed only by this CA
  --tlscert=~/.docker/cert.pem         Path to TLS certificate file
  --tlskey=~/.docker/key.pem           Path to TLS key file
  --tlsverify=false                    Use TLS and verify the remote
  --userland-proxy=true                Use userland proxy for loopback traffic
  -v, --version=false                  Print version information and quit

Commands:
    attach    Attach to a running container
    build     Build an image from a Dockerfile
    commit    Create a new image from a container's changes
    cp        Copy files/folders from a container's filesystem to the host path
    create    Create a new container
    diff      Inspect changes on a container's filesystem
    events    Get real time events from the server
    exec      Run a command in a running container
    export    Stream the contents of a container as a tar archive
    history   Show the history of an image
    images    List images
    import    Create a new filesystem image from the contents of a tarball
    info      Display system-wide information
    inspect   Return low-level information on a container or image
    kill      Kill a running container
    load      Load an image from a tar archive
    login     Register or log in to a Docker registry server
    logout    Log out from a Docker registry server
    logs      Fetch the logs of a container
    pause     Pause all processes within a container
    port      Lookup the public-facing port that is NAT-ed to PRIVATE_PORT
    ps        List containers
    pull      Pull an image or a repository from a Docker registry server
    push      Push an image or a repository to a Docker registry server
    rename    Rename an existing container
    restart   Restart a running container
    rm        Remove one or more containers
    rmi       Remove one or more images
    run       Run a command in a new container
    save      Save an image to a tar archive
    search    Search for an image on the Docker Hub
    start     Start a stopped container
    stats     Display a stream of a containers' resource usage statistics
    stop      Stop a running container
    tag       Tag an image into a repository
    top       Lookup the running processes of a container
    unpause   Unpause a paused container
    version   Show the Docker version information
    wait      Block until a container stops, then print its exit code

Run 'docker COMMAND --help' for more information on a command.
'''
    mock = mocker.patch('subprocess.Popen')
    mock.return_value.stdout = BytesIO(help)
    return mock


def output(cmd):
    return "docker: '{}' is not a docker command.\n" \
           "See 'docker --help'.".format(cmd)


def test_match():
    assert match(Command('docker pes', output('pes')))


@pytest.mark.parametrize('script, output', [
    ('docker ps', ''),
    ('cat pes', output('pes'))])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.usefixtures('docker_help')
@pytest.mark.parametrize('wrong, fixed', [
    ('pes', ['ps', 'push', 'pause']),
    ('tags', ['tag', 'stats', 'images'])])
def test_get_new_command(wrong, fixed):
    command = Command('docker {}'.format(wrong), output(wrong))
    assert get_new_command(command) == ['docker {}'.format(x) for x in fixed]
<EOF>
<BOF>
import pytest
from thefuck.rules.git_help_aliased import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('script, output', [
    ('git help st', "`git st' is aliased to `status'"),
    ('git help ds', "`git ds' is aliased to `diff --staged'")])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('git help status', "GIT-STATUS(1)...Git Manual...GIT-STATUS(1)"),
    ('git help diff', "GIT-DIFF(1)...Git Manual...GIT-DIFF(1)")])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, new_command', [
    ('git help st', "`git st' is aliased to `status'", 'git help status'),
    ('git help ds', "`git ds' is aliased to `diff --staged'", 'git help diff')])
def test_get_new_command(script, output, new_command):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
from thefuck.rules.git_branch_list import match, get_new_command
from thefuck.shells import shell
from thefuck.types import Command


def test_match():
    assert match(Command('git branch list', ''))


def test_not_match():
    assert not match(Command('', ''))
    assert not match(Command('git commit', ''))
    assert not match(Command('git branch', ''))
    assert not match(Command('git stash list', ''))


def test_get_new_command():
    assert (get_new_command(Command('git branch list', '')) ==
            shell.and_('git branch --delete list', 'git branch'))
<EOF>
<BOF>
import pytest
from thefuck.rules.brew_install import match, get_new_command
from thefuck.rules.brew_install import _get_formulas
from thefuck.types import Command


@pytest.fixture
def brew_no_available_formula():
    return '''Error: No available formula for elsticsearch '''


@pytest.fixture
def brew_install_no_argument():
    return '''This command requires a formula argument'''


@pytest.fixture
def brew_already_installed():
    return '''Warning: git-2.3.5 already installed'''


def _is_not_okay_to_test():
    return 'elasticsearch' not in _get_formulas()


@pytest.mark.skipif(_is_not_okay_to_test(),
                    reason='No need to run if there\'s no formula')
def test_match(brew_no_available_formula, brew_already_installed,
               brew_install_no_argument):
    assert match(Command('brew install elsticsearch',
                         brew_no_available_formula))
    assert not match(Command('brew install git',
                             brew_already_installed))
    assert not match(Command('brew install', brew_install_no_argument))


@pytest.mark.skipif(_is_not_okay_to_test(),
                    reason='No need to run if there\'s no formula')
def test_get_new_command(brew_no_available_formula):
    assert get_new_command(Command('brew install elsticsearch',
                                   brew_no_available_formula))\
        == 'brew install elasticsearch'

    assert get_new_command(Command('brew install aa',
                                   brew_no_available_formula))\
        != 'brew install aha'
<EOF>
<BOF>
import pytest
from thefuck.types import Command
from thefuck.rules.brew_link import get_new_command, match


@pytest.fixture
def output():
    return ("Error: Could not symlink bin/gcp\n"
            "Target /usr/local/bin/gcp\n"
            "already exists. You may want to remove it:\n"
            "  rm '/usr/local/bin/gcp'\n"
            "\n"
            "To force the link and overwrite all conflicting files:\n"
            "  brew link --overwrite coreutils\n"
            "\n"
            "To list all files that would be deleted:\n"
            "  brew link --overwrite --dry-run coreutils\n")


@pytest.fixture
def new_command(formula):
    return 'brew link --overwrite --dry-run {}'.format(formula)


@pytest.mark.parametrize('script', ['brew link coreutils', 'brew ln coreutils'])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['brew link coreutils'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, formula, ', [('brew link coreutils', 'coreutils')])
def test_get_new_command(output, new_command, script, formula):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_merge import match, get_new_command
from thefuck.types import Command


output = 'merge: local - not something we can merge\n\n' \
         'Did you mean this?\n\tremote/local'


def test_match():
    assert match(Command('git merge test', output))
    assert not match(Command('git merge master', ''))
    assert not match(Command('ls', output))


@pytest.mark.parametrize('command, new_command', [
    (Command('git merge local', output),
     'git merge remote/local'),
    (Command('git merge -m "test" local', output),
     'git merge -m "test" remote/local'),
    (Command('git merge -m "test local" local', output),
     'git merge -m "test local" remote/local')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.git_rm_local_modifications import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(target):
    return ('error: the following file has local modifications:\n    {}\n(use '
            '--cached to keep the file, or -f to force removal)').format(target)


@pytest.mark.parametrize('script, target', [
    ('git rm foo', 'foo'),
    ('git rm foo bar', 'bar')])
def test_match(output, script, target):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['git rm foo', 'git rm foo bar', 'git rm'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, target, new_command', [
    ('git rm foo', 'foo', ['git rm --cached foo', 'git rm -f foo']),
    ('git rm foo bar', 'bar', ['git rm --cached foo bar', 'git rm -f foo bar'])])
def test_get_new_command(output, script, target, new_command):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.ln_s_order import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def file_exists(mocker):
    return mocker.patch('os.path.exists', return_value=True)


get_output = "ln: failed to create symbolic link '{}': File exists".format


@pytest.mark.parametrize('script, output, exists', [
    ('ln dest source', get_output('source'), True),
    ('ls -s dest source', get_output('source'), True),
    ('ln -s dest source', '', True),
    ('ln -s dest source', get_output('source'), False)])
def test_not_match(file_exists, script, output, exists):
    file_exists.return_value = exists
    assert not match(Command(script, output))


@pytest.mark.usefixtures('file_exists')
@pytest.mark.parametrize('script, result', [
    ('ln -s dest source', 'ln -s source dest'),
    ('ln dest -s source', 'ln -s source dest'),
    ('ln dest source -s', 'ln source -s dest')])
def test_match(script, result):
    output = get_output('source')
    assert match(Command(script, output))
    assert get_new_command(Command(script, output)) == result
<EOF>
<BOF>
from thefuck.rules.ls_lah import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('ls', ''))
    assert match(Command('ls file.py', ''))
    assert match(Command('ls /opt', ''))
    assert not match(Command('ls -lah /opt', ''))
    assert not match(Command('pacman -S binutils', ''))
    assert not match(Command('lsof', ''))


def test_get_new_command():
    assert get_new_command(Command('ls file.py', '')) == 'ls -lah file.py'
    assert get_new_command(Command('ls', '')) == 'ls -lah'
<EOF>
<BOF>
import pytest
from thefuck.rules.git_branch_delete import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''error: The branch 'branch' is not fully merged.
If you are sure you want to delete it, run 'git branch -D branch'.

'''


def test_match(output):
    assert match(Command('git branch -d branch', output))
    assert not match(Command('git branch -d branch', ''))
    assert not match(Command('ls', output))


def test_get_new_command(output):
    assert get_new_command(Command('git branch -d branch', output))\
        == "git branch -D branch"
<EOF>
<BOF>
import pytest
from thefuck.rules.path_from_history import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def history(mocker):
    return mocker.patch(
        'thefuck.rules.path_from_history.get_valid_history_without_current',
        return_value=['cd /opt/java', 'ls ~/work/project/'])


@pytest.fixture(autouse=True)
def path_exists(mocker):
    path_mock = mocker.patch('thefuck.rules.path_from_history.Path')
    exists_mock = path_mock.return_value.expanduser.return_value.exists
    exists_mock.return_value = True
    return exists_mock


@pytest.mark.parametrize('script, output', [
    ('ls project', 'no such file or directory: project'),
    ('cd project', "can't cd to project"),
])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('myapp cats', 'no such file or directory: project'),
    ('cd project', ""),
])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, result', [
    ('ls project', 'no such file or directory: project', 'ls ~/work/project'),
    ('cd java', "can't cd to java", 'cd /opt/java'),
])
def test_get_new_command(script, output, result):
    new_command = get_new_command(Command(script, output))
    assert new_command[0] == result
<EOF>
<BOF>
import pytest
from six import BytesIO
from thefuck.rules.gem_unknown_command import match, get_new_command
from thefuck.types import Command

output = '''
ERROR:  While executing gem ... (Gem::CommandLineError)
    Unknown command {}
'''

gem_help_commands_stdout = b'''
GEM commands are:

    build             Build a gem from a gemspec
    cert              Manage RubyGems certificates and signing settings
    check             Check a gem repository for added or missing files
    cleanup           Clean up old versions of installed gems
    contents          Display the contents of the installed gems
    dependency        Show the dependencies of an installed gem
    environment       Display information about the RubyGems environment
    fetch             Download a gem and place it in the current directory
    generate_index    Generates the index files for a gem server directory
    help              Provide help on the 'gem' command
    install           Install a gem into the local repository
    list              Display local gems whose name matches REGEXP
    lock              Generate a lockdown list of gems
    mirror            Mirror all gem files (requires rubygems-mirror)
    open              Open gem sources in editor
    outdated          Display all gems that need updates
    owner             Manage gem owners of a gem on the push server
    pristine          Restores installed gems to pristine condition from files
                      located in the gem cache
    push              Push a gem up to the gem server
    query             Query gem information in local or remote repositories
    rdoc              Generates RDoc for pre-installed gems
    search            Display remote gems whose name matches REGEXP
    server            Documentation and gem repository HTTP server
    sources           Manage the sources and cache file RubyGems uses to search
                      for gems
    specification     Display gem specification (in yaml)
    stale             List gems along with access times
    uninstall         Uninstall gems from the local repository
    unpack            Unpack an installed gem to the current directory
    update            Update installed gems to the latest version
    which             Find the location of a library file you can require
    yank              Remove a pushed gem from the index

For help on a particular command, use 'gem help COMMAND'.

Commands may be abbreviated, so long as they are unambiguous.
e.g. 'gem i rake' is short for 'gem install rake'.

'''


@pytest.fixture(autouse=True)
def gem_help_commands(mocker):
    patch = mocker.patch('subprocess.Popen')
    patch.return_value.stdout = BytesIO(gem_help_commands_stdout)
    return patch


@pytest.mark.parametrize('script, command', [
    ('gem isntall jekyll', 'isntall'),
    ('gem last --local', 'last')])
def test_match(script, command):
    assert match(Command(script, output.format(command)))


@pytest.mark.parametrize('script, output', [
    ('gem install jekyll', ''),
    ('git log', output.format('log'))])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, result', [
    ('gem isntall jekyll', output.format('isntall'), 'gem install jekyll'),
    ('gem last --local', output.format('last'), 'gem list --local')])
def test_get_new_command(script, output, result):
    new_command = get_new_command(Command(script, output))
    assert new_command[0] == result
<EOF>
<BOF>
import pytest
from thefuck.rules.javac import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('javac foo', ''),
    Command('javac bar', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('javac foo', ''), 'javac foo.java'),
    (Command('javac bar', ''), 'javac bar.java')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest

from thefuck.types import Command
from thefuck.rules.tsuru_not_command import match, get_new_command


@pytest.mark.parametrize('command', [
    Command('tsuru log', (
        'tsuru: "tchururu" is not a tsuru command. See "tsuru help".\n'
        '\nDid you mean?\n'
        '\tapp-log\n'
        '\tlogin\n'
        '\tlogout\n'
    )),
    Command('tsuru app-l', (
        'tsuru: "tchururu" is not a tsuru command. See "tsuru help".\n'
        '\nDid you mean?\n'
        '\tapp-list\n'
        '\tapp-log\n'
    )),
    Command('tsuru user-list', (
        'tsuru: "tchururu" is not a tsuru command. See "tsuru help".\n'
        '\nDid you mean?\n'
        '\tteam-user-list\n'
    )),
    Command('tsuru targetlist', (
        'tsuru: "tchururu" is not a tsuru command. See "tsuru help".\n'
        '\nDid you mean?\n'
        '\ttarget-list\n'
    )),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('tsuru tchururu', (
        'tsuru: "tchururu" is not a tsuru command. See "tsuru help".\n'
        '\nDid you mean?\n'
    )),
    Command('tsuru version', 'tsuru version 0.16.0.'),
    Command('tsuru help', (
        'tsuru version 0.16.0.\n'
        '\nUsage: tsuru command [args]\n'
    )),
    Command('tsuru platform-list', (
        '- java\n'
        '- logstashgiro\n'
        '- newnode\n'
        '- nodejs\n'
        '- php\n'
        '- python\n'
        '- python3\n'
        '- ruby\n'
        '- ruby20\n'
        '- static\n'
    )),
    Command('tsuru env-get', 'Error: App thefuck not found.'),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_commands', [
    (Command('tsuru log', (
        'tsuru: "log" is not a tsuru command. See "tsuru help".\n'
        '\nDid you mean?\n'
        '\tapp-log\n'
        '\tlogin\n'
        '\tlogout\n'
    )), ['tsuru login', 'tsuru logout', 'tsuru app-log']),
    (Command('tsuru app-l', (
        'tsuru: "app-l" is not a tsuru command. See "tsuru help".\n'
        '\nDid you mean?\n'
        '\tapp-list\n'
        '\tapp-log\n'
    )), ['tsuru app-log', 'tsuru app-list']),
    (Command('tsuru user-list', (
        'tsuru: "user-list" is not a tsuru command. See "tsuru help".\n'
        '\nDid you mean?\n'
        '\tteam-user-list\n'
    )), ['tsuru team-user-list']),
    (Command('tsuru targetlist', (
        'tsuru: "targetlist" is not a tsuru command. See "tsuru help".\n'
        '\nDid you mean?\n'
        '\ttarget-list\n'
    )), ['tsuru target-list']),
])
def test_get_new_command(command, new_commands):
    assert get_new_command(command) == new_commands
<EOF>
<BOF>
import pytest
from thefuck.rules.prove_recursively import match, get_new_command
from thefuck.types import Command


output = '''Files=0, Tests=0,  0 wallclock secs ( 0.00 usr +  0.00 sys =  0.00 CPU)
Result: NOTESTS'''


@pytest.fixture
def isdir(mocker):
    return mocker.patch('thefuck.rules.prove_recursively'
                        '.os.path.isdir')


@pytest.mark.parametrize('script, output', [
    ('prove -lv t', output),
    ('prove app/t', output)])
def test_match(isdir, script, output):
    isdir.return_value = True
    command = Command(script, output)
    assert match(command)


@pytest.mark.parametrize('script, output, isdir_result', [
    ('prove -lv t', output, False),
    ('prove -r t', output, True),
    ('prove --recurse t', output, True)])
def test_not_match(isdir, script, output, isdir_result):
    isdir.return_value = isdir_result
    command = Command(script, output)
    assert not match(command)


@pytest.mark.parametrize('before, after', [
    ('prove -lv t', 'prove -r -lv t'),
    ('prove t', 'prove -r t')])
def test_get_new_command(before, after):
    command = Command(before, output)
    assert get_new_command(command) == after
<EOF>
<BOF>
import pytest
from thefuck.rules.git_not_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def git_not_command():
    return """git: 'brnch' is not a git command. See 'git --help'.

The most similar command is
branch
"""


@pytest.fixture
def git_not_command_one_of_this():
    return """git: 'st' is not a git command. See 'git --help'.

The most similar commands are
status
reset
stage
stash
stats
"""


@pytest.fixture
def git_not_command_closest():
    return '''git: 'tags' is not a git command. See 'git --help'.

The most similar commands are
\tstage
\ttag
'''


@pytest.fixture
def git_command():
    return "* master"


def test_match(git_not_command, git_command, git_not_command_one_of_this):
    assert match(Command('git brnch', git_not_command))
    assert match(Command('git st', git_not_command_one_of_this))
    assert not match(Command('ls brnch', git_not_command))
    assert not match(Command('git branch', git_command))


def test_get_new_command(git_not_command, git_not_command_one_of_this,
                         git_not_command_closest):
    assert (get_new_command(Command('git brnch', git_not_command))
            == ['git branch'])
    assert (get_new_command(Command('git st', git_not_command_one_of_this))
            == ['git stats', 'git stash', 'git stage'])
    assert (get_new_command(Command('git tags', git_not_command_closest))
            == ['git tag', 'git stage'])
<EOF>
<BOF>
import pytest
from thefuck.rules.ag_literal import get_new_command, match
from thefuck.types import Command


@pytest.fixture
def output():
    return ('ERR: Bad regex! pcre_compile() failed at position 1: missing )\n'
            'If you meant to search for a literal string, run ag with -Q\n')


@pytest.mark.parametrize('script', ['ag \\('])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['ag foo'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, new_cmd', [
    ('ag \\(', 'ag -Q \\(')])
def test_get_new_command(script, new_cmd, output):
    assert get_new_command((Command(script, output))) == new_cmd
<EOF>
<BOF>
import pytest
from thefuck.rules.git_flag_after_filename import match, get_new_command
from thefuck.types import Command

command1 = Command('git log README.md -p',
                   "fatal: bad flag '-p' used after filename")
command2 = Command('git log README.md -p CONTRIBUTING.md',
                   "fatal: bad flag '-p' used after filename")
command3 = Command('git log -p README.md --name-only',
                   "fatal: bad flag '--name-only' used after filename")
command4 = Command('git log README.md -p',
                   "fatal: option '-p' must come before non-option arguments")
command5 = Command('git log README.md -p CONTRIBUTING.md',
                   "fatal: option '-p' must come before non-option arguments")
command6 = Command('git log -p README.md --name-only',
                   "fatal: option '--name-only' must come before non-option arguments")


@pytest.mark.parametrize('command', [
    command1, command2, command3, command4, command5, command6])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git log README.md', ''),
    Command('git log -p README.md', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (command1, "git log -p README.md"),
    (command2, "git log -p README.md CONTRIBUTING.md"),
    (command3, "git log -p --name-only README.md"),
    (command4, "git log -p README.md"),
    (command5, "git log -p README.md CONTRIBUTING.md"),
    (command6, "git log -p --name-only README.md")])
def test_get_new_command(command, result):
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from thefuck.rules.git_add_force import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return ('The following paths are ignored by one of your .gitignore files:\n'
            'dist/app.js\n'
            'dist/background.js\n'
            'dist/options.js\n'
            'Use -f if you really want to add them.\n')


def test_match(output):
    assert match(Command('git add dist/*.js', output))
    assert not match(Command('git add dist/*.js', ''))


def test_get_new_command(output):
    assert (get_new_command(Command('git add dist/*.js', output))
            == "git add --force dist/*.js")
<EOF>
<BOF>
import pytest
from thefuck.rules.sudo import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('output', [
    'Permission denied',
    'permission denied',
    "npm ERR! Error: EACCES, unlink",
    'requested operation requires superuser privilege',
    'need to be root',
    'need root',
    'must be root',
    'You don\'t have access to the history DB.',
    "error: [Errno 13] Permission denied: '/usr/local/lib/python2.7/dist-packages/ipaddr.py'"])
def test_match(output):
    assert match(Command('', output))


def test_not_match():
    assert not match(Command('', ''))
    assert not match(Command('sudo ls', 'Permission denied'))


@pytest.mark.parametrize('before, after', [
    ('ls', 'sudo ls'),
    ('echo a > b', 'sudo sh -c "echo a > b"'),
    ('echo "a" >> b', 'sudo sh -c "echo \\"a\\" >> b"'),
    ('mkdir && touch a', 'sudo sh -c "mkdir && touch a"')])
def test_get_new_command(before, after):
    assert get_new_command(Command(before, '')) == after
<EOF>
<BOF>
from mock import patch
from thefuck.rules.has_exists_script import match, get_new_command
from thefuck.types import Command


def test_match():
    with patch('os.path.exists', return_value=True):
        assert match(Command('main', 'main: command not found'))
        assert match(Command('main --help',
                             'main: command not found'))
        assert not match(Command('main', ''))

    with patch('os.path.exists', return_value=False):
        assert not match(Command('main', 'main: command not found'))


def test_get_new_command():
    assert get_new_command(Command('main --help', '')) == './main --help'
<EOF>
<BOF>
import pytest
from thefuck.rules.unsudo import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('output', [
    'you cannot perform this operation as root'])
def test_match(output):
    assert match(Command('sudo ls', output))


def test_not_match():
    assert not match(Command('', ''))
    assert not match(Command('sudo ls', 'Permission denied'))
    assert not match(Command('ls', 'you cannot perform this operation as root'))


@pytest.mark.parametrize('before, after', [
    ('sudo ls', 'ls'),
    ('sudo pacaur -S helloworld', 'pacaur -S helloworld')])
def test_get_new_command(before, after):
    assert get_new_command(Command(before, '')) == after
<EOF>
<BOF>
from thefuck.rules.ls_all import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('ls', ''))
    assert not match(Command('ls', 'file.py\n'))


def test_get_new_command():
    assert get_new_command(Command('ls empty_dir', '')) == 'ls -A empty_dir'
    assert get_new_command(Command('ls', '')) == 'ls -A'
<EOF>
<BOF>
import pytest
from thefuck.rules.git_rm_staged import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(target):
    return ('error: the following file has changes staged in the index:\n    {}\n(use '
            '--cached to keep the file, or -f to force removal)').format(target)


@pytest.mark.parametrize('script, target', [
    ('git rm foo', 'foo'),
    ('git rm foo bar', 'bar')])
def test_match(output, script, target):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['git rm foo', 'git rm foo bar', 'git rm'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, target, new_command', [
    ('git rm foo', 'foo', ['git rm --cached foo', 'git rm -f foo']),
    ('git rm foo bar', 'bar', ['git rm --cached foo bar', 'git rm -f foo bar'])])
def test_get_new_command(output, script, target, new_command):
    assert get_new_command(Command(script, output)) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.unknown_command import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('./bin/hdfs dfs ls', 'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'),
    Command('hdfs dfs ls',
            'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'),
    Command('hdfs dfs ls /foo/bar', 'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('./bin/hdfs dfs -ls', ''),
    Command('./bin/hdfs dfs -ls /foo/bar', ''),
    Command('hdfs dfs -ls -R /foo/bar', ''),
    Command('', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('hdfs dfs ls',
             'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'), ['hdfs dfs -ls']),
    (Command('hdfs dfs rm /foo/bar',
             'rm: Unknown command\nDid you mean -rm?  This command begins with a dash.'), ['hdfs dfs -rm /foo/bar']),
    (Command('./bin/hdfs dfs ls -R /foo/bar',
             'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'), ['./bin/hdfs dfs -ls -R /foo/bar']),
    (Command('./bin/hdfs dfs -Dtest=fred ls -R /foo/bar',
             'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'), ['./bin/hdfs dfs -Dtest=fred -ls -R /foo/bar'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.django_south_merge import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''Running migrations for app:
 ! Migration app:0003_auto... should not have been applied before app:0002_auto__add_field_query_due_date_ but was.
Traceback (most recent call last):
  File "/home/nvbn/work/.../bin/python", line 42, in <module>
    exec(compile(__file__f.read(), __file__, "exec"))
  File "/home/nvbn/work/.../app/manage.py", line 34, in <module>
    execute_from_command_line(sys.argv)
  File "/home/nvbn/work/.../lib/django/core/management/__init__.py", line 443, in execute_from_command_line
    utility.execute()
  File "/home/nvbn/work/.../lib/django/core/management/__init__.py", line 382, in execute
    self.fetch_command(subcommand).run_from_argv(self.argv)
  File "/home/nvbn/work/.../lib/django/core/management/base.py", line 196, in run_from_argv
    self.execute(*args, **options.__dict__)
  File "/home/nvbn/work/.../lib/django/core/management/base.py", line 232, in execute
    output = self.handle(*args, **options)
  File "/home/nvbn/work/.../app/lib/south/management/commands/migrate.py", line 108, in handle
    ignore_ghosts = ignore_ghosts,
  File "/home/nvbn/work/.../app/lib/south/migration/__init__.py", line 207, in migrate_app
    raise exceptions.InconsistentMigrationHistory(problems)
south.exceptions.InconsistentMigrationHistory: Inconsistent migration history
The following options are available:
    --merge: will just attempt the migration ignoring any potential dependency conflicts.
'''


def test_match(output):
    assert match(Command('./manage.py migrate', output))
    assert match(Command('python manage.py migrate', output))
    assert not match(Command('./manage.py migrate', ''))
    assert not match(Command('app migrate', output))
    assert not match(Command('./manage.py test', output))


def test_get_new_command():
    assert (get_new_command(Command('./manage.py migrate auth', ''))
            == './manage.py migrate auth --merge')
<EOF>
<BOF>
import pytest
from mock import patch
from thefuck.rules import pacman_not_found
from thefuck.rules.pacman_not_found import match, get_new_command
from thefuck.types import Command

PKGFILE_OUTPUT_LLC = '''extra/llvm 3.6.0-5      /usr/bin/llc
extra/llvm35 3.5.2-13/usr/bin/llc'''


@pytest.mark.skipif(not getattr(pacman_not_found, 'enabled_by_default', True),
                    reason='Skip if pacman is not available')
@pytest.mark.parametrize('command', [
    Command('yaourt -S llc', 'error: target not found: llc'),
    Command('pacman llc', 'error: target not found: llc'),
    Command('sudo pacman llc', 'error: target not found: llc')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('yaourt -S llc', 'error: target not found: llc'),
    Command('pacman llc', 'error: target not found: llc'),
    Command('sudo pacman llc', 'error: target not found: llc')])
@patch('thefuck.specific.archlinux.subprocess')
def test_match_mocked(subp_mock, command):
    subp_mock.check_output.return_value = PKGFILE_OUTPUT_LLC
    assert match(command)


@pytest.mark.skipif(not getattr(pacman_not_found, 'enabled_by_default', True),
                    reason='Skip if pacman is not available')
@pytest.mark.parametrize('command, fixed', [
    (Command('yaourt -S llc', 'error: target not found: llc'), ['yaourt -S extra/llvm', 'yaourt -S extra/llvm35']),
    (Command('pacman -S llc', 'error: target not found: llc'), ['pacman -S extra/llvm', 'pacman -S extra/llvm35']),
    (Command('sudo pacman -S llc', 'error: target not found: llc'), ['sudo pacman -S extra/llvm', 'sudo pacman -S extra/llvm35'])])
def test_get_new_command(command, fixed):
    assert get_new_command(command) == fixed


@pytest.mark.parametrize('command, fixed', [
    (Command('yaourt -S llc', 'error: target not found: llc'), ['yaourt -S extra/llvm', 'yaourt -S extra/llvm35']),
    (Command('pacman -S llc', 'error: target not found: llc'), ['pacman -S extra/llvm', 'pacman -S extra/llvm35']),
    (Command('sudo pacman -S llc', 'error: target not found: llc'), ['sudo pacman -S extra/llvm', 'sudo pacman -S extra/llvm35'])])
@patch('thefuck.specific.archlinux.subprocess')
def test_get_new_command_mocked(subp_mock, command, fixed):
    subp_mock.check_output.return_value = PKGFILE_OUTPUT_LLC
    assert get_new_command(command) == fixed
<EOF>
<BOF>
import pytest
from thefuck.rules.man import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('man read', ''),
    Command('man 2 read', ''),
    Command('man 3 read', ''),
    Command('man -s2 read', ''),
    Command('man -s3 read', ''),
    Command('man -s 2 read', ''),
    Command('man -s 3 read', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('man', ''),
    Command('man ', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('man read', ''), ['man 3 read', 'man 2 read', 'read --help']),
    (Command('man missing', "No manual entry for missing\n"), ['missing --help']),
    (Command('man 2 read', ''), 'man 3 read'),
    (Command('man 3 read', ''), 'man 2 read'),
    (Command('man -s2 read', ''), 'man -s3 read'),
    (Command('man -s3 read', ''), 'man -s2 read'),
    (Command('man -s 2 read', ''), 'man -s 3 read'),
    (Command('man -s 3 read', ''), 'man -s 2 read')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

from io import BytesIO
import pytest
from thefuck.types import Command
from thefuck.rules.yarn_command_not_found import match, get_new_command

output = '''
error Command "{}" not found.
'''.format

yarn_help_stdout = b'''

  Usage: yarn [command] [flags]

  Options:

    -h, --help                      output usage information
    -V, --version                   output the version number
    --verbose                       output verbose messages on internal operations
    --offline                       trigger an error if any required dependencies are not available in local cache
    --prefer-offline                use network only if dependencies are not available in local cache
    --strict-semver                 
    --json                          
    --ignore-scripts                don't run lifecycle scripts
    --har                           save HAR output of network traffic
    --ignore-platform               ignore platform checks
    --ignore-engines                ignore engines check
    --ignore-optional               ignore optional dependencies
    --force                         ignore all caches
    --no-bin-links                  don't generate bin links when setting up packages
    --flat                          only allow one version of a package
    --prod, --production [prod]     
    --no-lockfile                   don't read or generate a lockfile
    --pure-lockfile                 don't generate a lockfile
    --frozen-lockfile               don't generate a lockfile and fail if an update is needed
    --link-duplicates               create hardlinks to the repeated modules in node_modules
    --global-folder <path>          
    --modules-folder <path>         rather than installing modules into the node_modules folder relative to the cwd, output them here
    --cache-folder <path>           specify a custom folder to store the yarn cache
    --mutex <type>[:specifier]      use a mutex to ensure only one yarn instance is executing
    --no-emoji                      disable emoji in output
    --proxy <host>                  
    --https-proxy <host>            
    --no-progress                   disable progress bar
    --network-concurrency <number>  maximum number of concurrent network requests

  Commands:

    - access
    - add
    - bin
    - cache
    - check
    - clean
    - config
    - generate-lock-entry
    - global
    - import
    - info
    - init
    - install
    - licenses
    - link
    - list
    - login
    - logout
    - outdated
    - owner
    - pack
    - publish
    - remove
    - run
    - tag
    - team
    - unlink
    - upgrade
    - upgrade-interactive
    - version
    - versions
    - why

  Run `yarn help COMMAND` for more information on specific commands.
  Visit https://yarnpkg.com/en/docs/cli/ to learn more about Yarn.
''' # noqa


@pytest.fixture(autouse=True)
def yarn_help(mocker):
    patch = mocker.patch('thefuck.rules.yarn_command_not_found.Popen')
    patch.return_value.stdout = BytesIO(yarn_help_stdout)
    return patch


@pytest.mark.parametrize('command', [
    Command('yarn whyy webpack', output('whyy'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('npm nuild', output('nuild')),
    Command('yarn install', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (Command('yarn whyy webpack', output('whyy')),
     'yarn why webpack'),
    (Command('yarn require lodash', output('require')),
     'yarn add lodash')])
def test_get_new_command(command, result):
    fixed_command = get_new_command(command)
    if isinstance(fixed_command, list):
        fixed_command = fixed_command[0]

    assert fixed_command == result
<EOF>
<BOF>
import pytest
from thefuck.rules.touch import match, get_new_command
from thefuck.types import Command


def output(is_bsd):
    if is_bsd:
        return "touch: /a/b/c: No such file or directory"
    return "touch: cannot touch '/a/b/c': No such file or directory"


@pytest.mark.parametrize('script, is_bsd', [
    ('touch /a/b/c', False),
    ('touch /a/b/c', True)])
def test_match(script, is_bsd):
    command = Command(script, output(is_bsd))
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('touch /a/b/c', ''),
    Command('ls /a/b/c', output(False))])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('script, is_bsd', [
    ('touch /a/b/c', False),
    ('touch /a/b/c', True)])
def test_get_new_command(script, is_bsd):
    command = Command(script, output(is_bsd))
    fixed_command = get_new_command(command)
    assert fixed_command == 'mkdir -p /a/b && touch /a/b/c'
<EOF>
<BOF>
import pytest
from thefuck.rules.missing_space_before_subcommand import (
    match, get_new_command)
from thefuck.types import Command


@pytest.fixture(autouse=True)
def all_executables(mocker):
    return mocker.patch(
        'thefuck.rules.missing_space_before_subcommand.get_all_executables',
        return_value=['git', 'ls', 'npm'])


@pytest.mark.parametrize('script', [
    'gitbranch', 'ls-la', 'npminstall'])
def test_match(script):
    assert match(Command(script, ''))


@pytest.mark.parametrize('script', ['git branch', 'vimfile'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, result', [
    ('gitbranch', 'git branch'),
    ('ls-la', 'ls -la'),
    ('npminstall webpack', 'npm install webpack')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, '')) == result
<EOF>
<BOF>
import pytest
from thefuck.rules.grep_arguments_order import get_new_command, match
from thefuck.types import Command

output = 'grep: {}: No such file or directory'.format


@pytest.fixture(autouse=True)
def os_path(monkeypatch):
    monkeypatch.setattr('os.path.isfile', lambda x: not x.startswith('-'))


@pytest.mark.parametrize('script, file', [
    ('grep test.py test', 'test'),
    ('grep -lir . test', 'test'),
    ('egrep test.py test', 'test'),
    ('egrep -lir . test', 'test')])
def test_match(script, file):
    assert match(Command(script, output(file)))


@pytest.mark.parametrize('script, output', [
    ('cat test.py', output('test')),
    ('grep test test.py', ''),
    ('grep -lir test .', ''),
    ('egrep test test.py', ''),
    ('egrep -lir test .', '')])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, result', [
    ('grep test.py test', output('test'), 'grep test test.py'),
    ('grep -lir . test', output('test'), 'grep -lir test .'),
    ('grep . test -lir', output('test'), 'grep test -lir .'),
    ('egrep test.py test', output('test'), 'egrep test test.py'),
    ('egrep -lir . test', output('test'), 'egrep -lir test .'),
    ('egrep . test -lir', output('test'), 'egrep test -lir .')])
def test_get_new_command(script, output, result):
    assert get_new_command(Command(script, output)) == result
<EOF>
<BOF>
import pytest
from io import BytesIO
from thefuck.rules.git_checkout import match, get_branches, get_new_command
from thefuck.types import Command


def did_not_match(target, did_you_forget=False):
    error = ("error: pathspec '{}' did not match any "
             "file(s) known to git.".format(target))
    if did_you_forget:
        error = ("{}\nDid you forget to 'git add'?'".format(error))
    return error


@pytest.fixture
def git_branch(mocker, branches):
    mock = mocker.patch('subprocess.Popen')
    mock.return_value.stdout = BytesIO(branches)
    return mock


@pytest.mark.parametrize('command', [
    Command('git checkout unknown', did_not_match('unknown')),
    Command('git commit unknown', did_not_match('unknown'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git submodule update unknown',
            did_not_match('unknown', True)),
    Command('git checkout known', ''),
    Command('git commit known', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('branches, branch_list', [
    (b'', []),
    (b'* master', ['master']),
    (b'  remotes/origin/master', ['master']),
    (b'  just-another-branch', ['just-another-branch']),
    (b'* master\n  just-another-branch', ['master', 'just-another-branch']),
    (b'* master\n  remotes/origin/master\n  just-another-branch',
     ['master', 'master', 'just-another-branch'])])
def test_get_branches(branches, branch_list, git_branch):
    git_branch(branches)
    assert list(get_branches()) == branch_list


@pytest.mark.parametrize('branches, command, new_command', [
    (b'',
     Command('git checkout unknown', did_not_match('unknown')),
     'git checkout -b unknown'),
    (b'',
     Command('git commit unknown', did_not_match('unknown')),
     'git branch unknown && git commit unknown'),
    (b'  test-random-branch-123',
     Command('git checkout tst-rdm-brnch-123',
             did_not_match('tst-rdm-brnch-123')),
     'git checkout test-random-branch-123'),
    (b'  test-random-branch-123',
     Command('git commit tst-rdm-brnch-123',
             did_not_match('tst-rdm-brnch-123')),
     'git commit test-random-branch-123')])
def test_get_new_command(branches, command, new_command, git_branch):
    git_branch(branches)
    assert get_new_command(command) == new_command
<EOF>
<BOF>
import pytest
from thefuck.rules.fab_command_not_found import match, get_new_command
from thefuck.types import Command

output = '''
Warning: Command(s) not found:
    extenson
    deloyp

Available commands:

    update_config
    prepare_extension
    Template               A string class for supporting $-substitutions.
    deploy
    glob                   Return a list of paths matching a pathname pattern.
    install_web
    set_version
'''


@pytest.mark.parametrize('command', [
    Command('fab extenson', output),
    Command('fab deloyp', output),
    Command('fab extenson deloyp', output)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('gulp extenson', output),
    Command('fab deloyp', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('script, result', [
    ('fab extenson', 'fab prepare_extension'),
    ('fab extenson:version=2016',
     'fab prepare_extension:version=2016'),
    ('fab extenson:version=2016 install_web set_version:val=0.5.0',
     'fab prepare_extension:version=2016 install_web set_version:val=0.5.0'),
    ('fab extenson:version=2016 deloyp:beta=true -H the.fuck',
     'fab prepare_extension:version=2016 deploy:beta=true -H the.fuck'),
])
def test_get_new_command(script, result):
    command = Command(script, output)
    assert get_new_command(command) == result
<EOF>
<BOF>
import pytest
from mock import Mock
from thefuck.entrypoints.fix_command import _get_raw_command


class TestGetRawCommand(object):
    def test_from_force_command_argument(self):
        known_args = Mock(force_command=['git', 'brunch'])
        assert _get_raw_command(known_args) == ['git', 'brunch']

    def test_from_command_argument(self, os_environ):
        os_environ['TF_HISTORY'] = None
        known_args = Mock(force_command=None,
                          command=['sl'])
        assert _get_raw_command(known_args) == ['sl']

    @pytest.mark.parametrize('history, result', [
        ('git br', 'git br'),
        ('git br\nfcuk', 'git br'),
        ('git br\nfcuk\nls', 'ls'),
        ('git br\nfcuk\nls\nfuk', 'ls')])
    def test_from_history(self, os_environ, history, result):
        os_environ['TF_HISTORY'] = history
        known_args = Mock(force_command=None,
                          command=None)
        assert _get_raw_command(known_args) == [result]
<EOF>
<BOF>
from mock import Mock
import pytest
from thefuck.entrypoints.alias import _get_alias


@pytest.mark.parametrize(
    'py2, enable_experimental_instant_mode, which, is_instant', [
        (False, True, True, True),
        (False, False, True, False),
        (False, True, False, False),
        (True, True, True, False),
        (True, True, False, False),
        (True, False, True, False)])
def test_get_alias(monkeypatch, mocker, py2,
                   enable_experimental_instant_mode,
                   which, is_instant):
    monkeypatch.setattr('six.PY2', py2)
    args = Mock(
        enable_experimental_instant_mode=enable_experimental_instant_mode,
        alias='fuck', )
    mocker.patch('thefuck.entrypoints.alias.which', return_value=which)
    shell = Mock(app_alias=lambda _: 'app_alias',
                 instant_mode_alias=lambda _: 'instant_mode_alias')
    monkeypatch.setattr('thefuck.entrypoints.alias.shell', shell)

    alias = _get_alias(args)
    if is_instant:
        assert alias == 'instant_mode_alias'
    else:
        assert alias == 'app_alias'
<EOF>
<BOF>
import pytest
import json
from six import StringIO
from mock import MagicMock
from thefuck.shells.generic import ShellConfiguration
from thefuck.entrypoints.not_configured import main


@pytest.fixture(autouse=True)
def usage_tracker(mocker):
    return mocker.patch(
        'thefuck.entrypoints.not_configured._get_not_configured_usage_tracker_path',
        new_callable=MagicMock)


@pytest.fixture(autouse=True)
def usage_tracker_io(usage_tracker):
    io = StringIO()
    usage_tracker.return_value \
                 .open.return_value \
                 .__enter__.return_value = io
    return io


@pytest.fixture(autouse=True)
def usage_tracker_exists(usage_tracker):
    usage_tracker.return_value \
                 .exists.return_value = True
    return usage_tracker.return_value.exists


def _assert_tracker_updated(usage_tracker_io, pid):
    usage_tracker_io.seek(0)
    info = json.load(usage_tracker_io)
    assert info['pid'] == pid


def _change_tracker(usage_tracker_io, pid):
    usage_tracker_io.truncate(0)
    info = {'pid': pid, 'time': 0}
    json.dump(info, usage_tracker_io)
    usage_tracker_io.seek(0)


@pytest.fixture(autouse=True)
def shell_pid(mocker):
    return mocker.patch('thefuck.entrypoints.not_configured._get_shell_pid',
                        new_callable=MagicMock)


@pytest.fixture(autouse=True)
def shell(mocker):
    shell = mocker.patch('thefuck.entrypoints.not_configured.shell',
                         new_callable=MagicMock)
    shell.get_history.return_value = []
    shell.how_to_configure.return_value = ShellConfiguration(
        content='eval $(thefuck --alias)',
        path='/tmp/.bashrc',
        reload='bash',
        can_configure_automatically=True)
    return shell


@pytest.fixture(autouse=True)
def shell_config(mocker):
    path_mock = mocker.patch('thefuck.entrypoints.not_configured.Path',
                             new_callable=MagicMock)
    return path_mock.return_value \
        .expanduser.return_value \
        .open.return_value \
        .__enter__.return_value


@pytest.fixture(autouse=True)
def logs(mocker):
    return mocker.patch('thefuck.entrypoints.not_configured.logs',
                        new_callable=MagicMock)


def test_for_generic_shell(shell, logs):
    shell.how_to_configure.return_value = None
    main()
    logs.how_to_configure_alias.assert_called_once()


def test_on_first_run(usage_tracker_io, usage_tracker_exists, shell_pid, logs):
    shell_pid.return_value = 12
    main()
    usage_tracker_exists.return_value = False
    _assert_tracker_updated(usage_tracker_io, 12)
    logs.how_to_configure_alias.assert_called_once()


def test_on_run_after_other_commands(usage_tracker_io, shell_pid, shell, logs):
    shell_pid.return_value = 12
    shell.get_history.return_value = ['fuck', 'ls']
    _change_tracker(usage_tracker_io, 12)
    main()
    logs.how_to_configure_alias.assert_called_once()


def test_on_first_run_from_current_shell(usage_tracker_io, shell_pid,
                                         shell, logs):
    shell.get_history.return_value = ['fuck']
    shell_pid.return_value = 12
    main()
    _assert_tracker_updated(usage_tracker_io, 12)
    logs.how_to_configure_alias.assert_called_once()


def test_when_cant_configure_automatically(shell_pid, shell, logs):
    shell_pid.return_value = 12
    shell.how_to_configure.return_value = ShellConfiguration(
        content='eval $(thefuck --alias)',
        path='/tmp/.bashrc',
        reload='bash',
        can_configure_automatically=False)
    main()
    logs.how_to_configure_alias.assert_called_once()


def test_when_already_configured(usage_tracker_io, shell_pid,
                                 shell, shell_config, logs):
    shell.get_history.return_value = ['fuck']
    shell_pid.return_value = 12
    _change_tracker(usage_tracker_io, 12)
    shell_config.read.return_value = 'eval $(thefuck --alias)'
    main()
    logs.already_configured.assert_called_once()


def test_when_successfully_configured(usage_tracker_io, shell_pid,
                                      shell, shell_config, logs):
    shell.get_history.return_value = ['fuck']
    shell_pid.return_value = 12
    _change_tracker(usage_tracker_io, 12)
    shell_config.read.return_value = ''
    main()
    shell_config.write.assert_any_call('eval $(thefuck --alias)')
    logs.configured_successfully.assert_called_once()
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

from mock import Mock, patch
from psutil import AccessDenied, TimeoutExpired

from thefuck.output_readers import rerun


class TestRerun(object):
    def setup_method(self, test_method):
        self.patcher = patch('thefuck.output_readers.rerun.Process')
        process_mock = self.patcher.start()
        self.proc_mock = process_mock.return_value = Mock()

    def teardown_method(self, test_method):
        self.patcher.stop()

    @patch('thefuck.output_readers.rerun._wait_output', return_value=False)
    @patch('thefuck.output_readers.rerun.Popen')
    def test_get_output(self, popen_mock, wait_output_mock):
        popen_mock.return_value.stdout.read.return_value = b'output'
        assert rerun.get_output('', '') is None
        wait_output_mock.assert_called_once()

    def test_wait_output_is_slow(self, settings):
        assert rerun._wait_output(Mock(), True)
        self.proc_mock.wait.assert_called_once_with(settings.wait_slow_command)

    def test_wait_output_is_not_slow(self, settings):
        assert rerun._wait_output(Mock(), False)
        self.proc_mock.wait.assert_called_once_with(settings.wait_command)

    @patch('thefuck.output_readers.rerun._kill_process')
    def test_wait_output_timeout(self, kill_process_mock):
        self.proc_mock.wait.side_effect = TimeoutExpired(3)
        self.proc_mock.children.return_value = []
        assert not rerun._wait_output(Mock(), False)
        kill_process_mock.assert_called_once_with(self.proc_mock)

    @patch('thefuck.output_readers.rerun._kill_process')
    def test_wait_output_timeout_children(self, kill_process_mock):
        self.proc_mock.wait.side_effect = TimeoutExpired(3)
        self.proc_mock.children.return_value = [Mock()] * 2
        assert not rerun._wait_output(Mock(), False)
        assert kill_process_mock.call_count == 3

    def test_kill_process(self):
        proc = Mock()
        rerun._kill_process(proc)
        proc.kill.assert_called_once_with()

    @patch('thefuck.output_readers.rerun.logs')
    def test_kill_process_access_denied(self, logs_mock):
        proc = Mock()
        proc.kill.side_effect = AccessDenied()
        rerun._kill_process(proc)
        proc.kill.assert_called_once_with()
        logs_mock.debug.assert_called_once()
<EOF>
<BOF>
import pytest


@pytest.fixture
def builtins_open(mocker):
    return mocker.patch('six.moves.builtins.open')


@pytest.fixture
def isfile(mocker):
    return mocker.patch('os.path.isfile', return_value=True)


@pytest.fixture
@pytest.mark.usefixtures('isfile')
def history_lines(mocker):
    def aux(lines):
        mock = mocker.patch('io.open')
        mock.return_value.__enter__ \
            .return_value.readlines.return_value = lines

    return aux


@pytest.fixture
def config_exists(mocker):
    path_mock = mocker.patch('thefuck.shells.generic.Path')
    return path_mock.return_value \
        .expanduser.return_value \
        .exists
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import pytest
from thefuck.shells import Fish


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestFish(object):
    @pytest.fixture
    def shell(self):
        return Fish()

    @pytest.fixture(autouse=True)
    def Popen(self, mocker):
        mock = mocker.patch('thefuck.shells.fish.Popen')
        mock.return_value.stdout.read.side_effect = [(
            b'cd\nfish_config\nfuck\nfunced\nfuncsave\ngrep\nhistory\nll\nls\n'
            b'man\nmath\npopd\npushd\nruby'),
            (b'alias fish_key_reader /usr/bin/fish_key_reader\nalias g git\n'
             b'alias alias_with_equal_sign=echo\ninvalid_alias'), b'func1\nfunc2', b'']
        return mock

    @pytest.mark.parametrize('key, value', [
        ('TF_OVERRIDDEN_ALIASES', 'cut,git,sed'),  # legacy
        ('THEFUCK_OVERRIDDEN_ALIASES', 'cut,git,sed'),
        ('THEFUCK_OVERRIDDEN_ALIASES', 'cut, git, sed'),
        ('THEFUCK_OVERRIDDEN_ALIASES', ' cut,\tgit,sed\n'),
        ('THEFUCK_OVERRIDDEN_ALIASES', '\ncut,\n\ngit,\tsed\r')])
    def test_get_overridden_aliases(self, shell, os_environ, key, value):
        os_environ[key] = value
        assert shell._get_overridden_aliases() == {'cd', 'cut', 'git', 'grep',
                                                   'ls', 'man', 'open', 'sed'}

    @pytest.mark.parametrize('before, after', [
        ('cd', 'cd'),
        ('pwd', 'pwd'),
        ('fuck', 'fish -ic "fuck"'),
        ('find', 'find'),
        ('funced', 'fish -ic "funced"'),
        ('grep', 'grep'),
        ('awk', 'awk'),
        ('math "2 + 2"', r'fish -ic "math \"2 + 2\""'),
        ('man', 'man'),
        ('open', 'open'),
        ('vim', 'vim'),
        ('ll', 'fish -ic "ll"'),
        ('ls', 'ls'),
        ('g', 'git')])
    def test_from_shell(self, before, after, shell):
        assert shell.from_shell(before) == after

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('foo', 'bar') == 'foo; and bar'

    def test_or_(self, shell):
        assert shell.or_('foo', 'bar') == 'foo; or bar'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {'fish_config': 'fish_config',
                                       'fuck': 'fuck',
                                       'funced': 'funced',
                                       'funcsave': 'funcsave',
                                       'history': 'history',
                                       'll': 'll',
                                       'math': 'math',
                                       'popd': 'popd',
                                       'pushd': 'pushd',
                                       'ruby': 'ruby',
                                       'g': 'git',
                                       'fish_key_reader': '/usr/bin/fish_key_reader',
                                       'alias_with_equal_sign': 'echo'}
        assert shell.get_aliases() == {'func1': 'func1', 'func2': 'func2'}

    def test_app_alias(self, shell):
        assert 'function fuck' in shell.app_alias('fuck')
        assert 'function FUCK' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')
        assert 'TF_SHELL=fish' in shell.app_alias('fuck')
        assert 'TF_ALIAS=fuck PYTHONIOENCODING' in shell.app_alias('fuck')
        assert 'PYTHONIOENCODING=utf-8 thefuck' in shell.app_alias('fuck')

    def test_app_alias_alter_history(self, settings, shell):
        settings.alter_history = True
        assert 'builtin history delete' in shell.app_alias('FUCK')
        assert 'builtin history merge' in shell.app_alias('FUCK')
        settings.alter_history = False
        assert 'builtin history delete' not in shell.app_alias('FUCK')
        assert 'builtin history merge' not in shell.app_alias('FUCK')

    def test_get_history(self, history_lines, shell):
        history_lines(['- cmd: ls', '  when: 1432613911',
                       '- cmd: rm', '  when: 1432613916'])
        assert list(shell.get_history()) == ['ls', 'rm']

    @pytest.mark.parametrize('entry, entry_utf8', [
        ('ls', '- cmd: ls\n   when: 1430707243\n'),
        (u'echo café', '- cmd: echo café\n   when: 1430707243\n')])
    def test_put_to_history(self, entry, entry_utf8, builtins_open, mocker, shell):
        mocker.patch('thefuck.shells.fish.time', return_value=1430707243.3517463)
        shell.put_to_history(entry)
        builtins_open.return_value.__enter__.return_value. \
            write.assert_called_once_with(entry_utf8)

    def test_how_to_configure(self, shell, config_exists):
        config_exists.return_value = True
        assert shell.how_to_configure().can_configure_automatically

    def test_how_to_configure_when_config_not_found(self, shell,
                                                    config_exists):
        config_exists.return_value = False
        assert not shell.how_to_configure().can_configure_automatically

    def test_info(self, shell, Popen):
        Popen.return_value.stdout.read.side_effect = [b'3.5.9']
        assert shell.info() == 'Fish Shell 3.5.9'
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import os
import pytest
from thefuck.shells.zsh import Zsh


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestZsh(object):
    @pytest.fixture
    def shell(self):
        return Zsh()

    @pytest.fixture(autouse=True)
    def shell_aliases(self):
        os.environ['TF_SHELL_ALIASES'] = (
            'fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1))\'\n'
            'l=\'ls -CF\'\n'
            'la=\'ls -A\'\n'
            'll=\'ls -alF\'')

    @pytest.mark.parametrize('before, after', [
        ('fuck', 'eval $(thefuck $(fc -ln -1 | tail -n 1))'),
        ('pwd', 'pwd'),
        ('ll', 'ls -alF')])
    def test_from_shell(self, before, after, shell):
        assert shell.from_shell(before) == after

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == 'ls && cd'

    def test_or_(self, shell):
        assert shell.or_('ls', 'cd') == 'ls || cd'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {
            'fuck': 'eval $(thefuck $(fc -ln -1 | tail -n 1))',
            'l': 'ls -CF',
            'la': 'ls -A',
            'll': 'ls -alF'}

    def test_app_alias(self, shell):
        assert 'fuck () {' in shell.app_alias('fuck')
        assert 'FUCK () {' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')
        assert 'PYTHONIOENCODING' in shell.app_alias('fuck')

    def test_app_alias_variables_correctly_set(self, shell):
        alias = shell.app_alias('fuck')
        assert "fuck () {" in alias
        assert 'TF_SHELL=zsh' in alias
        assert "TF_ALIAS=fuck" in alias
        assert 'PYTHONIOENCODING=utf-8' in alias
        assert 'TF_SHELL_ALIASES=$(alias)' in alias

    def test_get_history(self, history_lines, shell):
        history_lines([': 1432613911:0;ls', ': 1432613916:0;rm'])
        assert list(shell.get_history()) == ['ls', 'rm']

    def test_how_to_configure(self, shell, config_exists):
        config_exists.return_value = True
        assert shell.how_to_configure().can_configure_automatically

    def test_how_to_configure_when_config_not_found(self, shell,
                                                    config_exists):
        config_exists.return_value = False
        assert not shell.how_to_configure().can_configure_automatically

    def test_info(self, shell, mocker):
        patch = mocker.patch('thefuck.shells.zsh.Popen')
        patch.return_value.stdout.read.side_effect = [b'3.5.9']
        assert shell.info() == 'ZSH 3.5.9'
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import pytest
from thefuck.shells.tcsh import Tcsh


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestTcsh(object):
    @pytest.fixture
    def shell(self):
        return Tcsh()

    @pytest.fixture(autouse=True)
    def Popen(self, mocker):
        mock = mocker.patch('thefuck.shells.tcsh.Popen')
        mock.return_value.stdout.read.return_value = (
            b'fuck\teval $(thefuck $(fc -ln -1))\n'
            b'l\tls -CF\n'
            b'la\tls -A\n'
            b'll\tls -alF')
        return mock

    @pytest.mark.parametrize('before, after', [
        ('pwd', 'pwd'),
        ('fuck', 'eval $(thefuck $(fc -ln -1))'),
        ('awk', 'awk'),
        ('ll', 'ls -alF')])
    def test_from_shell(self, before, after, shell):
        assert shell.from_shell(before) == after

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == 'ls && cd'

    def test_or_(self, shell):
        assert shell.or_('ls', 'cd') == 'ls || cd'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {'fuck': 'eval $(thefuck $(fc -ln -1))',
                                       'l': 'ls -CF',
                                       'la': 'ls -A',
                                       'll': 'ls -alF'}

    def test_app_alias(self, shell):
        assert 'setenv TF_SHELL tcsh' in shell.app_alias('fuck')
        assert 'alias fuck' in shell.app_alias('fuck')
        assert 'alias FUCK' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')

    def test_get_history(self, history_lines, shell):
        history_lines(['ls', 'rm'])
        assert list(shell.get_history()) == ['ls', 'rm']

    def test_how_to_configure(self, shell, config_exists):
        config_exists.return_value = True
        assert shell.how_to_configure().can_configure_automatically

    def test_how_to_configure_when_config_not_found(self, shell,
                                                    config_exists):
        config_exists.return_value = False
        assert not shell.how_to_configure().can_configure_automatically
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import pytest
from thefuck.shells import Powershell


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestPowershell(object):
    @pytest.fixture
    def shell(self):
        return Powershell()

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == '(ls) -and (cd)'

    def test_app_alias(self, shell):
        assert 'function fuck' in shell.app_alias('fuck')
        assert 'function FUCK' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')

    def test_how_to_configure(self, shell):
        assert not shell.how_to_configure().can_configure_automatically
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import pytest
from thefuck.shells import Generic


class TestGeneric(object):
    @pytest.fixture
    def shell(self):
        return Generic()

    def test_from_shell(self, shell):
        assert shell.from_shell('pwd') == 'pwd'

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == 'ls && cd'

    def test_or_(self, shell):
        assert shell.or_('ls', 'cd') == 'ls || cd'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {}

    def test_app_alias(self, shell):
        assert 'alias fuck' in shell.app_alias('fuck')
        assert 'alias FUCK' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')
        assert 'TF_ALIAS=fuck PYTHONIOENCODING' in shell.app_alias('fuck')
        assert 'PYTHONIOENCODING=utf-8 thefuck' in shell.app_alias('fuck')

    def test_get_history(self, history_lines, shell):
        history_lines(['ls', 'rm'])
        # We don't know what to do in generic shell with history lines,
        # so just ignore them:
        assert list(shell.get_history()) == []

    def test_split_command(self, shell):
        assert shell.split_command('ls') == ['ls']
        assert shell.split_command(u'echo café') == [u'echo', u'café']

    def test_how_to_configure(self, shell):
        assert shell.how_to_configure() is None
<EOF>
<BOF>
# -*- coding: utf-8 -*-

import os
import pytest
from thefuck.shells import Bash


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestBash(object):
    @pytest.fixture
    def shell(self):
        return Bash()

    @pytest.fixture(autouse=True)
    def shell_aliases(self):
        os.environ['TF_SHELL_ALIASES'] = (
            'alias fuck=\'eval $(thefuck $(fc -ln -1))\'\n'
            'alias l=\'ls -CF\'\n'
            'alias la=\'ls -A\'\n'
            'alias ll=\'ls -alF\'')

    @pytest.mark.parametrize('before, after', [
        ('pwd', 'pwd'),
        ('fuck', 'eval $(thefuck $(fc -ln -1))'),
        ('awk', 'awk'),
        ('ll', 'ls -alF')])
    def test_from_shell(self, before, after, shell):
        assert shell.from_shell(before) == after

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == 'ls && cd'

    def test_or_(self, shell):
        assert shell.or_('ls', 'cd') == 'ls || cd'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {'fuck': 'eval $(thefuck $(fc -ln -1))',
                                       'l': 'ls -CF',
                                       'la': 'ls -A',
                                       'll': 'ls -alF'}

    def test_app_alias(self, shell):
        assert 'fuck () {' in shell.app_alias('fuck')
        assert 'FUCK () {' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')
        assert 'PYTHONIOENCODING' in shell.app_alias('fuck')

    def test_app_alias_variables_correctly_set(self, shell):
        alias = shell.app_alias('fuck')
        assert "fuck () {" in alias
        assert 'TF_SHELL=bash' in alias
        assert "TF_ALIAS=fuck" in alias
        assert 'PYTHONIOENCODING=utf-8' in alias
        assert 'TF_SHELL_ALIASES=$(alias)' in alias

    def test_get_history(self, history_lines, shell):
        history_lines(['ls', 'rm'])
        assert list(shell.get_history()) == ['ls', 'rm']

    def test_split_command(self, shell):
        command = 'git log -p'
        command_parts = ['git', 'log', '-p']
        assert shell.split_command(command) == command_parts

    def test_how_to_configure(self, shell, config_exists):
        config_exists.return_value = True
        assert shell.how_to_configure().can_configure_automatically

    def test_how_to_configure_when_config_not_found(self, shell,
                                                    config_exists):
        config_exists.return_value = False
        assert not shell.how_to_configure().can_configure_automatically

    def test_info(self, shell, mocker):
        patch = mocker.patch('thefuck.shells.bash.Popen')
        patch.return_value.stdout.read.side_effect = [b'3.5.9']
        assert shell.info() == 'Bash 3.5.9'
<EOF>
<BOF>
import pytest
from thefuck.specific.git import git_support
from thefuck.types import Command


@pytest.mark.parametrize('called, command, output', [
    ('git co', 'git checkout', "19:22:36.299340 git.c:282   trace: alias expansion: co => 'checkout'"),
    ('git com file', 'git commit --verbose file',
     "19:23:25.470911 git.c:282   trace: alias expansion: com => 'commit' '--verbose'")])
def test_git_support(called, command, output):
    @git_support
    def fn(command):
        return command.script

    assert fn(Command(called, output)) == command


@pytest.mark.parametrize('command, is_git', [
    ('git pull', True),
    ('hub pull', True),
    ('git push --set-upstream origin foo', True),
    ('hub push --set-upstream origin foo', True),
    ('ls', False),
    ('cat git', False),
    ('cat hub', False)])
def test_git_support_match(command, is_git):
    @git_support
    def fn(command):
        return True

    assert fn(Command(command, '')) == is_git
<EOF>
<BOF>
import pytest
from thefuck.specific.sudo import sudo_support
from thefuck.types import Command


@pytest.mark.parametrize('return_value, command, called, result', [
    ('ls -lah', 'sudo ls', 'ls', 'sudo ls -lah'),
    ('ls -lah', 'ls', 'ls', 'ls -lah'),
    (['ls -lah'], 'sudo ls', 'ls', ['sudo ls -lah']),
    (True, 'sudo ls', 'ls', True),
    (True, 'ls', 'ls', True),
    (False, 'sudo ls', 'ls', False),
    (False, 'ls', 'ls', False)])
def test_sudo_support(return_value, command, called, result):
    def fn(command):
        assert command == Command(called, '')
        return return_value

    assert sudo_support(fn)(Command(command, '')) == result
<EOF>
<BOF>
from io import BytesIO

import pytest
from thefuck.specific.npm import get_scripts

run_script_stdout = b'''
Lifecycle scripts included in code-view-web:
  test
    jest

available via `npm run-script`:
  build
    cp node_modules/ace-builds/src-min/ -a resources/ace/ && webpack --progress --colors -p --config ./webpack.production.config.js
  develop
    cp node_modules/ace-builds/src/ -a resources/ace/ && webpack-dev-server --progress --colors
  watch-test
    jest --verbose --watch

'''


@pytest.mark.usefixtures('no_memoize')
def test_get_scripts(mocker):
    patch = mocker.patch('thefuck.specific.npm.Popen')
    patch.return_value.stdout = BytesIO(run_script_stdout)
    assert get_scripts() == ['build', 'develop', 'watch-test']
<EOF>
<BOF>
import atexit
import os
import pickle
import re
import shelve
import sys
import six
from decorator import decorator
from difflib import get_close_matches as difflib_get_close_matches
from functools import wraps
from .logs import warn, exception
from .conf import settings
from .system import Path

DEVNULL = open(os.devnull, 'w')

if six.PY2:
    import anydbm
    shelve_open_error = anydbm.error
else:
    import dbm
    shelve_open_error = dbm.error


def memoize(fn):
    """Caches previous calls to the function."""
    memo = {}

    @wraps(fn)
    def wrapper(*args, **kwargs):
        if not memoize.disabled:
            key = pickle.dumps((args, kwargs))
            if key not in memo:
                memo[key] = fn(*args, **kwargs)
            value = memo[key]
        else:
            # Memoize is disabled, call the function
            value = fn(*args, **kwargs)

        return value

    return wrapper


memoize.disabled = False


@memoize
def which(program):
    """Returns `program` path or `None`."""
    try:
        from shutil import which

        return which(program)
    except ImportError:
        def is_exe(fpath):
            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

        fpath, fname = os.path.split(program)
        if fpath:
            if is_exe(program):
                return program
        else:
            for path in os.environ["PATH"].split(os.pathsep):
                path = path.strip('"')
                exe_file = os.path.join(path, program)
                if is_exe(exe_file):
                    return exe_file

        return None


def default_settings(params):
    """Adds default values to settings if it not presented.

    Usage:

        @default_settings({'apt': '/usr/bin/apt'})
        def match(command):
            print(settings.apt)

    """
    def _default_settings(fn, command):
        for k, w in params.items():
            settings.setdefault(k, w)
        return fn(command)
    return decorator(_default_settings)


def get_closest(word, possibilities, cutoff=0.6, fallback_to_first=True):
    """Returns closest match or just first from possibilities."""
    possibilities = list(possibilities)
    try:
        return difflib_get_close_matches(word, possibilities, 1, cutoff)[0]
    except IndexError:
        if fallback_to_first:
            return possibilities[0]


def get_close_matches(word, possibilities, n=None, cutoff=0.6):
    """Overrides `difflib.get_close_match` to controle argument `n`."""
    if n is None:
        n = settings.num_close_matches
    return difflib_get_close_matches(word, possibilities, n, cutoff)


@memoize
def get_all_executables():
    from thefuck.shells import shell

    def _safe(fn, fallback):
        try:
            return fn()
        except OSError:
            return fallback

    tf_alias = get_alias()
    tf_entry_points = ['thefuck', 'fuck']

    bins = [exe.name.decode('utf8') if six.PY2 else exe.name
            for path in os.environ.get('PATH', '').split(':')
            for exe in _safe(lambda: list(Path(path).iterdir()), [])
            if not _safe(exe.is_dir, True)
            and exe.name not in tf_entry_points]
    aliases = [alias.decode('utf8') if six.PY2 else alias
               for alias in shell.get_aliases() if alias != tf_alias]

    return bins + aliases


def replace_argument(script, from_, to):
    """Replaces command line argument."""
    replaced_in_the_end = re.sub(u' {}$'.format(re.escape(from_)), u' {}'.format(to),
                                 script, count=1)
    if replaced_in_the_end != script:
        return replaced_in_the_end
    else:
        return script.replace(
            u' {} '.format(from_), u' {} '.format(to), 1)


@decorator
def eager(fn, *args, **kwargs):
    return list(fn(*args, **kwargs))


@eager
def get_all_matched_commands(stderr, separator='Did you mean'):
    if not isinstance(separator, list):
        separator = [separator]
    should_yield = False
    for line in stderr.split('\n'):
        for sep in separator:
            if sep in line:
                should_yield = True
                break
        else:
            if should_yield and line:
                yield line.strip()


def replace_command(command, broken, matched):
    """Helper for *_no_command rules."""
    new_cmds = get_close_matches(broken, matched, cutoff=0.1)
    return [replace_argument(command.script, broken, new_cmd.strip())
            for new_cmd in new_cmds]


@memoize
def is_app(command, *app_names, **kwargs):
    """Returns `True` if command is call to one of passed app names."""

    at_least = kwargs.pop('at_least', 0)
    if kwargs:
        raise TypeError("got an unexpected keyword argument '{}'".format(kwargs.keys()))

    if len(command.script_parts) > at_least:
        return command.script_parts[0] in app_names

    return False


def for_app(*app_names, **kwargs):
    """Specifies that matching script is for on of app names."""
    def _for_app(fn, command):
        if is_app(command, *app_names, **kwargs):
            return fn(command)
        else:
            return False

    return decorator(_for_app)


class Cache(object):
    """Lazy read cache and save changes at exit."""

    def __init__(self):
        self._db = None

    def _init_db(self):
        try:
            self._setup_db()
        except Exception:
            exception("Unable to init cache", sys.exc_info())
            self._db = {}

    def _setup_db(self):
        cache_dir = self._get_cache_dir()
        cache_path = Path(cache_dir).joinpath('thefuck').as_posix()

        try:
            self._db = shelve.open(cache_path)
        except shelve_open_error + (ImportError,):
            # Caused when switching between Python versions
            warn("Removing possibly out-dated cache")
            os.remove(cache_path)
            self._db = shelve.open(cache_path)

        atexit.register(self._db.close)

    def _get_cache_dir(self):
        default_xdg_cache_dir = os.path.expanduser("~/.cache")
        cache_dir = os.getenv("XDG_CACHE_HOME", default_xdg_cache_dir)

        # Ensure the cache_path exists, Python 2 does not have the exist_ok
        # parameter
        try:
            os.makedirs(cache_dir)
        except OSError:
            if not os.path.isdir(cache_dir):
                raise

        return cache_dir

    def _get_mtime(self, path):
        try:
            return str(os.path.getmtime(path))
        except OSError:
            return '0'

    def _get_key(self, fn, depends_on, args, kwargs):
        parts = (fn.__module__, repr(fn).split('at')[0],
                 depends_on, args, kwargs)
        return str(pickle.dumps(parts))

    def get_value(self, fn, depends_on, args, kwargs):
        if self._db is None:
            self._init_db()

        depends_on = [Path(name).expanduser().absolute().as_posix()
                      for name in depends_on]
        key = self._get_key(fn, depends_on, args, kwargs)
        etag = '.'.join(self._get_mtime(path) for path in depends_on)

        if self._db.get(key, {}).get('etag') == etag:
            return self._db[key]['value']
        else:
            value = fn(*args, **kwargs)
            self._db[key] = {'etag': etag, 'value': value}
            return value


_cache = Cache()


def cache(*depends_on):
    """Caches function result in temporary file.

    Cache will be expired when modification date of files from `depends_on`
    will be changed.

    Only functions should be wrapped in `cache`, not methods.

    """
    def cache_decorator(fn):
        @memoize
        @wraps(fn)
        def wrapper(*args, **kwargs):
            if cache.disabled:
                return fn(*args, **kwargs)
            else:
                return _cache.get_value(fn, depends_on, args, kwargs)

        return wrapper

    return cache_decorator


cache.disabled = False


def get_installation_info():
    import pkg_resources

    return pkg_resources.require('thefuck')[0]


def get_alias():
    return os.environ.get('TF_ALIAS', 'fuck')


@memoize
def get_valid_history_without_current(command):
    def _not_corrected(history, tf_alias):
        """Returns all lines from history except that comes before `fuck`."""
        previous = None
        for line in history:
            if previous is not None and line != tf_alias:
                yield previous
            previous = line
        if history:
            yield history[-1]

    from thefuck.shells import shell
    history = shell.get_history()
    tf_alias = get_alias()
    executables = set(get_all_executables())\
        .union(shell.get_builtin_commands())

    return [line for line in _not_corrected(history, tf_alias)
            if not line.startswith(tf_alias) and not line == command.script
            and line.split(' ')[0] in executables]


def format_raw_script(raw_script):
    """Creates single script from a list of script parts.

    :type raw_script: [basestring]
    :rtype: basestring

    """
    if six.PY2:
        script = ' '.join(arg.decode('utf-8') for arg in raw_script)
    else:
        script = ' '.join(raw_script)

    return script.strip()
<EOF>
<BOF>
class EmptyCommand(Exception):
    """Raised when empty command passed to `thefuck`."""


class NoRuleMatched(Exception):
    """Raised when no rule matched for some command."""


class ScriptNotInLog(Exception):
    """Script not found in log."""
<EOF>
<BOF>
import sys
from argparse import ArgumentParser, SUPPRESS
from .const import ARGUMENT_PLACEHOLDER
from .utils import get_alias


class Parser(object):
    """Argument parser that can handle arguments with our special
    placeholder.

    """

    def __init__(self):
        self._parser = ArgumentParser(prog='thefuck', add_help=False)
        self._add_arguments()

    def _add_arguments(self):
        """Adds arguments to parser."""
        self._parser.add_argument(
            '-v', '--version',
            action='store_true',
            help="show program's version number and exit")
        self._parser.add_argument(
            '-a', '--alias',
            nargs='?',
            const=get_alias(),
            help='[custom-alias-name] prints alias for current shell')
        self._parser.add_argument(
            '-l', '--shell-logger',
            action='store',
            help='log shell output to the file')
        self._parser.add_argument(
            '--enable-experimental-instant-mode',
            action='store_true',
            help='enable experimental instant mode, use on your own risk')
        self._parser.add_argument(
            '-h', '--help',
            action='store_true',
            help='show this help message and exit')
        self._add_conflicting_arguments()
        self._parser.add_argument(
            '-d', '--debug',
            action='store_true',
            help='enable debug output')
        self._parser.add_argument(
            '--force-command',
            action='store',
            help=SUPPRESS)
        self._parser.add_argument(
            'command',
            nargs='*',
            help='command that should be fixed')

    def _add_conflicting_arguments(self):
        """It's too dangerous to use `-y` and `-r` together."""
        group = self._parser.add_mutually_exclusive_group()
        group.add_argument(
            '-y', '--yes', '--yeah',
            action='store_true',
            help='execute fixed command without confirmation')
        group.add_argument(
            '-r', '--repeat',
            action='store_true',
            help='repeat on failure')

    def _prepare_arguments(self, argv):
        """Prepares arguments by:

        - removing placeholder and moving arguments after it to beginning,
          we need this to distinguish arguments from `command` with ours;

        - adding `--` before `command`, so our parse would ignore arguments
          of `command`.

        """
        if ARGUMENT_PLACEHOLDER in argv:
            index = argv.index(ARGUMENT_PLACEHOLDER)
            return argv[index + 1:] + ['--'] + argv[:index]
        elif argv and not argv[0].startswith('-') and argv[0] != '--':
            return ['--'] + argv
        else:
            return argv

    def parse(self, argv):
        arguments = self._prepare_arguments(argv[1:])
        return self._parser.parse_args(arguments)

    def print_usage(self):
        self._parser.print_usage(sys.stderr)

    def print_help(self):
        self._parser.print_help(sys.stderr)
<EOF>
<BOF>
# -*- encoding: utf-8 -*-


class _GenConst(object):
    def __init__(self, name):
        self._name = name

    def __repr__(self):
        return u'<const: {}>'.format(self._name)


KEY_UP = _GenConst('↑')
KEY_DOWN = _GenConst('↓')
KEY_CTRL_C = _GenConst('Ctrl+C')
KEY_CTRL_N = _GenConst('Ctrl+N')
KEY_CTRL_P = _GenConst('Ctrl+P')

KEY_MAPPING = {'\x0e': KEY_CTRL_N,
               '\x03': KEY_CTRL_C,
               '\x10': KEY_CTRL_P}

ACTION_SELECT = _GenConst('select')
ACTION_ABORT = _GenConst('abort')
ACTION_PREVIOUS = _GenConst('previous')
ACTION_NEXT = _GenConst('next')

ALL_ENABLED = _GenConst('All rules enabled')
DEFAULT_RULES = [ALL_ENABLED]
DEFAULT_PRIORITY = 1000

DEFAULT_SETTINGS = {'rules': DEFAULT_RULES,
                    'exclude_rules': [],
                    'wait_command': 3,
                    'require_confirmation': True,
                    'no_colors': False,
                    'debug': False,
                    'priority': {},
                    'history_limit': None,
                    'alter_history': True,
                    'wait_slow_command': 15,
                    'slow_commands': ['lein', 'react-native', 'gradle',
                                      './gradlew', 'vagrant'],
                    'repeat': False,
                    'instant_mode': False,
                    'num_close_matches': 3,
                    'env': {'LC_ALL': 'C', 'LANG': 'C', 'GIT_TRACE': '1'}}

ENV_TO_ATTR = {'THEFUCK_RULES': 'rules',
               'THEFUCK_EXCLUDE_RULES': 'exclude_rules',
               'THEFUCK_WAIT_COMMAND': 'wait_command',
               'THEFUCK_REQUIRE_CONFIRMATION': 'require_confirmation',
               'THEFUCK_NO_COLORS': 'no_colors',
               'THEFUCK_DEBUG': 'debug',
               'THEFUCK_PRIORITY': 'priority',
               'THEFUCK_HISTORY_LIMIT': 'history_limit',
               'THEFUCK_ALTER_HISTORY': 'alter_history',
               'THEFUCK_WAIT_SLOW_COMMAND': 'wait_slow_command',
               'THEFUCK_SLOW_COMMANDS': 'slow_commands',
               'THEFUCK_REPEAT': 'repeat',
               'THEFUCK_INSTANT_MODE': 'instant_mode',
               'THEFUCK_NUM_CLOSE_MATCHES': 'num_close_matches'}

SETTINGS_HEADER = u"""# The Fuck settings file
#
# The rules are defined as in the example bellow:
#
# rules = ['cd_parent', 'git_push', 'python_command', 'sudo']
#
# The default values are as follows. Uncomment and change to fit your needs.
# See https://github.com/nvbn/thefuck#settings for more information.
#

"""

ARGUMENT_PLACEHOLDER = 'THEFUCK_ARGUMENT_PLACEHOLDER'

CONFIGURATION_TIMEOUT = 60

USER_COMMAND_MARK = u'\u200B' * 10

LOG_SIZE_IN_BYTES = 1024 * 1024

LOG_SIZE_TO_CLEAN = 10 * 1024

DIFF_WITH_ALIAS = 0.5

SHELL_LOGGER_SOCKET_ENV = 'SHELL_LOGGER_SOCKET'

SHELL_LOGGER_LIMIT = 5
<EOF>
<BOF>
from imp import load_source
import os
import sys
from warnings import warn
from six import text_type
from . import const
from .system import Path


class Settings(dict):
    def __getattr__(self, item):
        return self.get(item)

    def __setattr__(self, key, value):
        self[key] = value

    def init(self, args=None):
        """Fills `settings` with values from `settings.py` and env."""
        from .logs import exception

        self._setup_user_dir()
        self._init_settings_file()

        try:
            self.update(self._settings_from_file())
        except Exception:
            exception("Can't load settings from file", sys.exc_info())

        try:
            self.update(self._settings_from_env())
        except Exception:
            exception("Can't load settings from env", sys.exc_info())

        self.update(self._settings_from_args(args))

    def _init_settings_file(self):
        settings_path = self.user_dir.joinpath('settings.py')
        if not settings_path.is_file():
            with settings_path.open(mode='w') as settings_file:
                settings_file.write(const.SETTINGS_HEADER)
                for setting in const.DEFAULT_SETTINGS.items():
                    settings_file.write(u'# {} = {}\n'.format(*setting))

    def _get_user_dir_path(self):
        """Returns Path object representing the user config resource"""
        xdg_config_home = os.environ.get('XDG_CONFIG_HOME', '~/.config')
        user_dir = Path(xdg_config_home, 'thefuck').expanduser()
        legacy_user_dir = Path('~', '.thefuck').expanduser()

        # For backward compatibility use legacy '~/.thefuck' if it exists:
        if legacy_user_dir.is_dir():
            warn(u'Config path {} is deprecated. Please move to {}'.format(
                legacy_user_dir, user_dir))
            return legacy_user_dir
        else:
            return user_dir

    def _setup_user_dir(self):
        """Returns user config dir, create it when it doesn't exist."""
        user_dir = self._get_user_dir_path()

        rules_dir = user_dir.joinpath('rules')
        if not rules_dir.is_dir():
            rules_dir.mkdir(parents=True)
        self.user_dir = user_dir

    def _settings_from_file(self):
        """Loads settings from file."""
        settings = load_source(
            'settings', text_type(self.user_dir.joinpath('settings.py')))
        return {key: getattr(settings, key)
                for key in const.DEFAULT_SETTINGS.keys()
                if hasattr(settings, key)}

    def _rules_from_env(self, val):
        """Transforms rules list from env-string to python."""
        val = val.split(':')
        if 'DEFAULT_RULES' in val:
            val = const.DEFAULT_RULES + [rule for rule in val if rule != 'DEFAULT_RULES']
        return val

    def _priority_from_env(self, val):
        """Gets priority pairs from env."""
        for part in val.split(':'):
            try:
                rule, priority = part.split('=')
                yield rule, int(priority)
            except ValueError:
                continue

    def _val_from_env(self, env, attr):
        """Transforms env-strings to python."""
        val = os.environ[env]
        if attr in ('rules', 'exclude_rules'):
            return self._rules_from_env(val)
        elif attr == 'priority':
            return dict(self._priority_from_env(val))
        elif attr in ('wait_command', 'history_limit', 'wait_slow_command',
                      'num_close_matches'):
            return int(val)
        elif attr in ('require_confirmation', 'no_colors', 'debug',
                      'alter_history', 'instant_mode'):
            return val.lower() == 'true'
        elif attr == 'slow_commands':
            return val.split(':')
        else:
            return val

    def _settings_from_env(self):
        """Loads settings from env."""
        return {attr: self._val_from_env(env, attr)
                for env, attr in const.ENV_TO_ATTR.items()
                if env in os.environ}

    def _settings_from_args(self, args):
        """Loads settings from args."""
        if not args:
            return {}

        from_args = {}
        if args.yes:
            from_args['require_confirmation'] = not args.yes
        if args.debug:
            from_args['debug'] = args.debug
        if args.repeat:
            from_args['repeat'] = args.repeat
        return from_args


settings = Settings(const.DEFAULT_SETTINGS)
<EOF>
<BOF>
from imp import load_source
import os
import sys
from . import logs
from .shells import shell
from .conf import settings
from .const import DEFAULT_PRIORITY, ALL_ENABLED
from .exceptions import EmptyCommand
from .utils import get_alias, format_raw_script
from .output_readers import get_output


class Command(object):
    """Command that should be fixed."""

    def __init__(self, script, output):
        """Initializes command with given values.

        :type script: basestring
        :type output: basestring

        """
        self.script = script
        self.output = output

    @property
    def stdout(self):
        logs.warn('`stdout` is deprecated, please use `output` instead')
        return self.output

    @property
    def stderr(self):
        logs.warn('`stderr` is deprecated, please use `output` instead')
        return self.output

    @property
    def script_parts(self):
        if not hasattr(self, '_script_parts'):
            try:
                self._script_parts = shell.split_command(self.script)
            except Exception:
                logs.debug(u"Can't split command script {} because:\n {}".format(
                    self, sys.exc_info()))
                self._script_parts = []

        return self._script_parts

    def __eq__(self, other):
        if isinstance(other, Command):
            return (self.script, self.output) == (other.script, other.output)
        else:
            return False

    def __repr__(self):
        return u'Command(script={}, output={})'.format(
            self.script, self.output)

    def update(self, **kwargs):
        """Returns new command with replaced fields.

        :rtype: Command

        """
        kwargs.setdefault('script', self.script)
        kwargs.setdefault('output', self.output)
        return Command(**kwargs)

    @classmethod
    def from_raw_script(cls, raw_script):
        """Creates instance of `Command` from a list of script parts.

        :type raw_script: [basestring]
        :rtype: Command
        :raises: EmptyCommand

        """
        script = format_raw_script(raw_script)
        if not script:
            raise EmptyCommand

        expanded = shell.from_shell(script)
        output = get_output(script, expanded)
        return cls(expanded, output)


class Rule(object):
    """Rule for fixing commands."""

    def __init__(self, name, match, get_new_command,
                 enabled_by_default, side_effect,
                 priority, requires_output):
        """Initializes rule with given fields.

        :type name: basestring
        :type match: (Command) -> bool
        :type get_new_command: (Command) -> (basestring | [basestring])
        :type enabled_by_default: boolean
        :type side_effect: (Command, basestring) -> None
        :type priority: int
        :type requires_output: bool

        """
        self.name = name
        self.match = match
        self.get_new_command = get_new_command
        self.enabled_by_default = enabled_by_default
        self.side_effect = side_effect
        self.priority = priority
        self.requires_output = requires_output

    def __eq__(self, other):
        if isinstance(other, Rule):
            return ((self.name, self.match, self.get_new_command,
                     self.enabled_by_default, self.side_effect,
                     self.priority, self.requires_output)
                    == (other.name, other.match, other.get_new_command,
                        other.enabled_by_default, other.side_effect,
                        other.priority, other.requires_output))
        else:
            return False

    def __repr__(self):
        return 'Rule(name={}, match={}, get_new_command={}, ' \
               'enabled_by_default={}, side_effect={}, ' \
               'priority={}, requires_output)'.format(
                   self.name, self.match, self.get_new_command,
                   self.enabled_by_default, self.side_effect,
                   self.priority, self.requires_output)

    @classmethod
    def from_path(cls, path):
        """Creates rule instance from path.

        :type path: pathlib.Path
        :rtype: Rule

        """
        name = path.name[:-3]
        with logs.debug_time(u'Importing rule: {};'.format(name)):
            rule_module = load_source(name, str(path))
            priority = getattr(rule_module, 'priority', DEFAULT_PRIORITY)
        return cls(name, rule_module.match,
                   rule_module.get_new_command,
                   getattr(rule_module, 'enabled_by_default', True),
                   getattr(rule_module, 'side_effect', None),
                   settings.priority.get(name, priority),
                   getattr(rule_module, 'requires_output', True))

    @property
    def is_enabled(self):
        """Returns `True` when rule enabled.

        :rtype: bool

        """
        if self.name in settings.exclude_rules:
            return False
        elif self.name in settings.rules:
            return True
        elif self.enabled_by_default and ALL_ENABLED in settings.rules:
            return True
        else:
            return False

    def is_match(self, command):
        """Returns `True` if rule matches the command.

        :type command: Command
        :rtype: bool

        """
        if command.output is None and self.requires_output:
            return False

        try:
            with logs.debug_time(u'Trying rule: {};'.format(self.name)):
                if self.match(command):
                    return True
        except Exception:
            logs.rule_failed(self, sys.exc_info())

    def get_corrected_commands(self, command):
        """Returns generator with corrected commands.

        :type command: Command
        :rtype: Iterable[CorrectedCommand]

        """
        new_commands = self.get_new_command(command)
        if not isinstance(new_commands, list):
            new_commands = (new_commands,)
        for n, new_command in enumerate(new_commands):
            yield CorrectedCommand(script=new_command,
                                   side_effect=self.side_effect,
                                   priority=(n + 1) * self.priority)


class CorrectedCommand(object):
    """Corrected by rule command."""

    def __init__(self, script, side_effect, priority):
        """Initializes instance with given fields.

        :type script: basestring
        :type side_effect: (Command, basestring) -> None
        :type priority: int

        """
        self.script = script
        self.side_effect = side_effect
        self.priority = priority

    def __eq__(self, other):
        """Ignores `priority` field."""
        if isinstance(other, CorrectedCommand):
            return (other.script, other.side_effect) == \
                   (self.script, self.side_effect)
        else:
            return False

    def __hash__(self):
        return (self.script, self.side_effect).__hash__()

    def __repr__(self):
        return u'CorrectedCommand(script={}, side_effect={}, priority={})'.format(
            self.script, self.side_effect, self.priority)

    def _get_script(self):
        """Returns fixed commands script.

        If `settings.repeat` is `True`, appends command with second attempt
        of running fuck in case fixed command fails again.

        """
        if settings.repeat:
            repeat_fuck = '{} --repeat {}--force-command {}'.format(
                get_alias(),
                '--debug ' if settings.debug else '',
                shell.quote(self.script))
            return shell.or_(self.script, repeat_fuck)
        else:
            return self.script

    def run(self, old_cmd):
        """Runs command from rule for passed command.

        :type old_cmd: Command

        """
        if self.side_effect:
            self.side_effect(old_cmd, self.script)
        if settings.alter_history:
            shell.put_to_history(self.script)
        # This depends on correct setting of PYTHONIOENCODING by the alias:
        logs.debug(u'PYTHONIOENCODING: {}'.format(
            os.environ.get('PYTHONIOENCODING', '!!not-set!!')))

        print(self._get_script())
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

import sys
from .conf import settings
from .exceptions import NoRuleMatched
from .system import get_key
from .utils import get_alias
from . import logs, const


def read_actions():
    """Yields actions for pressed keys."""
    while True:
        key = get_key()

        # Handle arrows, j/k (qwerty), and n/e (colemak)
        if key in (const.KEY_UP, const.KEY_CTRL_N, 'k', 'e'):
            yield const.ACTION_PREVIOUS
        elif key in (const.KEY_DOWN, const.KEY_CTRL_P, 'j', 'n'):
            yield const.ACTION_NEXT
        elif key in (const.KEY_CTRL_C, 'q'):
            yield const.ACTION_ABORT
        elif key in ('\n', '\r'):
            yield const.ACTION_SELECT


class CommandSelector(object):
    """Helper for selecting rule from rules list."""

    def __init__(self, commands):
        """:type commands: Iterable[thefuck.types.CorrectedCommand]"""
        self._commands_gen = commands
        try:
            self._commands = [next(self._commands_gen)]
        except StopIteration:
            raise NoRuleMatched
        self._realised = False
        self._index = 0

    def _realise(self):
        if not self._realised:
            self._commands += list(self._commands_gen)
            self._realised = True

    def next(self):
        self._realise()
        self._index = (self._index + 1) % len(self._commands)

    def previous(self):
        self._realise()
        self._index = (self._index - 1) % len(self._commands)

    @property
    def value(self):
        """:rtype hefuck.types.CorrectedCommand"""
        return self._commands[self._index]


def select_command(corrected_commands):
    """Returns:

     - the first command when confirmation disabled;
     - None when ctrl+c pressed;
     - selected command.

    :type corrected_commands: Iterable[thefuck.types.CorrectedCommand]
    :rtype: thefuck.types.CorrectedCommand | None

    """
    try:
        selector = CommandSelector(corrected_commands)
    except NoRuleMatched:
        logs.failed('No fucks given' if get_alias() == 'fuck'
                    else 'Nothing found')
        return

    if not settings.require_confirmation:
        logs.show_corrected_command(selector.value)
        return selector.value

    logs.confirm_text(selector.value)

    for action in read_actions():
        if action == const.ACTION_SELECT:
            sys.stderr.write('\n')
            return selector.value
        elif action == const.ACTION_ABORT:
            logs.failed('\nAborted')
            return
        elif action == const.ACTION_PREVIOUS:
            selector.previous()
            logs.confirm_text(selector.value)
        elif action == const.ACTION_NEXT:
            selector.next()
            logs.confirm_text(selector.value)
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

from contextlib import contextmanager
from datetime import datetime
import sys
from traceback import format_exception
import colorama
from .conf import settings
from . import const


def color(color_):
    """Utility for ability to disabling colored output."""
    if settings.no_colors:
        return ''
    else:
        return color_


def warn(title):
    sys.stderr.write(u'{warn}[WARN] {title}{reset}\n'.format(
        warn=color(colorama.Back.RED + colorama.Fore.WHITE
                   + colorama.Style.BRIGHT),
        reset=color(colorama.Style.RESET_ALL),
        title=title))


def exception(title, exc_info):
    sys.stderr.write(
        u'{warn}[WARN] {title}:{reset}\n{trace}'
        u'{warn}----------------------------{reset}\n\n'.format(
            warn=color(colorama.Back.RED + colorama.Fore.WHITE
                       + colorama.Style.BRIGHT),
            reset=color(colorama.Style.RESET_ALL),
            title=title,
            trace=''.join(format_exception(*exc_info))))


def rule_failed(rule, exc_info):
    exception(u'Rule {}'.format(rule.name), exc_info)


def failed(msg):
    sys.stderr.write(u'{red}{msg}{reset}\n'.format(
        msg=msg,
        red=color(colorama.Fore.RED),
        reset=color(colorama.Style.RESET_ALL)))


def show_corrected_command(corrected_command):
    sys.stderr.write(u'{prefix}{bold}{script}{reset}{side_effect}\n'.format(
        prefix=const.USER_COMMAND_MARK,
        script=corrected_command.script,
        side_effect=u' (+side effect)' if corrected_command.side_effect else u'',
        bold=color(colorama.Style.BRIGHT),
        reset=color(colorama.Style.RESET_ALL)))


def confirm_text(corrected_command):
    sys.stderr.write(
        (u'{prefix}{clear}{bold}{script}{reset}{side_effect} '
         u'[{green}enter{reset}/{blue}↑{reset}/{blue}↓{reset}'
         u'/{red}ctrl+c{reset}]').format(
            prefix=const.USER_COMMAND_MARK,
            script=corrected_command.script,
            side_effect=' (+side effect)' if corrected_command.side_effect else '',
            clear='\033[1K\r',
            bold=color(colorama.Style.BRIGHT),
            green=color(colorama.Fore.GREEN),
            red=color(colorama.Fore.RED),
            reset=color(colorama.Style.RESET_ALL),
            blue=color(colorama.Fore.BLUE)))


def debug(msg):
    if settings.debug:
        sys.stderr.write(u'{blue}{bold}DEBUG:{reset} {msg}\n'.format(
            msg=msg,
            reset=color(colorama.Style.RESET_ALL),
            blue=color(colorama.Fore.BLUE),
            bold=color(colorama.Style.BRIGHT)))


@contextmanager
def debug_time(msg):
    started = datetime.now()
    try:
        yield
    finally:
        debug(u'{} took: {}'.format(msg, datetime.now() - started))


def how_to_configure_alias(configuration_details):
    print(u"Seems like {bold}fuck{reset} alias isn't configured!".format(
        bold=color(colorama.Style.BRIGHT),
        reset=color(colorama.Style.RESET_ALL)))

    if configuration_details:
        print(
            u"Please put {bold}{content}{reset} in your "
            u"{bold}{path}{reset} and apply "
            u"changes with {bold}{reload}{reset} or restart your shell.".format(
                bold=color(colorama.Style.BRIGHT),
                reset=color(colorama.Style.RESET_ALL),
                **configuration_details._asdict()))

        if configuration_details.can_configure_automatically:
            print(
                u"Or run {bold}fuck{reset} second time for configuring"
                u" it automatically.".format(
                    bold=color(colorama.Style.BRIGHT),
                    reset=color(colorama.Style.RESET_ALL)))

    print(u'More details - https://github.com/nvbn/thefuck#manual-installation')


def already_configured(configuration_details):
    print(
        u"Seems like {bold}fuck{reset} alias already configured!\n"
        u"For applying changes run {bold}{reload}{reset}"
        u" or restart your shell.".format(
            bold=color(colorama.Style.BRIGHT),
            reset=color(colorama.Style.RESET_ALL),
            reload=configuration_details.reload))


def configured_successfully(configuration_details):
    print(
        u"{bold}fuck{reset} alias configured successfully!\n"
        u"For applying changes run {bold}{reload}{reset}"
        u" or restart your shell.".format(
            bold=color(colorama.Style.BRIGHT),
            reset=color(colorama.Style.RESET_ALL),
            reload=configuration_details.reload))


def version(thefuck_version, python_version, shell_info):
    sys.stderr.write(
        u'The Fuck {} using Python {} and {}\n'.format(thefuck_version,
                                                       python_version,
                                                       shell_info))
<EOF>
<BOF>
import sys
from .conf import settings
from .types import Rule
from .system import Path
from . import logs


def get_loaded_rules(rules_paths):
    """Yields all available rules.

    :type rules_paths: [Path]
    :rtype: Iterable[Rule]

    """
    for path in rules_paths:
        if path.name != '__init__.py':
            rule = Rule.from_path(path)
            if rule.is_enabled:
                yield rule


def get_rules_import_paths():
    """Yields all rules import paths.

    :rtype: Iterable[Path]

    """
    # Bundled rules:
    yield Path(__file__).parent.joinpath('rules')
    # Rules defined by user:
    yield settings.user_dir.joinpath('rules')
    # Packages with third-party rules:
    for path in sys.path:
        for contrib_module in Path(path).glob('thefuck_contrib_*'):
            contrib_rules = contrib_module.joinpath('rules')
            if contrib_rules.is_dir():
                yield contrib_rules


def get_rules():
    """Returns all enabled rules.

    :rtype: [Rule]

    """
    paths = [rule_path for path in get_rules_import_paths()
             for rule_path in sorted(path.glob('*.py'))]
    return sorted(get_loaded_rules(paths),
                  key=lambda rule: rule.priority)


def organize_commands(corrected_commands):
    """Yields sorted commands without duplicates.

    :type corrected_commands: Iterable[thefuck.types.CorrectedCommand]
    :rtype: Iterable[thefuck.types.CorrectedCommand]

    """
    try:
        first_command = next(corrected_commands)
        yield first_command
    except StopIteration:
        return

    without_duplicates = {
        command for command in sorted(
            corrected_commands, key=lambda command: command.priority)
        if command != first_command}

    sorted_commands = sorted(
        without_duplicates,
        key=lambda corrected_command: corrected_command.priority)

    logs.debug('Corrected commands: '.format(
        ', '.join(u'{}'.format(cmd) for cmd in [first_command] + sorted_commands)))

    for command in sorted_commands:
        yield command


def get_corrected_commands(command):
    """Returns generator with sorted and unique corrected commands.

    :type command: thefuck.types.Command
    :rtype: Iterable[thefuck.types.CorrectedCommand]

    """
    corrected_commands = (
        corrected for rule in get_rules()
        if rule.is_match(command)
        for corrected in rule.get_corrected_commands(command))
    return organize_commands(corrected_commands)
<EOF>
<BOF>
import os
from thefuck.utils import for_app


def _get_actual_file(parts):
    for part in parts[1:]:
        if os.path.isfile(part) or os.path.isdir(part):
            return part


@for_app('grep', 'egrep')
def match(command):
    return ': No such file or directory' in command.output \
        and _get_actual_file(command.script_parts)


def get_new_command(command):
    actual_file = _get_actual_file(command.script_parts)
    parts = command.script_parts[::]
    # Moves file to the end of the script:
    parts.remove(actual_file)
    parts.append(actual_file)
    return ' '.join(parts)
<EOF>
<BOF>
from thefuck.utils import for_app
# Appends .go when compiling go files
#
# Example:
# > go run foo
# error: go run: no go files listed


@for_app('go')
def match(command):
    return (command.script.startswith('go run ')
            and not command.script.endswith('.go'))


def get_new_command(command):
    return command.script + '.go'
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('mvn')
def match(command):
    return 'No goals have been specified for this build' in command.output


def get_new_command(command):
    return [command.script + ' clean package',
            command.script + ' clean install']
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('brew', at_least=2)
def match(command):
    return (command.script_parts[1] in ['ln', 'link']
            and "brew link --overwrite --dry-run" in command.output)


def get_new_command(command):
    command_parts = command.script_parts[:]
    command_parts[1] = 'link'
    command_parts.insert(2, '--overwrite')
    command_parts.insert(3, '--dry-run')
    return ' '.join(command_parts)
<EOF>
<BOF>
from itertools import dropwhile, takewhile, islice
import re
import subprocess
from thefuck.utils import replace_command, for_app, which, cache
from thefuck.specific.sudo import sudo_support


@sudo_support
@for_app('docker')
def match(command):
    return 'is not a docker command' in command.output


def get_docker_commands():
    proc = subprocess.Popen('docker', stdout=subprocess.PIPE)
    lines = [line.decode('utf-8') for line in proc.stdout.readlines()]
    lines = dropwhile(lambda line: not line.startswith('Commands:'), lines)
    lines = islice(lines, 1, None)
    lines = list(takewhile(lambda line: line != '\n', lines))
    return [line.strip().split(' ')[0] for line in lines]


if which('docker'):
    get_docker_commands = cache(which('docker'))(get_docker_commands)


@sudo_support
def get_new_command(command):
    wrong_command = re.findall(
        r"docker: '(\w+)' is not a docker command.", command.output)[0]
    return replace_command(command, wrong_command, get_docker_commands())
<EOF>
<BOF>
import re
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('push' in command.script_parts
            and 'git push --set-upstream' in command.output)


def _get_upstream_option_index(command_parts):
    if '--set-upstream' in command_parts:
        return command_parts.index('--set-upstream')
    elif '-u' in command_parts:
        return command_parts.index('-u')
    else:
        return None


@git_support
def get_new_command(command):
    # If --set-upstream or -u are passed, remove it and its argument. This is
    # because the remaining arguments are concatenated onto the command suggested
    # by git, which includes --set-upstream and its argument
    command_parts = command.script_parts[:]
    upstream_option_index = _get_upstream_option_index(command_parts)

    if upstream_option_index is not None:
        command_parts.pop(upstream_option_index)

        # In case of `git push -u` we don't have next argument:
        if len(command_parts) > upstream_option_index:
            command_parts.pop(upstream_option_index)
    else:
        # the only non-qualified permitted options are the repository and refspec; git's
        # suggestion include them, so they won't be lost, but would be duplicated otherwise.
        push_idx = command_parts.index('push') + 1
        while len(command_parts) > push_idx and command_parts[len(command_parts) - 1][0] != '-':
            command_parts.pop(len(command_parts) - 1)

    arguments = re.findall(r'git push (.*)', command.output)[-1].replace("'", r"\'").strip()
    return replace_argument(" ".join(command_parts), 'push',
                            'push {}'.format(arguments))
<EOF>
<BOF>
import re
from thefuck.utils import replace_argument, for_app


@for_app('composer')
def match(command):
    return (('did you mean this?' in command.output.lower()
             or 'did you mean one of these?' in command.output.lower()))


def get_new_command(command):
    broken_cmd = re.findall(r"Command \"([^']*)\" is not defined", command.output)[0]
    new_cmd = re.findall(r'Did you mean this\?[^\n]*\n\s*([^\n]*)', command.output)
    if not new_cmd:
        new_cmd = re.findall(r'Did you mean one of these\?[^\n]*\n\s*([^\n]*)', command.output)
    return replace_argument(command.script, broken_cmd, new_cmd[0].strip())
<EOF>
<BOF>
from thefuck.utils import for_app, replace_command, eager, memoize
from thefuck.system import Path


@memoize
@eager
def _get_all_environments():
    root = Path('~/.virtualenvs').expanduser()
    if not root.is_dir():
        return

    for child in root.iterdir():
        if child.is_dir():
            yield child.name


@for_app('workon')
def match(command):
    return (len(command.script_parts) >= 2
            and command.script_parts[1] not in _get_all_environments())


def get_new_command(command):
    misspelled_env = command.script_parts[1]
    create_new = u'mkvirtualenv {}'.format(misspelled_env)

    available = _get_all_environments()
    if available:
        return (replace_command(command, misspelled_env, available)
                + [create_new])
    else:
        return create_new
<EOF>
<BOF>
import re
from thefuck.specific.git import git_support


@git_support
def match(command):
    return "push" in command.script and "The upstream branch of your current branch does not match" in command.output


@git_support
def get_new_command(command):
    return re.findall(r'^ +(git push [^\s]+ [^\s]+)', command.output, re.MULTILINE)[0]
<EOF>
<BOF>
import subprocess
from thefuck.utils import for_app, replace_command, eager


@for_app('ifconfig')
def match(command):
    return 'error fetching interface information: Device not found' \
           in command.output


@eager
def _get_possible_interfaces():
    proc = subprocess.Popen(['ifconfig', '-a'], stdout=subprocess.PIPE)
    for line in proc.stdout.readlines():
        line = line.decode()
        if line and line != '\n' and not line.startswith(' '):
            yield line.split(' ')[0]


def get_new_command(command):
    interface = command.output.split(' ')[0][:-1]
    possible_interfaces = _get_possible_interfaces()
    return replace_command(command, interface, possible_interfaces)
<EOF>
<BOF>
import re
from thefuck.utils import get_closest, for_app


def extract_possibilities(command):
    possib = re.findall(r'\n\(did you mean one of ([^\?]+)\?\)', command.output)
    if possib:
        return possib[0].split(', ')
    possib = re.findall(r'\n    ([^$]+)$', command.output)
    if possib:
        return possib[0].split(' ')
    return possib


@for_app('hg')
def match(command):
    return ('hg: unknown command' in command.output
            and '(did you mean one of ' in command.output
            or "hg: command '" in command.output
            and "' is ambiguous:" in command.output)


def get_new_command(command):
    script = command.script_parts[:]
    possibilities = extract_possibilities(command)
    script[1] = get_closest(script[1], possibilities)
    return ' '.join(script)
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('grep')
def match(command):
    return 'is a directory' in command.output.lower()


def get_new_command(command):
    return u'grep -r {}'.format(command.script[5:])
<EOF>
<BOF>
from thefuck.specific.sudo import sudo_support

enabled_by_default = False


@sudo_support
def match(command):
    return (command.script_parts
            and {'rm', '/'}.issubset(command.script_parts)
            and '--no-preserve-root' not in command.script
            and '--no-preserve-root' in command.output)


@sudo_support
def get_new_command(command):
    return u'{} --no-preserve-root'.format(command.script)
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('man', at_least=1)
def match(command):
    return True


def get_new_command(command):
    if '3' in command.script:
        return command.script.replace("3", "2")
    if '2' in command.script:
        return command.script.replace("2", "3")

    last_arg = command.script_parts[-1]
    help_command = last_arg + ' --help'

    # If there are no man pages for last_arg, suggest `last_arg --help` instead.
    # Otherwise, suggest `--help` after suggesting other man page sections.
    if command.output.strip() == 'No manual entry for ' + last_arg:
        return [help_command]

    split_cmd2 = command.script_parts
    split_cmd3 = split_cmd2[:]

    split_cmd2.insert(1, ' 2 ')
    split_cmd3.insert(1, ' 3 ')

    return [
        "".join(split_cmd3),
        "".join(split_cmd2),
        help_command,
    ]
<EOF>
<BOF>
from thefuck.specific.npm import npm_available, get_scripts
from thefuck.utils import for_app

enabled_by_default = npm_available


@for_app('npm')
def match(command):
    return ('Usage: npm <command>' in command.output
            and not any(part.startswith('ru') for part in command.script_parts)
            and command.script_parts[1] in get_scripts())


def get_new_command(command):
    parts = command.script_parts[:]
    parts.insert(1, 'run-script')
    return ' '.join(parts)
<EOF>
<BOF>
import re
from thefuck.utils import replace_argument, for_app


@for_app('cargo', at_least=1)
def match(command):
    return ('no such subcommand' in command.output.lower()
            and 'Did you mean' in command.output)


def get_new_command(command):
    broken = command.script_parts[1]
    fix = re.findall(r'Did you mean `([^`]*)`', command.output)[0]

    return replace_argument(command.script, broken, fix)
<EOF>
<BOF>
import re
from thefuck.utils import for_app
from thefuck.system import open_command


@for_app('yarn', at_least=2)
def match(command):
    return (command.script_parts[1] == 'help'
            and 'for documentation about this command.' in command.output)


def get_new_command(command):
    url = re.findall(
        r'Visit ([^ ]*) for documentation about this command.',
        command.output)[0]

    return open_command(url)
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('ls')
def match(command):
    return command.script_parts and 'ls -' not in command.script


def get_new_command(command):
    command = command.script_parts[:]
    command[0] = 'ls -lah'
    return ' '.join(command)
<EOF>
<BOF>
import re
from thefuck.utils import for_app


warning_regex = re.compile(r'Warning: (?:.(?!is ))+ is already installed and '
                           r'up-to-date')
message_regex = re.compile(r'To reinstall (?:(?!, ).)+, run `brew reinstall '
                           r'[^`]+`')


@for_app('brew', at_least=2)
def match(command):
    return ('install' in command.script
            and warning_regex.search(command.output)
            and message_regex.search(command.output))


def get_new_command(command):
    return command.script.replace('install', 'reinstall')
<EOF>
<BOF>
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('merge' in command.script
            and 'fatal: refusing to merge unrelated histories' in command.output)


@git_support
def get_new_command(command):
    return command.script + ' --allow-unrelated-histories'
<EOF>
<BOF>
import os
import zipfile
from thefuck.utils import for_app
from thefuck.shells import shell


def _is_bad_zip(file):
    try:
        with zipfile.ZipFile(file, 'r') as archive:
            return len(archive.namelist()) > 1
    except Exception:
        return False


def _zip_file(command):
    # unzip works that way:
    # unzip [-flags] file[.zip] [file(s) ...] [-x file(s) ...]
    #                ^          ^ files to unzip from the archive
    #                archive to unzip
    for c in command.script_parts[1:]:
        if not c.startswith('-'):
            if c.endswith('.zip'):
                return c
            else:
                return u'{}.zip'.format(c)


@for_app('unzip')
def match(command):
    if '-d' in command.script:
        return False

    zip_file = _zip_file(command)
    if zip_file:
        return _is_bad_zip(zip_file)
    else:
        return False


def get_new_command(command):
    return u'{} -d {}'.format(
        command.script, shell.quote(_zip_file(command)[:-4]))


def side_effect(old_cmd, command):
    with zipfile.ZipFile(_zip_file(old_cmd), 'r') as archive:
        for file in archive.namelist():
            try:
                os.remove(file)
            except OSError:
                # does not try to remove directories as we cannot know if they
                # already existed before
                pass


requires_output = False
<EOF>
<BOF>
import re
import os
from thefuck.utils import memoize, default_settings
from thefuck.conf import settings
from thefuck.shells import shell


# order is important: only the first match is considered
patterns = (
    # js, node:
    '^    at {file}:{line}:{col}',
    # cargo:
    '^   {file}:{line}:{col}',
    # python, thefuck:
    '^  File "{file}", line {line}',
    # awk:
    '^awk: {file}:{line}:',
    # git
    '^fatal: bad config file line {line} in {file}',
    # llc:
    '^llc: {file}:{line}:{col}:',
    # lua:
    '^lua: {file}:{line}:',
    # fish:
    '^{file} \\(line {line}\\):',
    # bash, sh, ssh:
    '^{file}: line {line}: ',
    # cargo, clang, gcc, go, pep8, rustc:
    '^{file}:{line}:{col}',
    # ghc, make, ruby, zsh:
    '^{file}:{line}:',
    # perl:
    'at {file} line {line}',
)


# for the sake of readability do not use named groups above
def _make_pattern(pattern):
    pattern = pattern.replace('{file}', '(?P<file>[^:\n]+)') \
                     .replace('{line}', '(?P<line>[0-9]+)') \
                     .replace('{col}', '(?P<col>[0-9]+)')
    return re.compile(pattern, re.MULTILINE)


patterns = [_make_pattern(p).search for p in patterns]


@memoize
def _search(output):
    for pattern in patterns:
        m = pattern(output)
        if m and os.path.isfile(m.group('file')):
            return m


def match(command):
    if 'EDITOR' not in os.environ:
        return False

    return _search(command.output)


@default_settings({'fixlinecmd': u'{editor} {file} +{line}',
                   'fixcolcmd': None})
def get_new_command(command):
    m = _search(command.output)

    # Note: there does not seem to be a standard for columns, so they are just
    # ignored by default
    if settings.fixcolcmd and 'col' in m.groupdict():
        editor_call = settings.fixcolcmd.format(editor=os.environ['EDITOR'],
                                                file=m.group('file'),
                                                line=m.group('line'),
                                                col=m.group('col'))
    else:
        editor_call = settings.fixlinecmd.format(editor=os.environ['EDITOR'],
                                                 file=m.group('file'),
                                                 line=m.group('line'))

    return shell.and_(editor_call, command.script)
<EOF>
<BOF>
import re
from thefuck.specific.sudo import sudo_support
from thefuck.utils import replace_command, for_app

no_command = "Error: No such command"
no_website = "hostscli.errors.WebsiteImportError"


@sudo_support
@for_app('hostscli')
def match(command):
    errors = [no_command, no_website]
    for error in errors:
        if error in command.output:
            return True
    return False


@sudo_support
def get_new_command(command):
    if no_website in command.output:
        return ['hostscli websites']

    misspelled_command = re.findall(
        r'Error: No such command ".*"', command.output)[0]
    commands = ['block', 'unblock', 'websites', 'block_all', 'unblock_all']
    return replace_command(command, misspelled_command, commands)
<EOF>
<BOF>
import re
from thefuck.utils import for_app

commands = ('ssh', 'scp')


@for_app(*commands)
def match(command):
    if not command.script:
        return False
    if not command.script.startswith(commands):
        return False

    patterns = (
        r'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!',
        r'WARNING: POSSIBLE DNS SPOOFING DETECTED!',
        r"Warning: the \S+ host key for '([^']+)' differs from the key for the IP address '([^']+)'",
    )

    return any(re.findall(pattern, command.output) for pattern in patterns)


def get_new_command(command):
    return command.script


def side_effect(old_cmd, command):
    offending_pattern = re.compile(
        r'(?:Offending (?:key for IP|\S+ key)|Matching host key) in ([^:]+):(\d+)',
        re.MULTILINE)
    offending = offending_pattern.findall(old_cmd.output)
    for filepath, lineno in offending:
        with open(filepath, 'r') as fh:
            lines = fh.readlines()
            del lines[int(lineno) - 1]
        with open(filepath, 'w') as fh:
            fh.writelines(lines)
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

import re
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return ('command not found' in command.output.lower()
            and u' ' in command.script)


@sudo_support
def get_new_command(command):
    return re.sub(u' ', ' ', command.script)
<EOF>
<BOF>
import re
from thefuck.utils import replace_command, for_app


@for_app('tmux')
def match(command):
    return ('ambiguous command:' in command.output
            and 'could be:' in command.output)


def get_new_command(command):
    cmd = re.match(r"ambiguous command: (.*), could be: (.*)",
                   command.output)

    old_cmd = cmd.group(1)
    suggestions = [c.strip() for c in cmd.group(2).split(',')]

    return replace_command(command, old_cmd, suggestions)
<EOF>
<BOF>
# -*- encoding: utf-8 -*-

CEDILLA = u"ç"


def match(command):
    return command.script.endswith(CEDILLA)


def get_new_command(command):
    return command.script[:-1]
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('ls')
def match(command):
    return command.output.strip() == ''


def get_new_command(command):
    return ' '.join(['ls', '-A'] + command.script_parts[1:])
<EOF>
<BOF>
from thefuck.utils import replace_argument
import re

# regex to match a suggested help command from the tool output
help_regex = r"(?:Run|Try) '([^']+)'(?: or '[^']+')? for (?:details|more information)."


def match(command):
    if re.search(help_regex, command.output, re.I) is not None:
        return True

    if '--help' in command.output:
        return True

    return False


def get_new_command(command):
    if re.search(help_regex, command.output) is not None:
        match_obj = re.search(help_regex, command.output, re.I)
        return match_obj.group(1)

    return replace_argument(command.script, '-h', '--help')


enabled_by_default = True
priority = 5000
<EOF>
<BOF>
import re
from thefuck.utils import replace_argument, for_app


@for_app('yarn', at_least=1)
def match(command):
    return 'Did you mean' in command.output


def get_new_command(command):
    broken = command.script_parts[1]
    fix = re.findall(r'Did you mean [`"](?:yarn )?([^`"]*)[`"]', command.output)[0]

    return replace_argument(command.script, broken, fix)
<EOF>
<BOF>
# Adds the missing space between the cd command and the target directory
# when trying to cd to the parent directory.
#
# Does not really save chars, but is fun :D
#
# Example:
# > cd..
# cd..: command not found


def match(command):
    return command.script == 'cd..'


def get_new_command(command):
    return 'cd ..'
<EOF>
<BOF>
import re
from thefuck.utils import get_all_matched_commands, replace_command
from thefuck.specific.git import git_support


@git_support
def match(command):
    return (" is not a git command. See 'git --help'." in command.output
            and ('The most similar command' in command.output
                 or 'Did you mean' in command.output))


@git_support
def get_new_command(command):
    broken_cmd = re.findall(r"git: '([^']*)' is not a git command",
                            command.output)[0]
    matched = get_all_matched_commands(command.output, ['The most similar command', 'Did you mean'])
    return replace_command(command, broken_cmd, matched)
<EOF>
<BOF>
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('push' in command.script
            and '! [rejected]' in command.output
            and 'failed to push some refs to' in command.output
            and 'Updates were rejected because the tip of your current branch is behind' in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'push', 'push --force-with-lease')


enabled_by_default = False
<EOF>
<BOF>
import re
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return ('mkdir' in command.script
            and 'No such file or directory' in command.output)


@sudo_support
def get_new_command(command):
    return re.sub('\\bmkdir (.*)', 'mkdir -p \\1', command.script)
<EOF>
<BOF>
from collections import Counter
import re
from thefuck.system import Path
from thefuck.utils import (get_valid_history_without_current,
                           memoize, replace_argument)
from thefuck.shells import shell


patterns = [r'no such file or directory: (.*)$',
            r"cannot access '(.*)': No such file or directory",
            r': (.*): No such file or directory',
            r"can't cd to (.*)$"]


@memoize
def _get_destination(command):
    for pattern in patterns:
        found = re.findall(pattern, command.output)
        if found:
            if found[0] in command.script_parts:
                return found[0]


def match(command):
    return bool(_get_destination(command))


def _get_all_absolute_paths_from_history(command):
    counter = Counter()

    for line in get_valid_history_without_current(command):
        splitted = shell.split_command(line)

        for param in splitted[1:]:
            if param.startswith('/') or param.startswith('~'):
                if param.endswith('/'):
                    param = param[:-1]

                counter[param] += 1

    return (path for path, _ in counter.most_common(None))


def get_new_command(command):
    destination = _get_destination(command)
    paths = _get_all_absolute_paths_from_history(command)

    return [replace_argument(command.script, destination, path)
            for path in paths if path.endswith(destination)
            and Path(path).expanduser().exists()]


priority = 800
<EOF>
<BOF>
import re
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return ('rm' in command.script
            and 'is a directory' in command.output.lower())


@sudo_support
def get_new_command(command):
    arguments = '-rf'
    if 'hdfs' in command.script:
        arguments = '-r'
    return re.sub('\\brm (.*)', 'rm ' + arguments + ' \\1', command.script)
<EOF>
<BOF>
import re
from thefuck.utils import replace_argument, for_app
from thefuck.specific.sudo import sudo_support


@sudo_support
@for_app('pip', 'pip2', 'pip3')
def match(command):
    return ('pip' in command.script and
            'unknown command' in command.output and
            'maybe you meant' in command.output)


def get_new_command(command):
    broken_cmd = re.findall(r'ERROR: unknown command \"([a-z]+)\"',
                            command.output)[0]
    new_cmd = re.findall(r'maybe you meant \"([a-z]+)\"', command.output)[0]

    return replace_argument(command.script, broken_cmd, new_cmd)
<EOF>
<BOF>
def match(command):
    return 'manage.py' in command.script and \
           'migrate' in command.script \
           and '--merge: will just attempt the migration' in command.output


def get_new_command(command):
    return u'{} --merge'.format(command.script)
<EOF>
<BOF>
from thefuck.specific.git import git_support


@git_support
def match(command):
    return (' rm ' in command.script and
            'error: the following file has changes staged in the index' in command.output and
            'use --cached to keep the file, or -f to force removal' in command.output)


@git_support
def get_new_command(command):
    command_parts = command.script_parts[:]
    index = command_parts.index('rm') + 1
    command_parts.insert(index, '--cached')
    command_list = [u' '.join(command_parts)]
    command_parts[index] = '-f'
    command_list.append(u' '.join(command_parts))
    return command_list
<EOF>
<BOF>
import re
import subprocess
from thefuck import utils
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support
from thefuck.shells import shell


@git_support
def match(command):
    return ('did not match any file(s) known to git.' in command.output
            and "Did you forget to 'git add'?" not in command.output)


def get_branches():
    proc = subprocess.Popen(
        ['git', 'branch', '-a', '--no-color', '--no-column'],
        stdout=subprocess.PIPE)
    for line in proc.stdout.readlines():
        line = line.decode('utf-8')
        if line.startswith('*'):
            line = line.split(' ')[1]
        if '/' in line:
            line = line.split('/')[-1]
        yield line.strip()


@git_support
def get_new_command(command):
    missing_file = re.findall(
        r"error: pathspec '([^']*)' "
        r"did not match any file\(s\) known to git.", command.output)[0]
    closest_branch = utils.get_closest(missing_file, get_branches(),
                                       fallback_to_first=False)
    if closest_branch:
        return replace_argument(command.script, missing_file, closest_branch)
    elif command.script_parts[1] == 'checkout':
        return replace_argument(command.script, 'checkout', 'checkout -b')
    else:
        return shell.and_('git branch {}', '{}').format(
            missing_file, command.script)
<EOF>
<BOF>
import subprocess
import re
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app, replace_command
from thefuck.specific.dnf import dnf_available


regex = re.compile(r'No such command: (.*)\.')


@for_app('dnf')
@sudo_support
def match(command):
    return 'no such command' in command.output.lower()


def _parse_operations(help_text_lines):
    operation_regex = re.compile(r'^([a-z-]+) +', re.MULTILINE)
    return operation_regex.findall(help_text_lines)


def _get_operations():
    proc = subprocess.Popen(["dnf", '--help'],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    lines = proc.stdout.read().decode("utf-8")

    return _parse_operations(lines)


@sudo_support
def get_new_command(command):
    misspelled_command = regex.findall(command.output)[0]
    return replace_command(command, misspelled_command, _get_operations())


enabled_by_default = dnf_available
<EOF>
<BOF>
from thefuck.utils import replace_argument, for_app


@for_app('php', at_least=2)
def match(command):
    return ('-s' in command.script_parts
            and command.script_parts[-1] != '-s')


def get_new_command(command):
    return replace_argument(command.script, "-s", "-S")
<EOF>
<BOF>
import re
from thefuck.specific.git import git_support

error_pattern = "fatal: bad flag '(.*?)' used after filename"
error_pattern2 = "fatal: option '(.*?)' must come before non-option arguments"


@git_support
def match(command):
    return re.search(error_pattern, command.output) or re.search(error_pattern2, command.output)


@git_support
def get_new_command(command):
    command_parts = command.script_parts[:]

    # find the bad flag
    bad_flag = match(command).group(1)
    bad_flag_index = command_parts.index(bad_flag)

    # find the filename
    for index in reversed(range(bad_flag_index)):
        if command_parts[index][0] != '-':
            filename_index = index
            break

    # swap them
    command_parts[bad_flag_index], command_parts[filename_index] = \
    command_parts[filename_index], command_parts[bad_flag_index]  # noqa: E122

    return u' '.join(command_parts)
<EOF>
<BOF>
import re
from thefuck.utils import replace_command
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('bisect' in command.script_parts and
            'usage: git bisect' in command.output)


@git_support
def get_new_command(command):
    broken = re.findall(r'git bisect ([^ $]*).*', command.script)[0]
    usage = re.findall(r'usage: git bisect \[([^\]]+)\]', command.output)[0]
    return replace_command(command, broken, usage.split('|'))
<EOF>
<BOF>
"""Appends .java when compiling java files

Example:
 > javac foo
 error: Class names, 'foo', are only accepted if annotation
 processing is explicitly requested

"""
from thefuck.utils import for_app


@for_app('javac')
def match(command):
    return not command.script.endswith('.java')


def get_new_command(command):
    return command.script + '.java'
<EOF>
<BOF>
import tarfile
import os
from thefuck.utils import for_app
from thefuck.shells import shell


tar_extensions = ('.tar', '.tar.Z', '.tar.bz2', '.tar.gz', '.tar.lz',
                  '.tar.lzma', '.tar.xz', '.taz', '.tb2', '.tbz', '.tbz2',
                  '.tgz', '.tlz', '.txz', '.tz')


def _is_tar_extract(cmd):
    if '--extract' in cmd:
        return True

    cmd = cmd.split()

    return len(cmd) > 1 and 'x' in cmd[1]


def _tar_file(cmd):
    for c in cmd:
        for ext in tar_extensions:
            if c.endswith(ext):
                return (c, c[0:len(c) - len(ext)])


@for_app('tar')
def match(command):
    return ('-C' not in command.script
            and _is_tar_extract(command.script)
            and _tar_file(command.script_parts) is not None)


def get_new_command(command):
    dir = shell.quote(_tar_file(command.script_parts)[1])
    return shell.and_('mkdir -p {dir}', '{cmd} -C {dir}') \
        .format(dir=dir, cmd=command.script)


def side_effect(old_cmd, command):
    with tarfile.TarFile(_tar_file(old_cmd.script_parts)[0]) as archive:
        for file in archive.getnames():
            try:
                os.remove(file)
            except OSError:
                # does not try to remove directories as we cannot know if they
                # already existed before
                pass
<EOF>
<BOF>
from thefuck.utils import get_close_matches
from thefuck.specific.git import git_support


@git_support
def match(command):
    return (' rebase' in command.script and
            'It seems that there is already a rebase-merge directory' in command.output and
            'I wonder if you are in the middle of another rebase' in command.output)


@git_support
def get_new_command(command):
    command_list = ['git rebase --continue', 'git rebase --abort', 'git rebase --skip']
    rm_cmd = command.output.split('\n')[-4]
    command_list.append(rm_cmd.strip())
    return get_close_matches(command.script, command_list, 4, 0)
<EOF>
<BOF>
import re
from thefuck.shells import shell
from thefuck.specific.git import git_support
from thefuck.system import Path
from thefuck.utils import memoize


@memoize
def _get_missing_file(command):
    pathspec = re.findall(
        r"error: pathspec '([^']*)' "
        r'did not match any file\(s\) known to git.', command.output)[0]
    if Path(pathspec).exists():
        return pathspec


@git_support
def match(command):
    return ('did not match any file(s) known to git.' in command.output
            and _get_missing_file(command))


@git_support
def get_new_command(command):
    missing_file = _get_missing_file(command)
    formatme = shell.and_('git add -- {}', '{}')
    return formatme.format(missing_file, command.script)
<EOF>
<BOF>
from thefuck.specific.git import git_support


@git_support
def match(command):
    return (' rm ' in command.script
            and "fatal: not removing '" in command.output
            and "' recursively without -r" in command.output)


@git_support
def get_new_command(command):
    command_parts = command.script_parts[:]
    index = command_parts.index('rm') + 1
    command_parts.insert(index, '-r')
    return u' '.join(command_parts)
<EOF>
<BOF>
def match(command):
    split_command = command.script_parts

    return (split_command
            and len(split_command) >= 2
            and split_command[0] == split_command[1])


def get_new_command(command):
    return ' '.join(command.script_parts[1:])


# it should be rare enough to actually have to type twice the same word, so
# this rule can have a higher priority to come before things like "cd cd foo"
priority = 900
<EOF>
<BOF>
import re
import subprocess
from thefuck.utils import for_app, eager, replace_command, cache, which


@for_app('gem')
def match(command):
    return ('ERROR:  While executing gem ... (Gem::CommandLineError)'
            in command.output
            and 'Unknown command' in command.output)


def _get_unknown_command(command):
    return re.findall(r'Unknown command (.*)$', command.output)[0]


@eager
def _get_all_commands():
    proc = subprocess.Popen(['gem', 'help', 'commands'],
                            stdout=subprocess.PIPE)

    for line in proc.stdout.readlines():
        line = line.decode()

        if line.startswith('    '):
            yield line.strip().split(' ')[0]


if which('gem'):
    _get_all_commands = cache(which('gem'))(_get_all_commands)


def get_new_command(command):
    unknown_command = _get_unknown_command(command)
    all_commands = _get_all_commands()
    return replace_command(command, unknown_command, all_commands)
<EOF>
<BOF>
from thefuck import utils
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    if command.script_parts and len(command.script_parts) > 1:
        return (command.script_parts[1] == 'stash'
                and 'usage:' in command.output)
    else:
        return False


# git's output here is too complicated to be parsed (see the test file)
stash_commands = (
    'apply',
    'branch',
    'clear',
    'drop',
    'list',
    'pop',
    'save',
    'show')


@git_support
def get_new_command(command):
    stash_cmd = command.script_parts[2]
    fixed = utils.get_closest(stash_cmd, stash_commands, fallback_to_first=False)

    if fixed is not None:
        return replace_argument(command.script, stash_cmd, fixed)
    else:
        cmd = command.script_parts[:]
        cmd.insert(2, 'save')
        return ' '.join(cmd)
<EOF>
<BOF>
import os
from thefuck.specific.sudo import sudo_support


def _get_destination(script_parts):
    """When arguments order is wrong first argument will be destination."""
    for part in script_parts:
        if part not in {'ln', '-s', '--symbolic'} and os.path.exists(part):
            return part


@sudo_support
def match(command):
    return (command.script_parts[0] == 'ln'
            and {'-s', '--symbolic'}.intersection(command.script_parts)
            and 'File exists' in command.output
            and _get_destination(command.script_parts))


@sudo_support
def get_new_command(command):
    destination = _get_destination(command.script_parts)
    parts = command.script_parts[:]
    parts.remove(destination)
    parts.append(destination)
    return ' '.join(parts)
<EOF>
<BOF>
import re
from thefuck.specific.apt import apt_available
from thefuck.utils import for_app

enabled_by_default = apt_available


@for_app('apt-get')
def match(command):
    return command.script.startswith('apt-get search')


def get_new_command(command):
    return re.sub(r'^apt-get', 'apt-cache', command.script)
<EOF>
<BOF>
# -*- encoding: utf-8 -*-
from six.moves.urllib.parse import urlparse
from thefuck.utils import for_app


@for_app('whois', at_least=1)
def match(command):
    """
    What the `whois` command returns depends on the 'Whois server' it contacted
    and is not consistent through different servers. But there can be only two
    types of errors I can think of with `whois`:
        - `whois https://en.wikipedia.org/` → `whois en.wikipedia.org`;
        - `whois en.wikipedia.org` → `whois wikipedia.org`.
    So we match any `whois` command and then:
        - if there is a slash: keep only the FQDN;
        - if there is no slash but there is a point: removes the left-most
          subdomain.

    We cannot either remove all subdomains because we cannot know which part is
    the subdomains and which is the domain, consider:
        - www.google.fr → subdomain: www, domain: 'google.fr';
        - google.co.uk → subdomain: None, domain; 'google.co.uk'.
    """
    return True


def get_new_command(command):
    url = command.script_parts[1]

    if '/' in command.script:
        return 'whois ' + urlparse(url).netloc
    elif '.' in command.script:
        path = urlparse(url).path.split('.')
        return ['whois ' + '.'.join(path[n:]) for n in range(1, len(path))]
<EOF>
<BOF>
from thefuck.shells import shell
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('pull' in command.script
            and ('You have unstaged changes' in command.output
                 or 'contains uncommitted changes' in command.output))


@git_support
def get_new_command(command):
    return shell.and_('git stash', 'git pull', 'git stash pop')
<EOF>
<BOF>
import re
from subprocess import Popen, PIPE
from thefuck.utils import memoize, which
from thefuck.shells import shell

enabled_by_default = bool(which('lsof'))

patterns = [r"bind on address \('.*', (?P<port>\d+)\)",
            r'Unable to bind [^ ]*:(?P<port>\d+)',
            r"can't listen on port (?P<port>\d+)",
            r'listen EADDRINUSE [^ ]*:(?P<port>\d+)']


@memoize
def _get_pid_by_port(port):
    proc = Popen(['lsof', '-i', ':{}'.format(port)], stdout=PIPE)
    lines = proc.stdout.read().decode().split('\n')
    if len(lines) > 1:
        return lines[1].split()[1]
    else:
        return None


@memoize
def _get_used_port(command):
    for pattern in patterns:
        matched = re.search(pattern, command.output)
        if matched:
            return matched.group('port')


def match(command):
    port = _get_used_port(command)
    return port and _get_pid_by_port(port)


def get_new_command(command):
    port = _get_used_port(command)
    pid = _get_pid_by_port(port)
    return shell.and_(u'kill {}'.format(pid), command.script)
<EOF>
<BOF>
import re
from thefuck.utils import for_app


@for_app('heroku')
def match(command):
    return 'Run heroku _ to run' in command.output


def get_new_command(command):
    return re.findall('Run heroku _ to run ([^.]*)', command.output)[0]
<EOF>
<BOF>
import re
from thefuck.utils import for_app


@for_app('heroku')
def match(command):
    return 'https://devcenter.heroku.com/articles/multiple-environments' in command.output


def get_new_command(command):
    apps = re.findall('([^ ]*) \\([^)]*\\)', command.output)
    return [command.script + ' --app ' + app for app in apps]
<EOF>
<BOF>
import re
from subprocess import Popen, PIPE
from thefuck.utils import for_app, eager, get_closest, cache

regex = re.compile(r'Warning: Task "(.*)" not found.')


@for_app('grunt')
def match(command):
    return regex.findall(command.output)


@cache('Gruntfile.js')
@eager
def _get_all_tasks():
    proc = Popen(['grunt', '--help'], stdout=PIPE)
    should_yield = False
    for line in proc.stdout.readlines():
        line = line.decode().strip()

        if 'Available tasks' in line:
            should_yield = True
            continue

        if should_yield and not line:
            return

        if '  ' in line:
            yield line.split(' ')[0]


def get_new_command(command):
    misspelled_task = regex.findall(command.output)[0].split(':')[0]
    tasks = _get_all_tasks()
    fixed = get_closest(misspelled_task, tasks)
    return command.script.replace(' {}'.format(misspelled_task),
                                  ' {}'.format(fixed))
<EOF>
<BOF>
from thefuck.shells import shell
from thefuck.specific.git import git_support


@git_support
def match(command):
    return 'pull' in command.script and 'set-upstream' in command.output


@git_support
def get_new_command(command):
    line = command.output.split('\n')[-3].strip()
    branch = line.split(' ')[-1]
    set_upstream = line.replace('<remote>', 'origin')\
                       .replace('<branch>', branch)
    return shell.and_(set_upstream, command.script)
<EOF>
<BOF>
patterns = ['you cannot perform this operation as root']


def match(command):
    if command.script_parts and command.script_parts[0] != 'sudo':
        return False

    for pattern in patterns:
        if pattern in command.output.lower():
            return True
    return False


def get_new_command(command):
    return ' '.join(command.script_parts[1:])
<EOF>
<BOF>
from thefuck.utils import get_close_matches, get_closest, \
    get_valid_history_without_current


def match(command):
    return len(get_close_matches(command.script,
                                 get_valid_history_without_current(command)))


def get_new_command(command):
    return get_closest(command.script,
                       get_valid_history_without_current(command))


priority = 9999
<EOF>
<BOF>
from thefuck.specific.git import git_support


@git_support
def match(command):
    return (' rm ' in command.script and
            'error: the following file has local modifications' in command.output and
            'use --cached to keep the file, or -f to force removal' in command.output)


@git_support
def get_new_command(command):
    command_parts = command.script_parts[:]
    index = command_parts.index('rm') + 1
    command_parts.insert(index, '--cached')
    command_list = [u' '.join(command_parts)]
    command_parts[index] = '-f'
    command_list.append(u' '.join(command_parts))
    return command_list
<EOF>
<BOF>
from thefuck.shells import shell
from thefuck.utils import for_app


@for_app('tsuru')
def match(command):
    return ('not authenticated' in command.output
            and 'session has expired' in command.output)


def get_new_command(command):
    return shell.and_('tsuru login', command.script)
<EOF>
<BOF>
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('commit' in command.script_parts)


@git_support
def get_new_command(command):
    return 'git commit --amend'
<EOF>
<BOF>
import re
from thefuck.utils import replace_command


def match(command):
    return (re.search(r"([^:]*): Unknown command.*", command.output) is not None
            and re.search(r"Did you mean ([^?]*)?", command.output) is not None)


def get_new_command(command):
    broken_cmd = re.findall(r"([^:]*): Unknown command.*", command.output)[0]
    matched = re.findall(r"Did you mean ([^?]*)?", command.output)
    return replace_command(command, broken_cmd, matched)
<EOF>
<BOF>
import os
from thefuck.shells import shell


def match(command):
    return (command.script.startswith('./')
            and 'permission denied' in command.output.lower()
            and os.path.exists(command.script_parts[0])
            and not os.access(command.script_parts[0], os.X_OK))


def get_new_command(command):
    return shell.and_(
        'chmod +x {}'.format(command.script_parts[0][2:]),
        command.script)
<EOF>
<BOF>
import re
from subprocess import Popen, PIPE
from thefuck.utils import for_app, eager, replace_command

regex = re.compile(r"Task '(.*)' (is ambiguous|not found)")


@for_app('gradle', './gradlew')
def match(command):
    return regex.findall(command.output)


@eager
def _get_all_tasks(gradle):
    proc = Popen([gradle, 'tasks'], stdout=PIPE)
    should_yield = False
    for line in proc.stdout.readlines():
        line = line.decode().strip()
        if line.startswith('----'):
            should_yield = True
            continue

        if not line.strip():
            should_yield = False
            continue

        if should_yield and not line.startswith('All tasks runnable from root project'):
            yield line.split(' ')[0]


def get_new_command(command):
    wrong_task = regex.findall(command.output)[0][0]
    all_tasks = _get_all_tasks(command.script_parts[0])
    return replace_command(command, wrong_task, all_tasks)
<EOF>
<BOF>
def match(command):
    return 'manage.py' in command.script and \
           'migrate' in command.script \
           and 'or pass --delete-ghost-migrations' in command.output


def get_new_command(command):
    return u'{} --delete-ghost-migrations'.format(command.script)
<EOF>
<BOF>
import re
from thefuck.utils import for_app

regex = re.compile(r'Run "(.*)" instead')


@for_app('yarn', at_least=1)
def match(command):
    return regex.findall(command.output)


def get_new_command(command):
    return regex.findall(command.output)[0]
<EOF>
<BOF>
from thefuck.shells import shell
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('push' in command.script and
            '! [rejected]' in command.output and
            'failed to push some refs to' in command.output and
            ('Updates were rejected because the tip of your'
             ' current branch is behind' in command.output or
             'Updates were rejected because the remote '
             'contains work that you do' in command.output))


@git_support
def get_new_command(command):
    return shell.and_(replace_argument(command.script, 'push', 'pull'),
                      command.script)
<EOF>
<BOF>
import re
from thefuck.utils import replace_command, get_all_matched_commands, for_app
from thefuck.specific.sudo import sudo_support


@sudo_support
@for_app('lein')
def match(command):
    return (command.script.startswith('lein')
            and "is not a task. See 'lein help'" in command.output
            and 'Did you mean this?' in command.output)


@sudo_support
def get_new_command(command):
    broken_cmd = re.findall(r"'([^']*)' is not a task",
                            command.output)[0]
    new_cmds = get_all_matched_commands(command.output, 'Did you mean this?')
    return replace_command(command, broken_cmd, new_cmds)
<EOF>
<BOF>
import re
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app


@sudo_support
@for_app('cp')
def match(command):
    output = command.output.lower()
    return 'omitting directory' in output or 'is a directory' in output


@sudo_support
def get_new_command(command):
    return re.sub(r'^cp', 'cp -a', command.script)
<EOF>
<BOF>
import re
import subprocess
from thefuck.utils import replace_command, for_app, cache


@for_app('gulp')
def match(command):
    return 'is not in your gulpfile' in command.output


@cache('gulpfile.js')
def get_gulp_tasks():
    proc = subprocess.Popen(['gulp', '--tasks-simple'],
                            stdout=subprocess.PIPE)
    return [line.decode('utf-8')[:-1]
            for line in proc.stdout.readlines()]


def get_new_command(command):
    wrong_task = re.findall(r"Task '(\w+)' is not in your gulpfile",
                            command.output)[0]
    return replace_command(command, wrong_task, get_gulp_tasks())
<EOF>
<BOF>
import re
from thefuck.utils import for_app, replace_command
from thefuck.specific.npm import get_scripts, npm_available

enabled_by_default = npm_available


@for_app('npm')
def match(command):
    return (any(part.startswith('ru') for part in command.script_parts)
            and 'npm ERR! missing script: ' in command.output)


def get_new_command(command):
    misspelled_script = re.findall(
        r'.*missing script: (.*)\n', command.output)[0]
    return replace_command(command, misspelled_script, get_scripts())
<EOF>
<BOF>
import os
from thefuck.utils import for_app, which


@for_app('gradle')
def match(command):
    return (not which(command.script_parts[0])
            and 'not found' in command.output
            and os.path.isfile('gradlew'))


def get_new_command(command):
    return u'./gradlew {}'.format(' '.join(command.script_parts[1:]))
<EOF>
<BOF>
from thefuck.specific.npm import npm_available
from thefuck.utils import replace_argument, for_app, eager, get_closest
from thefuck.specific.sudo import sudo_support

enabled_by_default = npm_available


def _get_wrong_command(script_parts):
    commands = [part for part in script_parts[1:] if not part.startswith('-')]
    if commands:
        return commands[0]


@sudo_support
@for_app('npm')
def match(command):
    return (command.script_parts[0] == 'npm' and
            'where <command> is one of:' in command.output and
            _get_wrong_command(command.script_parts))


@eager
def _get_available_commands(stdout):
    commands_listing = False
    for line in stdout.split('\n'):
        if line.startswith('where <command> is one of:'):
            commands_listing = True
        elif commands_listing:
            if not line:
                break

            for command in line.split(', '):
                stripped = command.strip()
                if stripped:
                    yield stripped


def get_new_command(command):
    npm_commands = _get_available_commands(command.output)
    wrong_command = _get_wrong_command(command.script_parts)
    fixed = get_closest(wrong_command, npm_commands)
    return replace_argument(command.script, wrong_command, fixed)
<EOF>
<BOF>
import re
from subprocess import Popen, PIPE
from thefuck.utils import (for_app, eager, replace_command, replace_argument,
                           cache, which)

regex = re.compile(r'error Command "(.*)" not found.')


@for_app('yarn')
def match(command):
    return regex.findall(command.output)


npm_commands = {'require': 'add'}


@eager
def _get_all_tasks():
    proc = Popen(['yarn', '--help'], stdout=PIPE)
    should_yield = False
    for line in proc.stdout.readlines():
        line = line.decode().strip()

        if 'Commands:' in line:
            should_yield = True
            continue

        if should_yield and '- ' in line:
            yield line.split(' ')[-1]


if which('yarn'):
    _get_all_tasks = cache(which('yarn'))(_get_all_tasks)


def get_new_command(command):
    misspelled_task = regex.findall(command.output)[0]
    if misspelled_task in npm_commands:
        yarn_command = npm_commands[misspelled_task]
        return replace_argument(command.script, misspelled_task, yarn_command)
    else:
        tasks = _get_all_tasks()
        return replace_command(command, misspelled_task, tasks)
<EOF>
<BOF>
from thefuck.utils import get_all_executables, memoize


@memoize
def _get_executable(script_part):
    for executable in get_all_executables():
        if script_part.startswith(executable):
            return executable


def match(command):
    return (not command.script_parts[0] in get_all_executables()
            and _get_executable(command.script_parts[0]))


def get_new_command(command):
    executable = _get_executable(command.script_parts[0])
    return command.script.replace(executable, u'{} '.format(executable), 1)


priority = 4000
<EOF>
<BOF>
from types import ModuleType
from thefuck.specific.apt import apt_available
from thefuck.utils import memoize, which
from thefuck.shells import shell

try:
    from CommandNotFound import CommandNotFound

    enabled_by_default = apt_available

    if isinstance(CommandNotFound, ModuleType):
        # For ubuntu 18.04+
        _get_packages = CommandNotFound.CommandNotFound().get_packages
    else:
        # For older versions
        _get_packages = CommandNotFound().getPackages
except ImportError:
    enabled_by_default = False


def _get_executable(command):
    if command.script_parts[0] == 'sudo':
        return command.script_parts[1]
    else:
        return command.script_parts[0]


@memoize
def get_package(executable):
    try:
        packages = _get_packages(executable)
        return packages[0][0]
    except IndexError:
        # IndexError is thrown when no matching package is found
        return None


def match(command):
    if 'not found' in command.output or 'not installed' in command.output:
        executable = _get_executable(command)
        return not which(executable) and get_package(executable)
    else:
        return False


def get_new_command(command):
    executable = _get_executable(command)
    name = get_package(executable)
    formatme = shell.and_('sudo apt-get install {}', '{}')
    return formatme.format(name, command.script)
<EOF>
<BOF>
# Opens URL's in the default web browser
#
# Example:
# > open github.com
# The file ~/github.com does not exist.
# Perhaps you meant 'http://github.com'?
#
from thefuck.shells import shell
from thefuck.utils import eager, for_app


def is_arg_url(command):
    return ('.com' in command.script or
            '.edu' in command.script or
            '.info' in command.script or
            '.io' in command.script or
            '.ly' in command.script or
            '.me' in command.script or
            '.net' in command.script or
            '.org' in command.script or
            '.se' in command.script or
            'www.' in command.script)


@for_app('open', 'xdg-open', 'gnome-open', 'kde-open')
def match(command):
    return (is_arg_url(command) or
            command.output.strip().startswith('The file ') and
            command.output.strip().endswith(' does not exist.'))


@eager
def get_new_command(command):
    output = command.output.strip()
    if is_arg_url(command):
        yield command.script.replace('open ', 'open http://')
    elif output.startswith('The file ') and output.endswith(' does not exist.'):
        arg = command.script.split(' ', 1)[1]
        for option in ['touch', 'mkdir']:
            yield shell.and_(u'{} {}'.format(option, arg), command.script)
<EOF>
<BOF>
from thefuck.utils import eager, get_closest, for_app


@for_app('fab')
def match(command):
    return 'Warning: Command(s) not found:' in command.output


# We need different behavior then in get_all_matched_commands.
@eager
def _get_between(content, start, end=None):
    should_yield = False
    for line in content.split('\n'):
        if start in line:
            should_yield = True
            continue

        if end and end in line:
            return

        if should_yield and line:
            yield line.strip().split(' ')[0]


def get_new_command(command):
    not_found_commands = _get_between(
        command.output, 'Warning: Command(s) not found:',
        'Available commands:')
    possible_commands = _get_between(
        command.output, 'Available commands:')

    script = command.script
    for not_found in not_found_commands:
        fix = get_closest(not_found, possible_commands)
        script = script.replace(' {}'.format(not_found),
                                ' {}'.format(fix))

    return script
<EOF>
<BOF>
from thefuck.utils import is_app, get_closest, replace_argument


_ADB_COMMANDS = (
    'backup',
    'bugreport',
    'connect',
    'devices',
    'disable-verity',
    'disconnect',
    'enable-verity',
    'emu',
    'forward',
    'get-devpath',
    'get-serialno',
    'get-state',
    'install',
    'install-multiple',
    'jdwp',
    'keygen',
    'kill-server',
    'logcat',
    'pull',
    'push',
    'reboot',
    'reconnect',
    'restore',
    'reverse',
    'root',
    'run-as',
    'shell',
    'sideload',
    'start-server',
    'sync',
    'tcpip',
    'uninstall',
    'unroot',
    'usb',
    'wait-for',
)


def match(command):
    return (is_app(command, 'adb')
            and command.output.startswith('Android Debug Bridge version'))


def get_new_command(command):
    for idx, arg in enumerate(command.script_parts[1:]):
        # allowed params to ADB are a/d/e/s/H/P/L where s, H, P and L take additional args
        # for example 'adb -s 111 logcat' or 'adb -e logcat'
        if not arg[0] == '-' and not command.script_parts[idx] in ('-s', '-H', '-P', '-L'):
            adb_cmd = get_closest(arg, _ADB_COMMANDS)
            return replace_argument(command.script, arg, adb_cmd)
<EOF>
<BOF>
def match(command):
    return command.script == 'cargo'


def get_new_command(command):
    return 'cargo build'
<EOF>
<BOF>
import os
from thefuck.utils import for_app


@for_app('cat', at_least=1)
def match(command):
    return (
        command.output.startswith('cat: ') and
        os.path.isdir(command.script_parts[1])
    )


def get_new_command(command):
    return command.script.replace('cat', 'ls', 1)
<EOF>
<BOF>
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('branch -d' in command.script
            and 'If you are sure you want to delete it' in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, '-d', '-D')
<EOF>
<BOF>
import os
import re
from thefuck.utils import get_closest, replace_command
from thefuck.specific.brew import get_brew_path_prefix, brew_available

BREW_CMD_PATH = '/Library/Homebrew/cmd'
TAP_PATH = '/Library/Taps'
TAP_CMD_PATH = '/%s/%s/cmd'

enabled_by_default = brew_available


def _get_brew_commands(brew_path_prefix):
    """To get brew default commands on local environment"""
    brew_cmd_path = brew_path_prefix + BREW_CMD_PATH

    return [name[:-3] for name in os.listdir(brew_cmd_path)
            if name.endswith(('.rb', '.sh'))]


def _get_brew_tap_specific_commands(brew_path_prefix):
    """To get tap's specific commands
    https://github.com/Homebrew/homebrew/blob/master/Library/brew.rb#L115"""
    commands = []
    brew_taps_path = brew_path_prefix + TAP_PATH

    for user in _get_directory_names_only(brew_taps_path):
        taps = _get_directory_names_only(brew_taps_path + '/%s' % user)

        # Brew Taps's naming rule
        # https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/brew-tap.md#naming-conventions-and-limitations
        taps = (tap for tap in taps if tap.startswith('homebrew-'))
        for tap in taps:
            tap_cmd_path = brew_taps_path + TAP_CMD_PATH % (user, tap)

            if os.path.isdir(tap_cmd_path):
                commands += (name.replace('brew-', '').replace('.rb', '')
                             for name in os.listdir(tap_cmd_path)
                             if _is_brew_tap_cmd_naming(name))

    return commands


def _is_brew_tap_cmd_naming(name):
    return name.startswith('brew-') and name.endswith('.rb')


def _get_directory_names_only(path):
    return [d for d in os.listdir(path)
            if os.path.isdir(os.path.join(path, d))]


def _brew_commands():
    brew_path_prefix = get_brew_path_prefix()
    if brew_path_prefix:
        try:
            return (_get_brew_commands(brew_path_prefix)
                    + _get_brew_tap_specific_commands(brew_path_prefix))
        except OSError:
            pass

    # Failback commands for testing (Based on Homebrew 0.9.5)
    return ['info', 'home', 'options', 'install', 'uninstall',
            'search', 'list', 'update', 'upgrade', 'pin', 'unpin',
            'doctor', 'create', 'edit']


def match(command):
    is_proper_command = ('brew' in command.script and
                         'Unknown command' in command.output)

    if is_proper_command:
        broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',
                                command.output)[0]
        return bool(get_closest(broken_cmd, _brew_commands()))
    return False


def get_new_command(command):
    broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',
                            command.output)[0]
    return replace_command(command, broken_cmd, _brew_commands())
<EOF>
<BOF>
"""
The confusion in systemctl's param order is massive.
"""
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app


@sudo_support
@for_app('systemctl')
def match(command):
    # Catches "Unknown operation 'service'." when executing systemctl with
    # misordered arguments
    cmd = command.script_parts
    return (cmd and 'Unknown operation \'' in command.output and
            len(cmd) - cmd.index('systemctl') == 3)


@sudo_support
def get_new_command(command):
    cmd = command.script_parts[:]
    cmd[-1], cmd[-2] = cmd[-2], cmd[-1]
    return ' '.join(cmd)
<EOF>
<BOF>
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('add' in command.script_parts
            and 'Use -f if you really want to add them.' in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'add', 'add --force')
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('ag')
def match(command):
    return command.output.endswith('run ag with -Q\n')


def get_new_command(command):
    return command.script.replace('ag', 'ag -Q', 1)
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('brew', at_least=2)
def match(command):
    return (command.script_parts[1] in ['uninstall', 'rm', 'remove']
            and "brew uninstall --force" in command.output)


def get_new_command(command):
    command_parts = command.script_parts[:]
    command_parts[1] = 'uninstall'
    command_parts.insert(2, '--force')
    return ' '.join(command_parts)
<EOF>
<BOF>
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('set-url' in command.script
            and 'fatal: No such remote' in command.output)


def get_new_command(command):
    return replace_argument(command.script, 'set-url', 'add')
<EOF>
<BOF>
# -*- coding: utf-8 -*-
"""Suggest creating symbolic link if hard link is not allowed.

Example:
> ln barDir barLink
ln: ‘barDir’: hard link not allowed for directory

--> ln -s barDir barLink
"""

import re
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return (command.output.endswith("hard link not allowed for directory") and
            command.script_parts[0] == 'ln')


@sudo_support
def get_new_command(command):
    return re.sub(r'^ln ', 'ln -s ', command.script)
<EOF>
<BOF>
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('diff' in command.script and
            '--staged' not in command.script)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'diff', 'diff --staged')
<EOF>
<BOF>
from thefuck.specific.apt import apt_available
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app

enabled_by_default = apt_available


@sudo_support
@for_app('apt')
def match(command):
    return command.script == "apt list --upgradable" and len(command.output.strip().split('\n')) > 1


@sudo_support
def get_new_command(command):
    return 'apt upgrade'
<EOF>
<BOF>
from thefuck.shells import shell
from thefuck.utils import for_app


@for_app('vagrant')
def match(command):
    return 'run `vagrant up`' in command.output.lower()


def get_new_command(command):
    cmds = command.script_parts
    machine = None
    if len(cmds) >= 3:
        machine = cmds[2]

    start_all_instances = shell.and_(u"vagrant up", command.script)
    if machine is None:
        return start_all_instances
    else:
        return [shell.and_(u"vagrant up {}".format(machine), command.script),
                start_all_instances]
<EOF>
<BOF>
import re
from thefuck.specific.git import git_support

fix = u'git commit -m "Initial commit." && {command}'
refspec_does_not_match = re.compile(r'src refspec \w+ does not match any\.')


@git_support
def match(command):
    return bool(refspec_does_not_match.search(command.output))


def get_new_command(command):
    return fix.format(command=command.script)
<EOF>
<BOF>
from thefuck.specific.apt import apt_available
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app

enabled_by_default = apt_available


@sudo_support
@for_app('apt')
def match(command):
    return "Run 'apt list --upgradable' to see them." in command.output


@sudo_support
def get_new_command(command):
    return 'apt list --upgradable'
<EOF>
<BOF>
import re
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('merge' in command.script
            and ' - not something we can merge' in command.output
            and 'Did you mean this?' in command.output)


@git_support
def get_new_command(command):
    unknown_branch = re.findall(r'merge: (.+) - not something we can merge', command.output)[0]
    remote_branch = re.findall(r'Did you mean this\?\n\t([^\n]+)', command.output)[0]

    return replace_argument(command.script, unknown_branch, remote_branch)
<EOF>
<BOF>
import re
from thefuck.shells import shell


patterns = (
    r"mv: cannot move '[^']*' to '([^']*)': No such file or directory",
    r"mv: cannot move '[^']*' to '([^']*)': Not a directory",
    r"cp: cannot create regular file '([^']*)': No such file or directory",
    r"cp: cannot create regular file '([^']*)': Not a directory",
)


def match(command):
    for pattern in patterns:
        if re.search(pattern, command.output):
            return True

    return False


def get_new_command(command):
    for pattern in patterns:
        file = re.findall(pattern, command.output)

        if file:
            file = file[0]
            dir = file[0:file.rfind('/')]

            formatme = shell.and_('mkdir -p {}', '{}')
            return formatme.format(dir, command.script)
<EOF>
<BOF>
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('tag' in command.script_parts
            and 'already exists' in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'tag', 'tag --force')
<EOF>
<BOF>
from thefuck.utils import for_app, memoize
from thefuck.system import Path

path_to_scm = {
    '.git': 'git',
    '.hg': 'hg',
}

wrong_scm_patterns = {
    'git': 'fatal: Not a git repository',
    'hg': 'abort: no repository found',
}


@memoize
def _get_actual_scm():
    for path, scm in path_to_scm.items():
        if Path(path).is_dir():
            return scm


@for_app(*wrong_scm_patterns.keys())
def match(command):
    scm = command.script_parts[0]
    pattern = wrong_scm_patterns[scm]

    return pattern in command.output and _get_actual_scm()


def get_new_command(command):
    scm = _get_actual_scm()
    return u' '.join([scm] + command.script_parts[1:])
<EOF>
<BOF>
import re
from thefuck.shells import shell
from thefuck.specific.git import git_support
from thefuck.utils import eager


@git_support
def match(command):
    return ("fatal: A branch named '" in command.output
            and "' already exists." in command.output)


@git_support
@eager
def get_new_command(command):
    branch_name = re.findall(
        r"fatal: A branch named '(.+)' already exists.", command.output)[0]
    branch_name = branch_name.replace("'", r"\'")
    new_command_templates = [['git branch -d {0}', 'git branch {0}'],
                             ['git branch -d {0}', 'git checkout -b {0}'],
                             ['git branch -D {0}', 'git branch {0}'],
                             ['git branch -D {0}', 'git checkout -b {0}'],
                             ['git checkout {0}']]
    for new_command_template in new_command_templates:
        yield shell.and_(*new_command_template).format(branch_name)
<EOF>
<BOF>
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    files = [arg for arg in command.script_parts[2:]
             if not arg.startswith('-')]
    return ('diff' in command.script
            and '--no-index' not in command.script
            and len(files) == 2)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'diff', 'diff --no-index')
<EOF>
<BOF>
# Fixes careless " and ' usage
#
# Example:
# > git commit -m 'My Message"


def match(command):
    return '\'' in command.script and '\"' in command.script


def get_new_command(command):
    return command.script.replace('\'', '\"')
<EOF>
<BOF>
import re

from thefuck.utils import for_app, replace_argument

INVALID_CHOICE = "(?=az)(?:.*): '(.*)' is not in the '.*' command group."
OPTIONS = "^The most similar choice to '.*' is:\n\\s*(.*)$"


@for_app('az')
def match(command):
    return "is not in the" in command.output and "command group" in command.output


def get_new_command(command):
    mistake = re.search(INVALID_CHOICE, command.output).group(1)
    options = re.findall(OPTIONS, command.output, flags=re.MULTILINE)
    return [replace_argument(command.script, mistake, o) for o in options]
<EOF>
<BOF>
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('error: did you mean `' in command.output
            and '` (with two dashes ?)' in command.output)


@git_support
def get_new_command(command):
    to = command.output.split('`')[1]
    return replace_argument(command.script, to[1:], to)
<EOF>
<BOF>
"""Attempts to spellcheck and correct failed cd commands"""

import os
import six
from thefuck.specific.sudo import sudo_support
from thefuck.rules import cd_mkdir
from thefuck.utils import for_app, get_close_matches

__author__ = "mmussomele"

MAX_ALLOWED_DIFF = 0.6


def _get_sub_dirs(parent):
    """Returns a list of the child directories of the given parent directory"""
    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]


@sudo_support
@for_app('cd')
def match(command):
    """Match function copied from cd_mkdir.py"""
    return (
        command.script.startswith('cd ') and any((
            'no such file or directory' in command.output.lower(),
            'cd: can\'t cd to' in command.output.lower(),
            'does not exist' in command.output.lower()
        )))


@sudo_support
def get_new_command(command):
    """
    Attempt to rebuild the path string by spellchecking the directories.
    If it fails (i.e. no directories are a close enough match), then it
    defaults to the rules of cd_mkdir.
    Change sensitivity by changing MAX_ALLOWED_DIFF. Default value is 0.6
    """
    dest = command.script_parts[1].split(os.sep)
    if dest[-1] == '':
        dest = dest[:-1]

    if dest[0] == '':
        cwd = os.sep
        dest = dest[1:]
    elif six.PY2:
        cwd = os.getcwdu()
    else:
        cwd = os.getcwd()
    for directory in dest:
        if directory == ".":
            continue
        elif directory == "..":
            cwd = os.path.split(cwd)[0]
            continue
        best_matches = get_close_matches(directory, _get_sub_dirs(cwd), cutoff=MAX_ALLOWED_DIFF)
        if best_matches:
            cwd = os.path.join(cwd, best_matches[0])
        else:
            return cd_mkdir.get_new_command(command)
    return u'cd "{0}"'.format(cwd)
<EOF>
<BOF>
from thefuck.shells import shell
from thefuck.specific.git import git_support


@git_support
def match(command):
    # catches "Please commit or stash them" and "Please, commit your changes or
    # stash them before you can switch branches."
    return 'or stash them' in command.output


@git_support
def get_new_command(command):
    formatme = shell.and_('git stash', '{}')
    return formatme.format(command.script)
<EOF>
<BOF>
from thefuck.specific.archlinux import get_pkgfile, archlinux_env
from thefuck.shells import shell


def match(command):
    return 'not found' in command.output and get_pkgfile(command.script)


def get_new_command(command):
    packages = get_pkgfile(command.script)

    formatme = shell.and_('{} -S {}', '{}')
    return [formatme.format(pacman, package, command.script)
            for package in packages]


enabled_by_default, pacman = archlinux_env()
<EOF>
<BOF>
import os
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return command.script_parts and os.path.exists(command.script_parts[0]) \
        and 'command not found' in command.output


@sudo_support
def get_new_command(command):
    return u'./{}'.format(command.script)
<EOF>
<BOF>
from thefuck.utils import get_all_executables, get_close_matches, \
    get_valid_history_without_current, get_closest, which
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return (not which(command.script_parts[0])
            and 'not found' in command.output
            and bool(get_close_matches(command.script_parts[0],
                                       get_all_executables())))


def _get_used_executables(command):
    for script in get_valid_history_without_current(command):
        yield script.split(' ')[0]


@sudo_support
def get_new_command(command):
    old_command = command.script_parts[0]

    # One from history:
    already_used = get_closest(
        old_command, _get_used_executables(command),
        fallback_to_first=False)
    if already_used:
        new_cmds = [already_used]
    else:
        new_cmds = []

    # Other from all executables:
    new_cmds += [cmd for cmd in get_close_matches(old_command,
                                                  get_all_executables())
                 if cmd not in new_cmds]

    return [' '.join([new_command] + command.script_parts[1:])
            for new_command in new_cmds]


priority = 3000
<EOF>
<BOF>
patterns = ['permission denied',
            'eacces',
            'pkg: insufficient privileges',
            'you cannot perform this operation unless you are root',
            'non-root users cannot',
            'operation not permitted',
            'root privilege',
            'this command has to be run under the root user.',
            'this operation requires root.',
            'requested operation requires superuser privilege',
            'must be run as root',
            'must run as root',
            'must be superuser',
            'must be root',
            'need to be root',
            'need root',
            'needs to be run as root',
            'only root can ',
            'you don\'t have access to the history db.',
            'authentication is required',
            'edspermissionerror',
            'you don\'t have write permissions',
            'use `sudo`',
            'SudoRequiredError',
            'error: insufficient privileges']


def match(command):
    if command.script_parts and '&&' not in command.script_parts and command.script_parts[0] == 'sudo':
        return False

    for pattern in patterns:
        if pattern in command.output.lower():
            return True
    return False


def get_new_command(command):
    if '&&' in command.script:
        return u'sudo sh -c "{}"'.format(" ".join([part for part in command.script_parts if part != "sudo"]))
    elif '>' in command.script:
        return u'sudo sh -c "{}"'.format(command.script.replace('"', '\\"'))
    else:
        return u'sudo {}'.format(command.script)
<EOF>
<BOF>
import re
from thefuck.shells import shell
from thefuck.utils import for_app


@for_app('touch')
def match(command):
    return 'No such file or directory' in command.output


def get_new_command(command):
    path = path = re.findall(
        r"touch: (?:cannot touch ')?(.+)/.+'?:", command.output)[0]
    return shell.and_(u'mkdir -p {}'.format(path), command.script)
<EOF>
<BOF>
import re
from thefuck.utils import get_all_matched_commands, replace_command, for_app


@for_app('tsuru')
def match(command):
    return (' is not a tsuru command. See "tsuru help".' in command.output
            and '\nDid you mean?\n\t' in command.output)


def get_new_command(command):
    broken_cmd = re.findall(r'tsuru: "([^"]*)" is not a tsuru command',
                            command.output)[0]
    return replace_command(command, broken_cmd,
                           get_all_matched_commands(command.output))
<EOF>
<BOF>
from thefuck.shells import shell
from thefuck.specific.git import git_support


@git_support
def match(command):
    # catches "git branch list" in place of "git branch"
    return (command.script_parts
            and command.script_parts[1:] == 'branch list'.split())


@git_support
def get_new_command(command):
    return shell.and_('git branch --delete list', 'git branch')
<EOF>
<BOF>
from thefuck.specific.git import git_support


@git_support
def match(command):
    return (
        {'rebase', '--continue'}.issubset(command.script_parts) and
        'No changes - did you forget to use \'git add\'?' in command.output
    )


def get_new_command(command):
    return 'git rebase --skip'
<EOF>
<BOF>
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('fatal: Not a git repository' in command.output
            and "Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set)." in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'pull', 'clone')
<EOF>
<BOF>
def match(command):
    return (command.script.startswith(u'man')
            and u'command not found' in command.output.lower())


def get_new_command(command):
    return u'man {}'.format(command.script[3:])


priority = 2000
<EOF>
<BOF>
import os
import re
from thefuck.utils import get_closest, replace_argument
from thefuck.specific.brew import get_brew_path_prefix, brew_available

enabled_by_default = brew_available


def _get_formulas():
    # Formulas are based on each local system's status
    try:
        brew_path_prefix = get_brew_path_prefix()
        brew_formula_path = brew_path_prefix + '/Library/Formula'

        for file_name in os.listdir(brew_formula_path):
            if file_name.endswith('.rb'):
                yield file_name[:-3]
    except Exception:
        pass


def _get_similar_formula(formula_name):
    return get_closest(formula_name, _get_formulas(), cutoff=0.85)


def match(command):
    is_proper_command = ('brew install' in command.script and
                         'No available formula' in command.output)

    if is_proper_command:
        formula = re.findall(r'Error: No available formula for ([a-z]+)',
                             command.output)[0]
        return bool(_get_similar_formula(formula))
    return False


def get_new_command(command):
    not_exist_formula = re.findall(r'Error: No available formula for ([a-z]+)',
                                   command.output)[0]
    exist_formula = _get_similar_formula(not_exist_formula)

    return replace_argument(command.script, not_exist_formula, exist_formula)
<EOF>
<BOF>
import shlex
from thefuck.shells import shell
from thefuck.utils import for_app


@for_app('sed')
def match(command):
    return "unterminated `s' command" in command.output


def get_new_command(command):
    script = shlex.split(command.script)

    for (i, e) in enumerate(script):
        if e.startswith(('s/', '-es/')) and e[-1] != '/':
            script[i] += '/'

    return ' '.join(map(shell.quote, script))
<EOF>
<BOF>
import os
from thefuck.utils import for_app


def _is_recursive(part):
    if part == '--recurse':
        return True
    elif not part.startswith('--') and part.startswith('-') and 'r' in part:
        return True


def _isdir(part):
    return not part.startswith('-') and os.path.isdir(part)


@for_app('prove')
def match(command):
    return (
        'NOTESTS' in command.output
        and not any(_is_recursive(part) for part in command.script_parts[1:])
        and any(_isdir(part) for part in command.script_parts[1:]))


def get_new_command(command):
    parts = command.script_parts[:]
    parts.insert(1, '-r')
    return u' '.join(parts)
<EOF>
<BOF>
# -*- encoding: utf-8 -*-
from thefuck.utils import memoize, get_alias

target_layout = '''qwertyuiop[]asdfghjkl;'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:"ZXCVBNM<>?'''

source_layouts = [u'''йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,''',
                  u'''йцукенгшщзхїфівапролджєячсмитьбю.ЙЦУКЕНГШЩЗХЇФІВАПРОЛДЖЄЯЧСМИТЬБЮ,''',
                  u'''ضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو./ًٌٍَُِّْ][}{ؤئيإأآة»«:؛كٓژٰ‌ٔء><؟''',
                  u''';ςερτυθιοπ[]ασδφγηξκλ΄ζχψωβνμ,./:΅ΕΡΤΥΘΙΟΠ{}ΑΣΔΦΓΗΞΚΛ¨"ΖΧΨΩΒΝΜ<>?''',
                  u'''/'קראטוןםפ][שדגכעיחלךף,זסבהנמצתץ.QWERTYUIOP{}ASDFGHJKL:"ZXCVBNM<>?''']


@memoize
def _get_matched_layout(command):
    # don't use command.split_script here because a layout mismatch will likely
    # result in a non-splitable sript as per shlex
    cmd = command.script.split(' ')
    for source_layout in source_layouts:
        is_all_match = True

        for cmd_part in cmd:
            if not all([ch in source_layout or ch in '-_' for ch in cmd_part]):
                is_all_match = False
                break

        if is_all_match:
            return source_layout


def _switch(ch, layout):
    if ch in layout:
        return target_layout[layout.index(ch)]
    else:
        return ch


def _switch_command(command, layout):
    return ''.join(_switch(ch, layout) for ch in command.script)


def match(command):
    if 'not found' not in command.output:
        return False
    matched_layout = _get_matched_layout(command)
    return (matched_layout and
            _switch_command(command, matched_layout) != get_alias())


def get_new_command(command):
    matched_layout = _get_matched_layout(command)
    return _switch_command(command, matched_layout)
<EOF>
<BOF>
def match(command):
    return command.script == 'test.py' and 'not found' in command.output


def get_new_command(command):
    return 'py.test'


# make it come before the python_command rule
priority = 900
<EOF>
<BOF>
from thefuck.utils import for_app, eager
from thefuck.shells import shell
from thefuck.specific.brew import brew_available


@for_app('brew')
def match(command):
    return (u'install' in command.script_parts
            and u'brew cask install' in command.output)


@eager
def _get_cask_install_lines(output):
    for line in output.split('\n'):
        line = line.strip()
        if line.startswith('brew cask install'):
            yield line


def _get_script_for_brew_cask(output):
    cask_install_lines = _get_cask_install_lines(output)
    if len(cask_install_lines) > 1:
        return shell.and_(*cask_install_lines)
    else:
        return cask_install_lines[0]


def get_new_command(command):
    brew_cask_script = _get_script_for_brew_cask(command.output)
    return shell.and_(brew_cask_script, command.script)


enabled_by_default = brew_available
<EOF>
<BOF>
import re
from subprocess import Popen, PIPE
from thefuck.utils import for_app, replace_command, cache, eager


@for_app('react-native')
def match(command):
    return re.findall(r"Unrecognized command '.*'", command.output)


@cache('package.json')
@eager
def _get_commands():
    proc = Popen(['react-native', '--help'], stdout=PIPE)
    should_yield = False
    for line in proc.stdout.readlines():
        line = line.decode().strip()

        if not line:
            continue

        if 'Commands:' in line:
            should_yield = True
            continue

        if should_yield:
            yield line.split(' ')[0]


def get_new_command(command):
    misspelled_command = re.findall(r"Unrecognized command '(.*)'",
                                    command.output)[0]
    commands = _get_commands()
    return replace_command(command, misspelled_command, commands)
<EOF>
<BOF>
# Appends .py when executing python files
#
# Example:
# > python foo
# error: python: can't open file 'foo': [Errno 2] No such file or directory
from thefuck.utils import for_app


@for_app('python')
def match(command):
    return not command.script.endswith('.py')


def get_new_command(command):
    return command.script + '.py'
<EOF>
<BOF>
"""Fixes common java command mistake

Example:
> java foo.java
Error: Could not find or load main class foo.java

"""
from thefuck.utils import for_app


@for_app('java')
def match(command):
    return command.script.endswith('.java')


def get_new_command(command):
    return command.script[:-5]
<EOF>
<BOF>
from thefuck.specific.git import git_support


@git_support
def match(command):
    return 'help' in command.script and ' is aliased to ' in command.output


@git_support
def get_new_command(command):
    aliased = command.output.split('`', 2)[2].split("'", 1)[0].split(' ', 1)[0]
    return 'git help {}'.format(aliased)
<EOF>
<BOF>
import re
from thefuck.utils import for_app, which, replace_argument


def _get_command_name(command):
    found = re.findall(r'sudo: (.*): command not found', command.output)
    if found:
        return found[0]


@for_app('sudo')
def match(command):
    if 'command not found' in command.output:
        command_name = _get_command_name(command)
        return which(command_name)


def get_new_command(command):
    command_name = _get_command_name(command)
    return replace_argument(command.script, command_name,
                            u'env "PATH=$PATH" {}'.format(command_name))
<EOF>
<BOF>
from thefuck.utils import for_app, get_close_matches, replace_command
import re


def _get_failed_lifecycle(command):
    return re.search(r'\[ERROR\] Unknown lifecycle phase "(.+)"',
                     command.output)


def _getavailable_lifecycles(command):
    return re.search(
        r'Available lifecycle phases are: (.+) -> \[Help 1\]', command.output)


@for_app('mvn')
def match(command):
    failed_lifecycle = _get_failed_lifecycle(command)
    available_lifecycles = _getavailable_lifecycles(command)
    return available_lifecycles and failed_lifecycle


def get_new_command(command):
    failed_lifecycle = _get_failed_lifecycle(command)
    available_lifecycles = _getavailable_lifecycles(command)
    if available_lifecycles and failed_lifecycle:
        selected_lifecycle = get_close_matches(
            failed_lifecycle.group(1), available_lifecycles.group(1).split(", "))
        return replace_command(command, failed_lifecycle.group(1), selected_lifecycle)
    else:
        return []
<EOF>
<BOF>
import re

from thefuck.utils import for_app, replace_argument

INVALID_CHOICE = "(?<=Invalid choice: ')(.*)(?=', maybe you meant:)"
OPTIONS = "^\\s*\\*\\s(.*)"


@for_app('aws')
def match(command):
    return "usage:" in command.output and "maybe you meant:" in command.output


def get_new_command(command):
    mistake = re.search(INVALID_CHOICE, command.output).group(0)
    options = re.findall(OPTIONS, command.output, flags=re.MULTILINE)
    return [replace_argument(command.script, mistake, o) for o in options]
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('brew', at_least=2)
def match(command):
    return ('update' in command.script
            and "Error: This command updates brew itself" in command.output
            and "Use 'brew upgrade" in command.output)


def get_new_command(command):
    return command.script.replace('update', 'upgrade')
<EOF>
<BOF>
import re
from thefuck.utils import for_app
from thefuck.specific.sudo import sudo_support
from thefuck.shells import shell


@sudo_support
@for_app('cd')
def match(command):
    return (
        command.script.startswith('cd ') and any((
            'no such file or directory' in command.output.lower(),
            'cd: can\'t cd to' in command.output.lower(),
            'does not exist' in command.output.lower()
        )))


@sudo_support
def get_new_command(command):
    repl = shell.and_('mkdir -p \\1', 'cd \\1')
    return re.sub(r'^cd (.*)', repl, command.script)
<EOF>
<BOF>
from thefuck.shells import shell
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('stash' in command.script
            and 'pop' in command.script
            and 'Your local changes to the following files would be overwritten by merge' in command.output)


@git_support
def get_new_command(command):
    return shell.and_('git add --update', 'git stash pop', 'git reset .')


# make it come before the other applicable rules
priority = 900
<EOF>
<BOF>
import subprocess
from thefuck.specific.apt import apt_available
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app, eager, replace_command

enabled_by_default = apt_available


@for_app('apt', 'apt-get', 'apt-cache')
@sudo_support
def match(command):
    return 'E: Invalid operation' in command.output


@eager
def _parse_apt_operations(help_text_lines):
    is_commands_list = False
    for line in help_text_lines:
        line = line.decode().strip()
        if is_commands_list and line:
            yield line.split()[0]
        elif line.startswith('Basic commands:') \
                or line.startswith('Most used commands:'):
            is_commands_list = True


@eager
def _parse_apt_get_and_cache_operations(help_text_lines):
    is_commands_list = False
    for line in help_text_lines:
        line = line.decode().strip()
        if is_commands_list:
            if not line:
                return

            yield line.split()[0]
        elif line.startswith('Commands:'):
            is_commands_list = True


def _get_operations(app):
    proc = subprocess.Popen([app, '--help'],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    lines = proc.stdout.readlines()

    if app == 'apt':
        return _parse_apt_operations(lines)
    else:
        return _parse_apt_get_and_cache_operations(lines)


@sudo_support
def get_new_command(command):
    invalid_operation = command.output.split()[-1]
    operations = _get_operations(command.script_parts[0])
    return replace_command(command, invalid_operation, operations)
<EOF>
<BOF>
from thefuck.utils import for_app


@for_app('g++', 'clang++')
def match(command):
    return ('This file requires compiler and library support for the '
            'ISO C++ 2011 standard.' in command.output or
            '-Wc++11-extensions' in command.output)


def get_new_command(command):
    return command.script + ' -std=c++11'
<EOF>
<BOF>
from thefuck.specific.sudo import sudo_support
# add 'python' suffix to the command if
#  1) The script does not have execute permission or
#  2) is interpreted as shell script


@sudo_support
def match(command):
    return (command.script_parts
            and command.script_parts[0].endswith('.py')
            and ('Permission denied' in command.output or
                 'command not found' in command.output))


@sudo_support
def get_new_command(command):
    return 'python ' + command.script
<EOF>
<BOF>
""" Fixes wrong package names with pacman or yaourt.

For example the `llc` program is in package `llvm` so this:
    yaourt -S llc
should be:
    yaourt -S llvm
"""

from thefuck.utils import replace_command
from thefuck.specific.archlinux import get_pkgfile, archlinux_env


def match(command):
    return (command.script_parts
            and (command.script_parts[0] in ('pacman', 'yaourt')
                 or command.script_parts[0:2] == ['sudo', 'pacman'])
            and 'error: target not found:' in command.output)


def get_new_command(command):
    pgr = command.script_parts[-1]

    return replace_command(command, pgr, get_pkgfile(pgr))


enabled_by_default, _ = archlinux_env()
<EOF>
<BOF>
"""
This happens way too often

When typing really fast cause I'm a 1337 H4X0R,
I often fuck up 'ls' and type 'sl'. No more!
"""


def match(command):
    return command.script == 'sl'


def get_new_command(command):
    return 'ls'
<EOF>
<BOF>
import re

from thefuck.specific.git import git_support


@git_support
def match(command):
    return "remote delete" in command.script


@git_support
def get_new_command(command):
    return re.sub(r"delete", "remove", command.script, 1)
<EOF>
<BOF>
import array
import fcntl
from functools import partial
import mmap
import os
import pty
import signal
import sys
import termios
import tty
from .. import logs, const


def _read(f, fd):
    data = os.read(fd, 1024)
    try:
        f.write(data)
    except ValueError:
        position = const.LOG_SIZE_IN_BYTES - const.LOG_SIZE_TO_CLEAN
        f.move(0, const.LOG_SIZE_TO_CLEAN, position)
        f.seek(position)
        f.write(b'\x00' * const.LOG_SIZE_TO_CLEAN)
        f.seek(position)
    return data


def _set_pty_size(master_fd):
    buf = array.array('h', [0, 0, 0, 0])
    fcntl.ioctl(pty.STDOUT_FILENO, termios.TIOCGWINSZ, buf, True)
    fcntl.ioctl(master_fd, termios.TIOCSWINSZ, buf)


def _spawn(shell, master_read):
    """Create a spawned process.

    Modified version of pty.spawn with terminal size support.

    """
    pid, master_fd = pty.fork()

    if pid == pty.CHILD:
        os.execlp(shell, shell)

    try:
        mode = tty.tcgetattr(pty.STDIN_FILENO)
        tty.setraw(pty.STDIN_FILENO)
        restore = True
    except tty.error:    # This is the same as termios.error
        restore = False

    _set_pty_size(master_fd)
    signal.signal(signal.SIGWINCH, lambda *_: _set_pty_size(master_fd))

    try:
        pty._copy(master_fd, master_read, pty._read)
    except OSError:
        if restore:
            tty.tcsetattr(pty.STDIN_FILENO, tty.TCSAFLUSH, mode)

    os.close(master_fd)
    return os.waitpid(pid, 0)[1]


def shell_logger(output):
    """Logs shell output to the `output`.

    Works like unix script command with `-f` flag.

    """
    if not os.environ.get('SHELL'):
        logs.warn("Shell logger doesn't support your platform.")
        sys.exit(1)

    fd = os.open(output, os.O_CREAT | os.O_TRUNC | os.O_RDWR)
    os.write(fd, b'\x00' * const.LOG_SIZE_IN_BYTES)
    buffer = mmap.mmap(fd, const.LOG_SIZE_IN_BYTES, mmap.MAP_SHARED, mmap.PROT_WRITE)
    return_code = _spawn(os.environ['SHELL'], partial(_read, buffer))

    sys.exit(return_code)
<EOF>
<BOF>
import six
from ..logs import warn
from ..shells import shell
from ..utils import which


def _get_alias(known_args):
    if six.PY2:
        warn("The Fuck will drop Python 2 support soon, more details "
             "https://github.com/nvbn/thefuck/issues/685")

    alias = shell.app_alias(known_args.alias)

    if known_args.enable_experimental_instant_mode:
        if six.PY2:
            warn("Instant mode requires Python 3")
        elif not which('script'):
            warn("Instant mode requires `script` app")
        else:
            return shell.instant_mode_alias(known_args.alias)

    return alias


def print_alias(known_args):
    print(_get_alias(known_args))
<EOF>
<BOF>
# Initialize output before importing any module, that can use colorama.
from ..system import init_output

init_output()

import getpass  # noqa: E402
import os  # noqa: E402
import json  # noqa: E402
from tempfile import gettempdir  # noqa: E402
import time  # noqa: E402
import six  # noqa: E402
from psutil import Process  # noqa: E402
from .. import logs, const  # noqa: E402
from ..shells import shell  # noqa: E402
from ..conf import settings  # noqa: E402
from ..system import Path  # noqa: E402


def _get_shell_pid():
    """Returns parent process pid."""
    proc = Process(os.getpid())

    try:
        return proc.parent().pid
    except TypeError:
        return proc.parent.pid


def _get_not_configured_usage_tracker_path():
    """Returns path of special file where we store latest shell pid."""
    return Path(gettempdir()).joinpath(u'thefuck.last_not_configured_run_{}'.format(
        getpass.getuser(),
    ))


def _record_first_run():
    """Records shell pid to tracker file."""
    info = {'pid': _get_shell_pid(),
            'time': time.time()}

    mode = 'wb' if six.PY2 else 'w'
    with _get_not_configured_usage_tracker_path().open(mode) as tracker:
        json.dump(info, tracker)


def _get_previous_command():
    history = shell.get_history()

    if history:
        return history[-1]
    else:
        return None


def _is_second_run():
    """Returns `True` when we know that `fuck` called second time."""
    tracker_path = _get_not_configured_usage_tracker_path()
    if not tracker_path.exists():
        return False

    current_pid = _get_shell_pid()
    with tracker_path.open('r') as tracker:
        try:
            info = json.load(tracker)
        except ValueError:
            return False

    if not (isinstance(info, dict) and info.get('pid') == current_pid):
        return False

    return (_get_previous_command() == 'fuck' or
            time.time() - info.get('time', 0) < const.CONFIGURATION_TIMEOUT)


def _is_already_configured(configuration_details):
    """Returns `True` when alias already in shell config."""
    path = Path(configuration_details.path).expanduser()
    with path.open('r') as shell_config:
        return configuration_details.content in shell_config.read()


def _configure(configuration_details):
    """Adds alias to shell config."""
    path = Path(configuration_details.path).expanduser()
    with path.open('a') as shell_config:
        shell_config.write(u'\n')
        shell_config.write(configuration_details.content)
        shell_config.write(u'\n')


def main():
    """Shows useful information about how-to configure alias on a first run
    and configure automatically on a second.

    It'll be only visible when user type fuck and when alias isn't configured.

    """
    settings.init()
    configuration_details = shell.how_to_configure()
    if (
        configuration_details and
        configuration_details.can_configure_automatically
    ):
        if _is_already_configured(configuration_details):
            logs.already_configured(configuration_details)
            return
        elif _is_second_run():
            _configure(configuration_details)
            logs.configured_successfully(configuration_details)
            return
        else:
            _record_first_run()

    logs.how_to_configure_alias(configuration_details)
<EOF>
<BOF>
from pprint import pformat
import os
import sys
from difflib import SequenceMatcher
from .. import logs, types, const
from ..conf import settings
from ..corrector import get_corrected_commands
from ..exceptions import EmptyCommand
from ..ui import select_command
from ..utils import get_alias, get_all_executables


def _get_raw_command(known_args):
    if known_args.force_command:
        return known_args.force_command
    elif not os.environ.get('TF_HISTORY'):
        return known_args.command
    else:
        history = os.environ['TF_HISTORY'].split('\n')[::-1]
        alias = get_alias()
        executables = get_all_executables()
        for command in history:
            diff = SequenceMatcher(a=alias, b=command).ratio()
            if diff < const.DIFF_WITH_ALIAS or command in executables:
                return [command]


def fix_command(known_args):
    """Fixes previous command. Used when `thefuck` called without arguments."""
    settings.init(known_args)
    with logs.debug_time('Total'):
        logs.debug(u'Run with settings: {}'.format(pformat(settings)))
        raw_command = _get_raw_command(known_args)

        try:
            command = types.Command.from_raw_script(raw_command)
        except EmptyCommand:
            logs.debug('Empty command, nothing to do')
            return

        corrected_commands = get_corrected_commands(command)
        selected_command = select_command(corrected_commands)

        if selected_command:
            selected_command.run(command)
        else:
            sys.exit(1)
<EOF>
<BOF>
# Initialize output before importing any module, that can use colorama.
from ..system import init_output

init_output()

import os  # noqa: E402
import sys  # noqa: E402
from .. import logs  # noqa: E402
from ..argument_parser import Parser  # noqa: E402
from ..utils import get_installation_info  # noqa: E402
from ..shells import shell  # noqa: E402
from .alias import print_alias  # noqa: E402
from .fix_command import fix_command  # noqa: E402


def main():
    parser = Parser()
    known_args = parser.parse(sys.argv)

    if known_args.help:
        parser.print_help()
    elif known_args.version:
        logs.version(get_installation_info().version,
                     sys.version.split()[0], shell.info())
    elif known_args.command or 'TF_HISTORY' in os.environ:
        fix_command(known_args)
    elif known_args.alias:
        print_alias(known_args)
    elif known_args.shell_logger:
        try:
            from .shell_logger import shell_logger  # noqa: E402
        except ImportError:
            logs.warn('Shell logger supports only Linux and macOS')
        else:
            shell_logger(known_args.shell_logger)
    else:
        parser.print_usage()
<EOF>
<BOF>
import os
import msvcrt
import win_unicode_console
from .. import const


def init_output():
    import colorama
    win_unicode_console.enable()
    colorama.init()


def get_key():
    ch = msvcrt.getwch()
    if ch in ('\x00', '\xe0'):  # arrow or function key prefix?
        ch = msvcrt.getwch()  # second call returns the actual key code

    if ch in const.KEY_MAPPING:
        return const.KEY_MAPPING[ch]
    if ch == 'H':
        return const.KEY_UP
    if ch == 'P':
        return const.KEY_DOWN

    return ch


def open_command(arg):
    return 'cmd /c start ' + arg


try:
    from pathlib import Path
except ImportError:
    from pathlib2 import Path


def _expanduser(self):
    return self.__class__(os.path.expanduser(str(self)))


# pathlib's expanduser fails on windows, see http://bugs.python.org/issue19776
Path.expanduser = _expanduser
<EOF>
<BOF>
import sys


if sys.platform == 'win32':
    from .win32 import *  # noqa: F401,F403
else:
    from .unix import *  # noqa: F401,F403
<EOF>
<BOF>
import os
import sys
import tty
import termios
import colorama
from distutils.spawn import find_executable
from .. import const

init_output = colorama.init


def getch():
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        return sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)


def get_key():
    ch = getch()

    if ch in const.KEY_MAPPING:
        return const.KEY_MAPPING[ch]
    elif ch == '\x1b':
        next_ch = getch()
        if next_ch == '[':
            last_ch = getch()

            if last_ch == 'A':
                return const.KEY_UP
            elif last_ch == 'B':
                return const.KEY_DOWN

    return ch


def open_command(arg):
    if find_executable('xdg-open'):
        return 'xdg-open ' + arg
    return 'open ' + arg


try:
    from pathlib import Path
except ImportError:
    from pathlib2 import Path


def _expanduser(self):
    return self.__class__(os.path.expanduser(str(self)))


if not hasattr(Path, 'expanduser'):
    Path.expanduser = _expanduser
<EOF>
<BOF>
import json
import os
import socket
try:
    from shutil import get_terminal_size
except ImportError:
    from backports.shutil_get_terminal_size import get_terminal_size
import pyte
from .. import const, logs


def _get_socket_path():
    return os.environ.get(const.SHELL_LOGGER_SOCKET_ENV)


def is_available():
    """Returns `True` if shell logger socket available.

    :rtype: book

    """
    path = _get_socket_path()
    if not path:
        return False

    return os.path.exists(path)


def _get_last_n(n):
    with socket.socket(socket.AF_UNIX) as client:
        client.connect(_get_socket_path())
        request = json.dumps({
            "type": "list",
            "count": n,
        }) + '\n'
        client.sendall(request.encode('utf-8'))
        response = client.makefile().readline()
        return json.loads(response)['commands']


def _get_output_lines(output):
    lines = output.split('\n')
    screen = pyte.Screen(get_terminal_size().columns, len(lines))
    stream = pyte.Stream(screen)
    stream.feed('\n'.join(lines))
    return screen.display


def get_output(script):
    """Gets command output from shell logger."""
    with logs.debug_time(u'Read output from external shell logger'):
        commands = _get_last_n(const.SHELL_LOGGER_LIMIT)
        for command in commands:
            if command['command'] == script:
                lines = _get_output_lines(command['output'])
                output = '\n'.join(lines).strip()
                return output
            else:
                logs.warn("Output isn't available in shell logger")
                return None
<EOF>
<BOF>
import os
import shlex
import mmap
import re
try:
    from shutil import get_terminal_size
except ImportError:
    from backports.shutil_get_terminal_size import get_terminal_size
import six
import pyte
from ..exceptions import ScriptNotInLog
from .. import const, logs


def _group_by_calls(log):
    ps1 = os.environ['PS1']
    ps1_newlines = ps1.count('\\n') + ps1.count('\n')
    ps1_counter = 0

    script_line = None
    lines = []
    for line in log:
        if const.USER_COMMAND_MARK in line or ps1_counter > 0:
            if script_line and ps1_counter == 0:
                yield script_line, lines

            if ps1_newlines > 0:
                if ps1_counter <= 0:
                    ps1_counter = ps1_newlines
                else:
                    ps1_counter -= 1

            script_line = line
            lines = [line]
        elif script_line is not None:
            lines.append(line)

    if script_line:
        yield script_line, lines


def _get_script_group_lines(grouped, script):
    parts = shlex.split(script)

    for script_line, lines in reversed(grouped):
        if all(part in script_line for part in parts):
            return lines

    raise ScriptNotInLog


def _get_output_lines(script, log_file):
    data = log_file.read().decode()
    data = re.sub(r'\x00+$', '', data)
    lines = data.split('\n')
    grouped = list(_group_by_calls(lines))
    script_lines = _get_script_group_lines(grouped, script)
    screen = pyte.Screen(get_terminal_size().columns, len(script_lines))
    stream = pyte.Stream(screen)
    stream.feed('\n'.join(script_lines))
    return screen.display


def _skip_old_lines(log_file):
    size = os.path.getsize(os.environ['THEFUCK_OUTPUT_LOG'])
    if size > const.LOG_SIZE_IN_BYTES:
        log_file.seek(size - const.LOG_SIZE_IN_BYTES)


def get_output(script):
    """Reads script output from log.

    :type script: str
    :rtype: str | None

    """
    if six.PY2:
        logs.warn('Experimental instant mode is Python 3+ only')
        return None

    if 'THEFUCK_OUTPUT_LOG' not in os.environ:
        logs.warn("Output log isn't specified")
        return None

    if const.USER_COMMAND_MARK not in os.environ.get('PS1', ''):
        logs.warn(
            "PS1 doesn't contain user command mark, please ensure "
            "that PS1 is not changed after The Fuck alias initialization")
        return None

    try:
        with logs.debug_time(u'Read output from log'):
            fd = os.open(os.environ['THEFUCK_OUTPUT_LOG'], os.O_RDONLY)
            buffer = mmap.mmap(fd, const.LOG_SIZE_IN_BYTES, mmap.MAP_SHARED, mmap.PROT_READ)
            _skip_old_lines(buffer)
            lines = _get_output_lines(script, buffer)
            output = '\n'.join(lines).strip()
            logs.debug(u'Received output: {}'.format(output))
            return output
    except OSError:
        logs.warn("Can't read output log")
        return None
    except ScriptNotInLog:
        logs.warn("Script not found in output log")
        return None
<EOF>
<BOF>
from ..conf import settings
from . import read_log, rerun, shell_logger


def get_output(script, expanded):
    """Get output of the script.

    :param script: Console script.
    :type script: str
    :param expanded: Console script with expanded aliases.
    :type expanded: str
    :rtype: str

    """
    if shell_logger.is_available():
        return shell_logger.get_output(script)
    if settings.instant_mode:
        return read_log.get_output(script)
    else:
        return rerun.get_output(script, expanded)
<EOF>
<BOF>
import os
import shlex
from subprocess import Popen, PIPE, STDOUT
from psutil import AccessDenied, Process, TimeoutExpired
from .. import logs
from ..conf import settings


def _kill_process(proc):
    """Tries to kill the process otherwise just logs a debug message, the
    process will be killed when thefuck terminates.

    :type proc: Process

    """
    try:
        proc.kill()
    except AccessDenied:
        logs.debug(u'Rerun: process PID {} ({}) could not be terminated'.format(
            proc.pid, proc.exe()))


def _wait_output(popen, is_slow):
    """Returns `True` if we can get output of the command in the
    `settings.wait_command` time.

    Command will be killed if it wasn't finished in the time.

    :type popen: Popen
    :rtype: bool

    """
    proc = Process(popen.pid)
    try:
        proc.wait(settings.wait_slow_command if is_slow
                  else settings.wait_command)
        return True
    except TimeoutExpired:
        for child in proc.children(recursive=True):
            _kill_process(child)
        _kill_process(proc)
        return False


def get_output(script, expanded):
    """Runs the script and obtains stdin/stderr.

    :type script: str
    :type expanded: str
    :rtype: str | None

    """
    env = dict(os.environ)
    env.update(settings.env)

    is_slow = shlex.split(expanded) in settings.slow_commands
    with logs.debug_time(u'Call: {}; with env: {}; is slow: '.format(
            script, env, is_slow)):
        result = Popen(expanded, shell=True, stdin=PIPE,
                       stdout=PIPE, stderr=STDOUT, env=env)
        if _wait_output(result, is_slow):
            output = result.stdout.read().decode('utf-8')
            logs.debug(u'Received output: {}'.format(output))
            return output
        else:
            logs.debug(u'Execution timed out!')
            return None
<EOF>
<BOF>
"""Package with shell specific actions, each shell class should
implement `from_shell`, `to_shell`, `app_alias`, `put_to_history` and
`get_aliases` methods.
"""
import os
from psutil import Process
from .bash import Bash
from .fish import Fish
from .generic import Generic
from .tcsh import Tcsh
from .zsh import Zsh
from .powershell import Powershell

shells = {'bash': Bash,
          'fish': Fish,
          'zsh': Zsh,
          'csh': Tcsh,
          'tcsh': Tcsh,
          'powershell': Powershell,
          'pwsh': Powershell}


def _get_shell_from_env():
    name = os.environ.get('TF_SHELL')

    if name in shells:
        return shells[name]()


def _get_shell_from_proc():
    proc = Process(os.getpid())

    while proc is not None and proc.pid > 0:
        try:
            name = proc.name()
        except TypeError:
            name = proc.name

        name = os.path.splitext(name)[0]

        if name in shells:
            return shells[name]()

        try:
            proc = proc.parent()
        except TypeError:
            proc = proc.parent

    return Generic()


shell = _get_shell_from_env() or _get_shell_from_proc()
<EOF>
<BOF>
from subprocess import Popen, PIPE
from time import time
import os
from ..utils import DEVNULL, memoize
from .generic import Generic


class Tcsh(Generic):
    def app_alias(self, alias_name):
        return ("alias {0} 'setenv TF_SHELL tcsh && setenv TF_ALIAS {0} && "
                "set fucked_cmd=`history -h 2 | head -n 1` && "
                "eval `thefuck ${{fucked_cmd}}`'").format(alias_name)

    def _parse_alias(self, alias):
        name, value = alias.split("\t", 1)
        return name, value

    @memoize
    def get_aliases(self):
        proc = Popen(['tcsh', '-ic', 'alias'], stdout=PIPE, stderr=DEVNULL)
        return dict(
            self._parse_alias(alias)
            for alias in proc.stdout.read().decode('utf-8').split('\n')
            if alias and '\t' in alias)

    def _get_history_file_name(self):
        return os.environ.get("HISTFILE",
                              os.path.expanduser('~/.history'))

    def _get_history_line(self, command_script):
        return u'#+{}\n{}\n'.format(int(time()), command_script)

    def how_to_configure(self):
        return self._create_shell_configuration(
            content=u'eval `thefuck --alias`',
            path='~/.tcshrc',
            reload='tcsh')
<EOF>
<BOF>
import io
import os
import shlex
import six
from collections import namedtuple
from ..logs import warn
from ..utils import memoize
from ..conf import settings
from ..system import Path


ShellConfiguration = namedtuple('ShellConfiguration', (
    'content', 'path', 'reload', 'can_configure_automatically'))


class Generic(object):
    def get_aliases(self):
        return {}

    def _expand_aliases(self, command_script):
        aliases = self.get_aliases()
        binary = command_script.split(' ')[0]
        if binary in aliases:
            return command_script.replace(binary, aliases[binary], 1)
        else:
            return command_script

    def from_shell(self, command_script):
        """Prepares command before running in app."""
        return self._expand_aliases(command_script)

    def to_shell(self, command_script):
        """Prepares command for running in shell."""
        return command_script

    def app_alias(self, alias_name):
        return "alias {0}='eval $(TF_ALIAS={0} PYTHONIOENCODING=utf-8 " \
               "thefuck $(fc -ln -1))'".format(alias_name)

    def instant_mode_alias(self, alias_name):
        warn("Instant mode not supported by your shell")
        return self.app_alias(alias_name)

    def _get_history_file_name(self):
        return ''

    def _get_history_line(self, command_script):
        return ''

    @memoize
    def get_history(self):
        return list(self._get_history_lines())

    def _get_history_lines(self):
        """Returns list of history entries."""
        history_file_name = self._get_history_file_name()
        if os.path.isfile(history_file_name):
            with io.open(history_file_name, 'r',
                         encoding='utf-8', errors='ignore') as history_file:

                lines = history_file.readlines()
                if settings.history_limit:
                    lines = lines[-settings.history_limit:]

                for line in lines:
                    prepared = self._script_from_history(line) \
                        .strip()
                    if prepared:
                        yield prepared

    def and_(self, *commands):
        return u' && '.join(commands)

    def or_(self, *commands):
        return u' || '.join(commands)

    def how_to_configure(self):
        return

    def split_command(self, command):
        """Split the command using shell-like syntax."""
        encoded = self.encode_utf8(command)

        try:
            splitted = [s.replace("??", "\\ ") for s in shlex.split(encoded.replace('\\ ', '??'))]
        except ValueError:
            splitted = encoded.split(' ')

        return self.decode_utf8(splitted)

    def encode_utf8(self, command):
        if six.PY2:
            return command.encode('utf8')
        return command

    def decode_utf8(self, command_parts):
        if six.PY2:
            return [s.decode('utf8') for s in command_parts]
        return command_parts

    def quote(self, s):
        """Return a shell-escaped version of the string s."""

        if six.PY2:
            from pipes import quote
        else:
            from shlex import quote

        return quote(s)

    def _script_from_history(self, line):
        return line

    def put_to_history(self, command):
        """Adds fixed command to shell history.

        In most of shells we change history on shell-level, but not
        all shells support it (Fish).

        """

    def get_builtin_commands(self):
        """Returns shells builtin commands."""
        return ['alias', 'bg', 'bind', 'break', 'builtin', 'case', 'cd',
                'command', 'compgen', 'complete', 'continue', 'declare',
                'dirs', 'disown', 'echo', 'enable', 'eval', 'exec', 'exit',
                'export', 'fc', 'fg', 'getopts', 'hash', 'help', 'history',
                'if', 'jobs', 'kill', 'let', 'local', 'logout', 'popd',
                'printf', 'pushd', 'pwd', 'read', 'readonly', 'return', 'set',
                'shift', 'shopt', 'source', 'suspend', 'test', 'times', 'trap',
                'type', 'typeset', 'ulimit', 'umask', 'unalias', 'unset',
                'until', 'wait', 'while']

    def info(self):
        """Returns the name and version of the current shell"""
        return 'Generic Shell'

    def _create_shell_configuration(self, content, path, reload):
        return ShellConfiguration(
            content=content,
            path=path,
            reload=reload,
            can_configure_automatically=Path(path).expanduser().exists())
<EOF>
<BOF>
from subprocess import Popen, PIPE
from time import time
import os
import sys
import six
from .. import logs
from ..conf import settings
from ..utils import DEVNULL, cache
from .generic import Generic


@cache('~/.config/fish/config.fish', '~/.config/fish/functions')
def _get_functions(overridden):
    proc = Popen(['fish', '-ic', 'functions'], stdout=PIPE, stderr=DEVNULL)
    functions = proc.stdout.read().decode('utf-8').strip().split('\n')
    return {func: func for func in functions if func not in overridden}


@cache('~/.config/fish/config.fish')
def _get_aliases(overridden):
    aliases = {}
    proc = Popen(['fish', '-ic', 'alias'], stdout=PIPE, stderr=DEVNULL)
    alias_out = proc.stdout.read().decode('utf-8').strip()
    if not alias_out:
        return aliases
    for alias in alias_out.split('\n'):
        for separator in (' ', '='):
            split_alias = alias.replace('alias ', '', 1).split(separator, 1)
            if len(split_alias) == 2:
                name, value = split_alias
                break
        else:
            continue
        if name not in overridden:
            aliases[name] = value
    return aliases


class Fish(Generic):
    def _get_overridden_aliases(self):
        overridden = os.environ.get('THEFUCK_OVERRIDDEN_ALIASES',
                                    os.environ.get('TF_OVERRIDDEN_ALIASES', ''))
        default = {'cd', 'grep', 'ls', 'man', 'open'}
        for alias in overridden.split(','):
            default.add(alias.strip())
        return default

    def app_alias(self, alias_name):
        if settings.alter_history:
            alter_history = ('    builtin history delete --exact'
                             ' --case-sensitive -- $fucked_up_command\n'
                             '    builtin history merge ^ /dev/null\n')
        else:
            alter_history = ''
        # It is VERY important to have the variables declared WITHIN the alias
        return ('function {0} -d "Correct your previous console command"\n'
                '  set -l fucked_up_command $history[1]\n'
                '  env TF_SHELL=fish TF_ALIAS={0} PYTHONIOENCODING=utf-8'
                ' thefuck $fucked_up_command | read -l unfucked_command\n'
                '  if [ "$unfucked_command" != "" ]\n'
                '    eval $unfucked_command\n{1}'
                '  end\n'
                'end').format(alias_name, alter_history)

    def get_aliases(self):
        overridden = self._get_overridden_aliases()
        functions = _get_functions(overridden)
        raw_aliases = _get_aliases(overridden)
        functions.update(raw_aliases)
        return functions

    def _expand_aliases(self, command_script):
        aliases = self.get_aliases()
        binary = command_script.split(' ')[0]
        if binary in aliases and aliases[binary] != binary:
            return command_script.replace(binary, aliases[binary], 1)
        elif binary in aliases:
            return u'fish -ic "{}"'.format(command_script.replace('"', r'\"'))
        else:
            return command_script

    def _get_history_file_name(self):
        return os.path.expanduser('~/.config/fish/fish_history')

    def _get_history_line(self, command_script):
        return u'- cmd: {}\n   when: {}\n'.format(command_script, int(time()))

    def _script_from_history(self, line):
        if '- cmd: ' in line:
            return line.split('- cmd: ', 1)[1]
        else:
            return ''

    def and_(self, *commands):
        return u'; and '.join(commands)

    def or_(self, *commands):
        return u'; or '.join(commands)

    def how_to_configure(self):
        return self._create_shell_configuration(
            content=u"thefuck --alias | source",
            path='~/.config/fish/config.fish',
            reload='fish')

    def info(self):
        """Returns the name and version of the current shell"""
        proc = Popen(['fish', '-c', 'echo $FISH_VERSION'],
                     stdout=PIPE, stderr=DEVNULL)
        version = proc.stdout.read().decode('utf-8').strip()
        return u'Fish Shell {}'.format(version)

    def put_to_history(self, command):
        try:
            return self._put_to_history(command)
        except IOError:
            logs.exception("Can't update history", sys.exc_info())

    def _put_to_history(self, command_script):
        """Puts command script to shell history."""
        history_file_name = self._get_history_file_name()
        if os.path.isfile(history_file_name):
            with open(history_file_name, 'a') as history:
                entry = self._get_history_line(command_script)
                if six.PY2:
                    history.write(entry.encode('utf-8'))
                else:
                    history.write(entry)
<EOF>
<BOF>
from .generic import Generic, ShellConfiguration


class Powershell(Generic):
    def app_alias(self, alias_name):
        return 'function ' + alias_name + ' {\n' \
               '    $history = (Get-History -Count 1).CommandLine;\n' \
               '    if (-not [string]::IsNullOrWhiteSpace($history)) {\n' \
               '        $fuck = $(thefuck $args $history);\n' \
               '        if (-not [string]::IsNullOrWhiteSpace($fuck)) {\n' \
               '            if ($fuck.StartsWith("echo")) { $fuck = $fuck.Substring(5); }\n' \
               '            else { iex "$fuck"; }\n' \
               '        }\n' \
               '    }\n' \
               '    [Console]::ResetColor() \n' \
               '}\n'

    def and_(self, *commands):
        return u' -and '.join('({0})'.format(c) for c in commands)

    def how_to_configure(self):
        return ShellConfiguration(
            content=u'iex "thefuck --alias"',
            path='$profile',
            reload='& $profile',
            can_configure_automatically=False)
<EOF>
<BOF>
from time import time
import os
from subprocess import Popen, PIPE
from tempfile import gettempdir
from uuid import uuid4
from ..conf import settings
from ..const import ARGUMENT_PLACEHOLDER, USER_COMMAND_MARK
from ..utils import DEVNULL, memoize
from .generic import Generic


class Zsh(Generic):
    def app_alias(self, alias_name):
        # It is VERY important to have the variables declared WITHIN the function
        return '''
            {name} () {{
                TF_PYTHONIOENCODING=$PYTHONIOENCODING;
                export TF_SHELL=zsh;
                export TF_ALIAS={name};
                TF_SHELL_ALIASES=$(alias);
                export TF_SHELL_ALIASES;
                TF_HISTORY="$(fc -ln -10)";
                export TF_HISTORY;
                export PYTHONIOENCODING=utf-8;
                TF_CMD=$(
                    thefuck {argument_placeholder} $@
                ) && eval $TF_CMD;
                unset TF_HISTORY;
                export PYTHONIOENCODING=$TF_PYTHONIOENCODING;
                {alter_history}
            }}
        '''.format(
            name=alias_name,
            argument_placeholder=ARGUMENT_PLACEHOLDER,
            alter_history=('test -n "$TF_CMD" && print -s $TF_CMD'
                           if settings.alter_history else ''))

    def instant_mode_alias(self, alias_name):
        if os.environ.get('THEFUCK_INSTANT_MODE', '').lower() == 'true':
            mark = ('%{' +
                    USER_COMMAND_MARK + '\b' * len(USER_COMMAND_MARK)
                    + '%}')
            return '''
                export PS1="{user_command_mark}$PS1";
                {app_alias}
            '''.format(user_command_mark=mark,
                       app_alias=self.app_alias(alias_name))
        else:
            log_path = os.path.join(
                gettempdir(), 'thefuck-script-log-{}'.format(uuid4().hex))
            return '''
                export THEFUCK_INSTANT_MODE=True;
                export THEFUCK_OUTPUT_LOG={log};
                thefuck --shell-logger {log};
                rm -f {log};
                exit
            '''.format(log=log_path)

    def _parse_alias(self, alias):
        name, value = alias.split('=', 1)
        if value[0] == value[-1] == '"' or value[0] == value[-1] == "'":
            value = value[1:-1]
        return name, value

    @memoize
    def get_aliases(self):
        raw_aliases = os.environ.get('TF_SHELL_ALIASES', '').split('\n')
        return dict(self._parse_alias(alias)
                    for alias in raw_aliases if alias and '=' in alias)

    def _get_history_file_name(self):
        return os.environ.get("HISTFILE",
                              os.path.expanduser('~/.zsh_history'))

    def _get_history_line(self, command_script):
        return u': {}:0;{}\n'.format(int(time()), command_script)

    def _script_from_history(self, line):
        if ';' in line:
            return line.split(';', 1)[1]
        else:
            return ''

    def how_to_configure(self):
        return self._create_shell_configuration(
            content=u'eval $(thefuck --alias)',
            path='~/.zshrc',
            reload='source ~/.zshrc')

    def info(self):
        """Returns the name and version of the current shell"""
        proc = Popen(['zsh', '-c', 'echo $ZSH_VERSION'],
                     stdout=PIPE, stderr=DEVNULL)
        version = proc.stdout.read().decode('utf-8').strip()
        return u'ZSH {}'.format(version)
<EOF>
<BOF>
import os
from subprocess import Popen, PIPE
from tempfile import gettempdir
from uuid import uuid4
from ..conf import settings
from ..const import ARGUMENT_PLACEHOLDER, USER_COMMAND_MARK
from ..utils import DEVNULL, memoize
from .generic import Generic


class Bash(Generic):
    def app_alias(self, alias_name):
        # It is VERY important to have the variables declared WITHIN the function
        return '''
            function {name} () {{
                TF_PYTHONIOENCODING=$PYTHONIOENCODING;
                export TF_SHELL=bash;
                export TF_ALIAS={name};
                export TF_SHELL_ALIASES=$(alias);
                export TF_HISTORY=$(fc -ln -10);
                export PYTHONIOENCODING=utf-8;
                TF_CMD=$(
                    thefuck {argument_placeholder} $@
                ) && eval $TF_CMD;
                unset TF_HISTORY;
                export PYTHONIOENCODING=$TF_PYTHONIOENCODING;
                {alter_history}
            }}
        '''.format(
            name=alias_name,
            argument_placeholder=ARGUMENT_PLACEHOLDER,
            alter_history=('history -s $TF_CMD;'
                           if settings.alter_history else ''))

    def instant_mode_alias(self, alias_name):
        if os.environ.get('THEFUCK_INSTANT_MODE', '').lower() == 'true':
            mark = USER_COMMAND_MARK + '\b' * len(USER_COMMAND_MARK)
            return '''
                export PS1="{user_command_mark}$PS1";
                {app_alias}
            '''.format(user_command_mark=mark,
                       app_alias=self.app_alias(alias_name))
        else:
            log_path = os.path.join(
                gettempdir(), 'thefuck-script-log-{}'.format(uuid4().hex))
            return '''
                export THEFUCK_INSTANT_MODE=True;
                export THEFUCK_OUTPUT_LOG={log};
                thefuck --shell-logger {log};
                rm {log};
                exit
            '''.format(log=log_path)

    def _parse_alias(self, alias):
        name, value = alias.replace('alias ', '', 1).split('=', 1)
        if value[0] == value[-1] == '"' or value[0] == value[-1] == "'":
            value = value[1:-1]
        return name, value

    @memoize
    def get_aliases(self):
        raw_aliases = os.environ.get('TF_SHELL_ALIASES', '').split('\n')
        return dict(self._parse_alias(alias)
                    for alias in raw_aliases if alias and '=' in alias)

    def _get_history_file_name(self):
        return os.environ.get("HISTFILE",
                              os.path.expanduser('~/.bash_history'))

    def _get_history_line(self, command_script):
        return u'{}\n'.format(command_script)

    def how_to_configure(self):
        if os.path.join(os.path.expanduser('~'), '.bashrc'):
            config = '~/.bashrc'
        elif os.path.join(os.path.expanduser('~'), '.bash_profile'):
            config = '~/.bash_profile'
        else:
            config = 'bash config'

        return self._create_shell_configuration(
            content=u'eval $(thefuck --alias)',
            path=config,
            reload=u'source {}'.format(config))

    def info(self):
        """Returns the name and version of the current shell"""
        proc = Popen(['bash', '-c', 'echo $BASH_VERSION'],
                     stdout=PIPE, stderr=DEVNULL)
        version = proc.stdout.read().decode('utf-8').strip()
        return u'Bash {}'.format(version)
<EOF>
<BOF>
import re
from subprocess import Popen, PIPE
from thefuck.utils import memoize, eager, which

npm_available = bool(which('npm'))


@memoize
@eager
def get_scripts():
    """Get custom npm scripts."""
    proc = Popen(['npm', 'run-script'], stdout=PIPE)
    should_yeild = False
    for line in proc.stdout.readlines():
        line = line.decode()
        if 'available via `npm run-script`:' in line:
            should_yeild = True
            continue

        if should_yeild and re.match(r'^  [^ ]+', line):
            yield line.strip().split(' ')[0]
<EOF>
<BOF>
""" This file provide some utility functions for Arch Linux specific rules."""
import subprocess
from .. import utils


@utils.memoize
def get_pkgfile(command):
    """ Gets the packages that provide the given command using `pkgfile`.

    If the command is of the form `sudo foo`, searches for the `foo` command
    instead.
    """
    try:
        command = command.strip()

        if command.startswith('sudo '):
            command = command[5:]

        command = command.split(" ")[0]

        packages = subprocess.check_output(
            ['pkgfile', '-b', '-v', command],
            universal_newlines=True, stderr=utils.DEVNULL
        ).splitlines()

        return [package.split()[0] for package in packages]
    except subprocess.CalledProcessError as err:
        if err.returncode == 1 and err.output == "":
            return []
        else:
            raise err


def archlinux_env():
    if utils.which('yaourt'):
        pacman = 'yaourt'
    elif utils.which('pacman'):
        pacman = 'sudo pacman'
    else:
        return False, None

    enabled_by_default = utils.which('pkgfile')

    return enabled_by_default, pacman
<EOF>
<BOF>
import subprocess
from ..utils import memoize, which


brew_available = bool(which('brew'))


@memoize
def get_brew_path_prefix():
    """To get brew path"""
    try:
        return subprocess.check_output(['brew', '--prefix'],
                                       universal_newlines=True).strip()
    except Exception:
        return None
<EOF>
<BOF>
from thefuck.utils import which

apt_available = bool(which('apt-get'))
<EOF>
<BOF>
from thefuck.utils import which

dnf_available = bool(which('dnf'))
<EOF>
<BOF>
import six
from decorator import decorator


@decorator
def sudo_support(fn, command):
    """Removes sudo before calling fn and adds it after."""
    if not command.script.startswith('sudo '):
        return fn(command)

    result = fn(command.update(script=command.script[5:]))

    if result and isinstance(result, six.string_types):
        return u'sudo {}'.format(result)
    elif isinstance(result, list):
        return [u'sudo {}'.format(x) for x in result]
    else:
        return result
<EOF>
<BOF>
import re
from decorator import decorator
from ..utils import is_app
from ..shells import shell


@decorator
def git_support(fn, command):
    """Resolves git aliases and supports testing for both git and hub."""
    # supports GitHub's `hub` command
    # which is recommended to be used with `alias git=hub`
    # but at this point, shell aliases have already been resolved
    if not is_app(command, 'git', 'hub'):
        return False

    # perform git aliases expansion
    if 'trace: alias expansion:' in command.output:
        search = re.search("trace: alias expansion: ([^ ]*) => ([^\n]*)",
                           command.output)
        alias = search.group(1)

        # by default git quotes everything, for example:
        #     'commit' '--amend'
        # which is surprising and does not allow to easily test for
        # eg. 'git commit'
        expansion = ' '.join(shell.quote(part)
                             for part in shell.split_command(search.group(2)))
        new_script = command.script.replace(alias, expansion)

        command = command.update(script=new_script)

    return fn(command)
<EOF>
